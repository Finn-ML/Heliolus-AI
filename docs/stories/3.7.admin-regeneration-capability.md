# Story 3.7: Admin Regeneration Capability

## Status
Draft

## Story

**As an** admin user,
**I want** to manually regenerate AI analysis for specific assessments,
**So that** I can fix issues or update content when needed

## Acceptance Criteria

1. POST `/v1/admin/assessments/:id/regenerate-ai` endpoint created
2. Endpoint requires ADMIN role (403 for non-admins)
3. Force regenerates even if content already exists
4. Updates existing database fields (not create new)
5. Returns new AI content in response
6. Audit log entry created for regeneration
7. Frontend admin button to trigger regeneration
8. Success/error notifications in UI

## Tasks / Subtasks

- [ ] Task 1: Create admin regeneration endpoint (AC: 1, 2)
  - [ ] Open `backend/src/routes/admin.routes.ts`
  - [ ] Add POST route for regeneration
  - [ ] Apply admin role middleware
  - [ ] Follow existing admin endpoint patterns

- [ ] Task 2: Implement force regeneration logic (AC: 3, 4)
  - [ ] Call assessmentService.generateAndStoreAIAnalysis
  - [ ] Add forceRegenerate parameter to override checks
  - [ ] Ensure overwrites existing content
  - [ ] Return updated assessment data

- [ ] Task 3: Add audit logging (AC: 6)
  - [ ] Create audit log entry for regeneration
  - [ ] Include admin user ID
  - [ ] Record timestamp and assessment ID
  - [ ] Store reason if provided

- [ ] Task 4: Return regenerated content (AC: 5)
  - [ ] Structure response with new AI data
  - [ ] Include generation timestamp
  - [ ] Add success confirmation
  - [ ] Handle errors gracefully

- [ ] Task 5: Add admin UI button (AC: 7)
  - [ ] Add to admin assessment detail view
  - [ ] Show only for ADMIN role
  - [ ] Confirmation dialog before regeneration
  - [ ] Loading state during generation

- [ ] Task 6: Implement UI notifications (AC: 8)
  - [ ] Success toast on completion
  - [ ] Error alert on failure
  - [ ] Show generation progress
  - [ ] Auto-refresh assessment data

## Dev Notes

### Admin Routes Location
[Source: backend/src/routes/admin.routes.ts]

This file contains all admin-only endpoints. It's a large file (48KB) with comprehensive admin functionality.

### Endpoint Implementation

```typescript
// POST /admin/assessments/:id/regenerate-ai - Force regenerate AI analysis
server.post('/assessments/:id/regenerate-ai', {
  schema: {
    description: 'Force regenerate AI analysis for an assessment (Admin only)',
    tags: ['Admin', 'Assessments', 'AI'],
    params: {
      type: 'object',
      properties: {
        id: { type: 'string' }
      },
      required: ['id']
    },
    body: {
      type: 'object',
      properties: {
        reason: { type: 'string', description: 'Reason for regeneration' }
      }
    },
    response: {
      200: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          data: {
            type: 'object',
            properties: {
              riskAnalysis: { type: 'object' },
              strategyMatrix: { type: 'array' },
              generatedAt: { type: 'string', format: 'date-time' },
              previousGeneratedAt: { type: 'string', format: 'date-time' }
            }
          },
          message: { type: 'string' }
        }
      },
      403: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          error: { type: 'string' }
        }
      }
    }
  },
  preHandler: [server.authenticate, server.requireRole('ADMIN')]
}, async (request, reply) => {
  const { id } = request.params as { id: string };
  const { reason } = request.body as { reason?: string };
  const adminUser = request.context.user;

  try {
    // Get existing assessment to store previous data
    const existingAssessment = await prisma.assessment.findUnique({
      where: { id },
      select: {
        aiGeneratedAt: true,
        aiRiskAnalysis: true,
        aiStrategyMatrix: true
      }
    });

    if (!existingAssessment) {
      return reply.code(404).send({
        success: false,
        error: 'Assessment not found'
      });
    }

    const previousGeneratedAt = existingAssessment.aiGeneratedAt;

    // Force regeneration
    const result = await assessmentService.generateAndStoreAIAnalysis(
      id,
      request.context,
      { forceRegenerate: true }
    );

    if (!result.success) {
      return reply.code(500).send({
        success: false,
        error: result.error || 'Failed to regenerate AI analysis'
      });
    }

    // Create audit log entry
    await prisma.auditLog.create({
      data: {
        userId: adminUser.id,
        action: 'AI_ANALYSIS_REGENERATED',
        entityType: 'Assessment',
        entityId: id,
        metadata: {
          reason: reason || 'Manual regeneration by admin',
          previousGeneratedAt,
          newGeneratedAt: result.data.generatedAt
        },
        ipAddress: request.ip,
        userAgent: request.headers['user-agent']
      }
    });

    // Log the regeneration
    request.log.info({
      adminId: adminUser.id,
      assessmentId: id,
      reason,
      previousGeneratedAt,
      newGeneratedAt: result.data.generatedAt
    }, 'AI analysis regenerated by admin');

    reply.code(200).send({
      success: true,
      data: {
        ...result.data,
        previousGeneratedAt
      },
      message: 'AI analysis successfully regenerated'
    });
  } catch (error) {
    request.log.error(error);
    reply.code(500).send({
      success: false,
      error: 'An error occurred during regeneration'
    });
  }
});
```

### Service Method Update
[Source: backend/src/services/assessment.service.ts]

Update the generateAndStoreAIAnalysis method to accept options:

```typescript
async generateAndStoreAIAnalysis(
  assessmentId: string,
  context?: ServiceContext,
  options?: { forceRegenerate?: boolean }
): Promise<ServiceResponse<any>> {
  try {
    const assessment = await this.db.assessment.findUnique({
      where: { id: assessmentId },
      include: {
        gaps: true,
        risks: true,
        organization: true
      }
    });

    if (!assessment) {
      return this.error('Assessment not found');
    }

    // Skip check if force regeneration
    if (!options?.forceRegenerate) {
      if (assessment.aiRiskAnalysis && assessment.aiStrategyMatrix) {
        this.logger.info('AI analysis already exists', { assessmentId });
        return this.success({
          riskAnalysis: assessment.aiRiskAnalysis,
          strategyMatrix: assessment.aiStrategyMatrix,
          generatedAt: assessment.aiGeneratedAt
        });
      }
    } else {
      this.logger.info('Force regenerating AI analysis', { assessmentId });
    }

    // Continue with generation...
    // [rest of the generation logic]
  }
}
```

### Frontend Admin UI
[Source: frontend/src/pages/admin/AssessmentDetail.tsx]

Add regeneration button to admin assessment detail view:

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useState } from 'react';
import { AlertDialog, AlertDialogContent, AlertDialogDescription } from '@/components/ui/alert-dialog';
import { Button } from '@/components/ui/button';
import { RefreshCw } from 'lucide-react';
import { toast } from 'sonner';

const RegenerateAIButton = ({ assessmentId }: { assessmentId: string }) => {
  const [showConfirm, setShowConfirm] = useState(false);
  const [reason, setReason] = useState('');
  const queryClient = useQueryClient();

  const regenerateMutation = useMutation({
    mutationFn: async () => {
      return apiRequest(`/admin/assessments/${assessmentId}/regenerate-ai`, {
        method: 'POST',
        body: JSON.stringify({ reason })
      });
    },
    onSuccess: (data) => {
      toast.success('AI analysis regenerated successfully');
      // Invalidate assessment cache
      queryClient.invalidateQueries(['assessment', assessmentId]);
      queryClient.invalidateQueries(['assessment', assessmentId, 'ai-analysis']);
      setShowConfirm(false);
      setReason('');
    },
    onError: (error: any) => {
      toast.error(error.message || 'Failed to regenerate AI analysis');
    }
  });

  return (
    <>
      <Button
        onClick={() => setShowConfirm(true)}
        variant="outline"
        className="gap-2"
        disabled={regenerateMutation.isPending}
      >
        <RefreshCw className={cn(
          "h-4 w-4",
          regenerateMutation.isPending && "animate-spin"
        )} />
        Regenerate AI Analysis
      </Button>

      <AlertDialog open={showConfirm} onOpenChange={setShowConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Regenerate AI Analysis?</AlertDialogTitle>
            <AlertDialogDescription>
              This will replace the existing AI-generated content with new analysis.
              This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>

          <div className="space-y-4">
            <div>
              <Label htmlFor="reason">Reason for regeneration (optional)</Label>
              <Textarea
                id="reason"
                value={reason}
                onChange={(e) => setReason(e.target.value)}
                placeholder="e.g., Updated assessment data, fix incorrect analysis..."
                className="mt-2"
              />
            </div>
          </div>

          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => regenerateMutation.mutate()}
              disabled={regenerateMutation.isPending}
            >
              {regenerateMutation.isPending ? 'Regenerating...' : 'Regenerate'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};
```

### Role Middleware
[Source: backend/src/middleware/rbac.middleware.ts]

Use existing role-based access control:

```typescript
server.decorate('requireRole', (role: UserRole) => {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const user = request.context?.user;

    if (!user) {
      return reply.code(401).send({
        success: false,
        error: 'Authentication required'
      });
    }

    if (user.role !== role && user.role !== 'ADMIN') {
      return reply.code(403).send({
        success: false,
        error: 'Insufficient permissions'
      });
    }
  };
});
```

### API Client Update
[Source: frontend/src/lib/api.ts]

Add admin API method:

```typescript
export const adminApi = {
  // ... existing methods ...

  regenerateAIAnalysis: async (assessmentId: string, reason?: string) => {
    return apiRequest<{
      riskAnalysis: any;
      strategyMatrix: any[];
      generatedAt: string;
      previousGeneratedAt: string;
    }>(`/admin/assessments/${assessmentId}/regenerate-ai`, {
      method: 'POST',
      body: JSON.stringify({ reason })
    });
  }
};
```

### Audit Log Display
[Source: frontend/src/pages/admin/AuditLogs.tsx]

Display regeneration events in audit log:

```typescript
const actionLabels: Record<string, string> = {
  // ... existing actions ...
  'AI_ANALYSIS_REGENERATED': 'AI Analysis Regenerated'
};

// In the audit log display
{log.action === 'AI_ANALYSIS_REGENERATED' && (
  <div className="text-sm text-gray-500 mt-1">
    <p>Reason: {log.metadata.reason}</p>
    <p>Previous: {formatDate(log.metadata.previousGeneratedAt)}</p>
    <p>New: {formatDate(log.metadata.newGeneratedAt)}</p>
  </div>
)}
```

## Testing

### Testing Standards

**Test File Location:**
`backend/tests/integration/admin-regeneration.test.ts`

**Integration Test:**
```typescript
import { describe, it, expect } from 'vitest';
import { app } from '../test-setup';

describe('POST /v1/admin/assessments/:id/regenerate-ai', () => {
  let adminToken: string;
  let userToken: string;
  let assessmentId: string;

  beforeAll(async () => {
    adminToken = await getAdminAuthToken();
    userToken = await getUserAuthToken();
    assessmentId = await createTestAssessmentWithAI();
  });

  it('should require admin role', async () => {
    const response = await app.inject({
      method: 'POST',
      url: `/v1/admin/assessments/${assessmentId}/regenerate-ai`,
      headers: {
        authorization: `Bearer ${userToken}` // Non-admin user
      }
    });

    expect(response.statusCode).toBe(403);
  });

  it('should regenerate AI analysis when admin', async () => {
    // Get original data
    const original = await app.inject({
      method: 'GET',
      url: `/v1/assessments/${assessmentId}/ai-analysis`,
      headers: {
        authorization: `Bearer ${adminToken}`
      }
    });

    const originalData = JSON.parse(original.body);
    const originalGeneratedAt = originalData.data.generatedAt;

    // Wait a bit to ensure different timestamp
    await new Promise(resolve => setTimeout(resolve, 100));

    // Regenerate
    const response = await app.inject({
      method: 'POST',
      url: `/v1/admin/assessments/${assessmentId}/regenerate-ai`,
      headers: {
        authorization: `Bearer ${adminToken}`
      },
      body: JSON.stringify({
        reason: 'Test regeneration'
      })
    });

    expect(response.statusCode).toBe(200);
    const body = JSON.parse(response.body);
    expect(body.success).toBe(true);
    expect(body.data.previousGeneratedAt).toBe(originalGeneratedAt);
    expect(body.data.generatedAt).not.toBe(originalGeneratedAt);
  });

  it('should create audit log entry', async () => {
    const response = await app.inject({
      method: 'POST',
      url: `/v1/admin/assessments/${assessmentId}/regenerate-ai`,
      headers: {
        authorization: `Bearer ${adminToken}`
      },
      body: JSON.stringify({
        reason: 'Audit test'
      })
    });

    expect(response.statusCode).toBe(200);

    // Check audit log
    const auditLogs = await prisma.auditLog.findMany({
      where: {
        entityId: assessmentId,
        action: 'AI_ANALYSIS_REGENERATED'
      }
    });

    expect(auditLogs.length).toBeGreaterThan(0);
    expect(auditLogs[0].metadata.reason).toBe('Audit test');
  });

  it('should return 404 for non-existent assessment', async () => {
    const response = await app.inject({
      method: 'POST',
      url: `/v1/admin/assessments/invalid-id/regenerate-ai`,
      headers: {
        authorization: `Bearer ${adminToken}`
      }
    });

    expect(response.statusCode).toBe(404);
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_