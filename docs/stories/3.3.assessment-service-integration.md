# Story 3.3: Assessment Service AI Generation Integration

## Status
Draft

## Story

**As a** backend developer,
**I want** to add AI generation to the assessment service,
**So that** AI content is generated once and stored permanently

## Acceptance Criteria

1. `generateAndStoreAIAnalysis()` method added to AssessmentService
2. Method checks for existing AI content before generation (idempotent)
3. Only generates if content doesn't exist (one-time generation)
4. Stores permanently in database (aiRiskAnalysis, aiStrategyMatrix fields)
5. Returns existing content if already generated (no regeneration)
6. Logs all generation attempts with timing metrics
7. Handles partial failures gracefully (store what succeeded)
8. Integration tests verify one-time generation behavior

## Tasks / Subtasks

- [ ] Task 1: Add generateAndStoreAIAnalysis method to AssessmentService (AC: 1)
  - [ ] Open `backend/src/services/assessment.service.ts`
  - [ ] Import RiskAnalysisAIService from story 3.2
  - [ ] Add method signature with proper TypeScript types
  - [ ] Follow existing service method patterns

- [ ] Task 2: Implement idempotent generation check (AC: 2, 5)
  - [ ] Query assessment including gaps, risks, organization
  - [ ] Check if aiRiskAnalysis and aiStrategyMatrix already exist
  - [ ] Return existing data immediately if found
  - [ ] Log when returning cached data

- [ ] Task 3: Implement AI content generation (AC: 3, 4)
  - [ ] Group gaps by category using reduce
  - [ ] Calculate risk scores per category
  - [ ] Call RiskAnalysisAIService methods in parallel
  - [ ] Build strategy matrix rows from results

- [ ] Task 4: Store generated content in database (AC: 4)
  - [ ] Use Prisma update to save AI content
  - [ ] Set aiRiskAnalysis JSON field
  - [ ] Set aiStrategyMatrix JSON array
  - [ ] Set aiGeneratedAt timestamp

- [ ] Task 5: Add comprehensive logging (AC: 6)
  - [ ] Log generation start with assessmentId
  - [ ] Log each category being processed
  - [ ] Log timing for AI generation
  - [ ] Log successful storage
  - [ ] Log any errors with context

- [ ] Task 6: Implement partial failure handling (AC: 7)
  - [ ] Wrap each category generation in try-catch
  - [ ] Store successful categories even if others fail
  - [ ] Mark partial generation in logs
  - [ ] Return partial results with error flag

- [ ] Task 7: Create integration tests (AC: 8)
  - [ ] Test first generation creates content
  - [ ] Test second call returns existing content
  - [ ] Test partial failure scenario
  - [ ] Verify database persistence

## Dev Notes

### Assessment Service Location
[Source: backend/src/services/assessment.service.ts]

The AssessmentService is a large file (~60KB) that handles the assessment lifecycle. Add the new method alongside existing assessment operations.

### Method Implementation

```typescript
class AssessmentService extends BaseService {
  // ... existing methods ...

  async generateAndStoreAIAnalysis(
    assessmentId: string,
    context?: ServiceContext
  ): Promise<ServiceResponse<any>> {
    try {
      // 1. Check for existing content
      const assessment = await this.db.assessment.findUnique({
        where: { id: assessmentId },
        include: {
          gaps: true,
          risks: true,
          organization: true
        }
      });

      if (!assessment) {
        return this.error('Assessment not found');
      }

      // 2. Return existing if already generated
      if (assessment.aiRiskAnalysis && assessment.aiStrategyMatrix) {
        this.logger.info('AI analysis already exists', { assessmentId });
        return this.success({
          riskAnalysis: assessment.aiRiskAnalysis,
          strategyMatrix: assessment.aiStrategyMatrix,
          generatedAt: assessment.aiGeneratedAt
        });
      }

      // 3. Generate new AI analysis
      const riskAnalysisAI = new RiskAnalysisAIService();

      // ... generation logic ...

      // 4. Store in database
      const updatedAssessment = await this.db.assessment.update({
        where: { id: assessmentId },
        data: {
          aiRiskAnalysis: riskAnalysis,
          aiStrategyMatrix: strategyMatrixRows,
          aiGeneratedAt: new Date()
        }
      });

      return this.success({
        riskAnalysis,
        strategyMatrix: strategyMatrixRows,
        generatedAt: updatedAssessment.aiGeneratedAt
      });
    } catch (error) {
      this.logger.error('Failed to generate AI analysis', { error, assessmentId });
      return this.error('Failed to generate AI analysis');
    }
  }
}
```

### Gap Grouping Pattern

```typescript
// Group gaps by category
const gapsByCategory = assessment.gaps.reduce((acc: Record<string, Gap[]>, gap) => {
  if (!acc[gap.category]) {
    acc[gap.category] = [];
  }
  acc[gap.category].push(gap);
  return acc;
}, {});
```

### Parallel Generation Pattern

```typescript
// Generate for all categories in parallel
const analysisPromises = Object.entries(gapsByCategory).map(
  async ([category, categoryGaps]) => {
    const categoryRisks = assessment.risks.filter(r => r.category === category);

    // Parallel generation of findings and strategies
    const [keyFindings, mitigationStrategies] = await Promise.all([
      riskAnalysisAI.generateKeyFindings(category, categoryGaps, context),
      riskAnalysisAI.generateMitigationStrategies(
        category,
        categoryGaps,
        categoryRisks,
        assessment.organization,
        context
      )
    ]);

    return { category, keyFindings, mitigationStrategies };
  }
);

const results = await Promise.all(analysisPromises);
```

### Risk Score Calculation

```typescript
const calculateCategoryRiskScore = (categoryGaps: Gap[]) => {
  const severityWeights = {
    CRITICAL: 10,
    HIGH: 7.5,
    MEDIUM: 5,
    LOW: 2.5
  };

  const totalWeight = categoryGaps.reduce((sum, gap) =>
    sum + severityWeights[gap.severity as keyof typeof severityWeights], 0
  );

  const maxWeight = categoryGaps.length * 10;
  return Math.min(10, (totalWeight / maxWeight) * 10);
};
```

### Strategy Matrix Row Structure

```typescript
interface StrategyMatrixRow {
  priority: number;
  riskArea: string;
  adjustedRisk: 'HIGH' | 'MEDIUM' | 'LOW';
  urgency: string;
  impact: string;
  primaryMitigation: string;
  timeline: string;
  budget: string;
  businessOwner: string;
  gapCount: number;
  criticalGaps: number;
}
```

### Business Owner Mapping

```typescript
private getBusinessOwner(category: string): string {
  const owners: Record<string, string> = {
    'DATA_PROTECTION': 'Chief Data Officer',
    'TRANSACTION_MONITORING': 'Head of Compliance',
    'CUSTOMER_DUE_DILIGENCE': 'KYC Manager',
    'RISK_ASSESSMENT': 'Chief Risk Officer',
    'REGULATORY_REPORTING': 'Compliance Director',
    'TRAINING': 'Head of L&D',
    'GOVERNANCE': 'Chief Compliance Officer',
    'TECHNOLOGY': 'Chief Technology Officer',
    'AUDIT': 'Chief Audit Executive',
    'THIRD_PARTY': 'Vendor Management'
  };
  return owners[category] || 'Compliance Team';
}
```

### Error Handling Pattern

```typescript
// Partial failure handling
const riskAnalysis: Record<string, any> = {};
const failedCategories: string[] = [];

for (const [category, categoryGaps] of Object.entries(gapsByCategory)) {
  try {
    // Generate for this category
    const result = await generateCategoryAnalysis(category, categoryGaps);
    riskAnalysis[category] = result;
  } catch (error) {
    this.logger.error('Failed to generate for category', { category, error });
    failedCategories.push(category);
    // Continue with other categories
  }
}

// Store partial results if any succeeded
if (Object.keys(riskAnalysis).length > 0) {
  await this.db.assessment.update({
    where: { id: assessmentId },
    data: {
      aiRiskAnalysis: riskAnalysis,
      // ... other fields
    }
  });
}
```

### Service Response Pattern
[Source: backend/src/services/base.service.ts]

Use the existing success/error response pattern:
```typescript
return this.success({
  riskAnalysis,
  strategyMatrix: strategyMatrixRows,
  generatedAt: new Date()
});

// Or for errors:
return this.error('Failed to generate AI analysis');
```

## Testing

### Testing Standards

**Test File Location:**
`backend/src/services/assessment.service.integration.spec.ts`

**Integration Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { PrismaClient } from '@prisma/client';
import { AssessmentService } from './assessment.service';

describe('AssessmentService AI Generation Integration', () => {
  let prisma: PrismaClient;
  let service: AssessmentService;
  let testAssessmentId: string;

  beforeAll(async () => {
    prisma = new PrismaClient();
    service = new AssessmentService();

    // Create test assessment with gaps and risks
    const assessment = await prisma.assessment.create({
      data: {
        // ... test data
      }
    });
    testAssessmentId = assessment.id;
  });

  afterAll(async () => {
    await prisma.assessment.delete({ where: { id: testAssessmentId } });
    await prisma.$disconnect();
  });

  it('should generate AI content on first call', async () => {
    const result = await service.generateAndStoreAIAnalysis(testAssessmentId);

    expect(result.success).toBe(true);
    expect(result.data.riskAnalysis).toBeDefined();
    expect(result.data.strategyMatrix).toBeInstanceOf(Array);
    expect(result.data.generatedAt).toBeInstanceOf(Date);

    // Verify stored in database
    const assessment = await prisma.assessment.findUnique({
      where: { id: testAssessmentId }
    });
    expect(assessment.aiRiskAnalysis).toBeDefined();
  });

  it('should return existing content on second call', async () => {
    const firstCall = await service.generateAndStoreAIAnalysis(testAssessmentId);
    const secondCall = await service.generateAndStoreAIAnalysis(testAssessmentId);

    // Should return same content without regeneration
    expect(secondCall.data.generatedAt).toEqual(firstCall.data.generatedAt);
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_