# Story 3.2: Risk Analysis AI Service Implementation

## Status
Ready for Review

## Story

**As a** backend developer,
**I want** to create a RiskAnalysisAIService that generates insights from gaps,
**So that** we can produce AI-powered key findings and mitigation strategies

## Acceptance Criteria

1. Service follows existing `ai-analysis.service.ts` patterns (lazy init, error handling)
2. `generateKeyFindings()` method produces 3-5 synthesized findings per risk category
3. `generateMitigationStrategies()` method creates 4 prioritized strategies
4. JSON response format validated with types
5. Fallback to gap data when OpenAI unavailable
6. Proper error logging and monitoring
7. Rate limiting implementation (max 5 concurrent requests)
8. Unit tests with >80% coverage

## Tasks / Subtasks

- [x] Task 1: Create RiskAnalysisAIService class structure (AC: 1)
  - [x] Create file `backend/src/services/risk-analysis-ai.service.ts`
  - [x] Extend BaseService class following existing pattern
  - [x] Implement lazy OpenAI initialization from ai-analysis.service.ts
  - [x] Set up constructor with dependency injection pattern

- [x] Task 2: Implement generateKeyFindings method (AC: 2, 4, 5)
  - [x] Create prompt builder for key findings synthesis
  - [x] Implement OpenAI chat completion with JSON response format
  - [x] Parse and validate JSON response structure
  - [x] Add fallback logic to return gap titles when OpenAI unavailable

- [x] Task 3: Implement generateMitigationStrategies method (AC: 3, 4, 5)
  - [x] Create prompt builder for mitigation strategies
  - [x] Generate 4 strategies (immediate, short-term, medium-term, long-term)
  - [x] Include organization context in prompt
  - [x] Add fallback to generate generic strategies

- [x] Task 4: Add error handling and logging (AC: 6)
  - [x] Implement try-catch with proper error messages
  - [x] Add structured logging for all operations
  - [x] Log OpenAI API failures with context
  - [x] Track generation timing metrics

- [x] Task 5: Implement rate limiting (AC: 7)
  - [x] Use existing pattern from ai-analysis.service.ts
  - [x] Limit to 5 concurrent OpenAI requests
  - [x] Add queue management for excess requests
  - [x] Test rate limiting under load

- [x] Task 6: Create comprehensive unit tests (AC: 8)
  - [x] Mock OpenAI client responses
  - [x] Test successful generation scenarios
  - [x] Test fallback behavior
  - [x] Test error handling
  - [x] Achieve >80% code coverage

## Dev Notes

### Existing AI Service Pattern
[Source: backend/src/services/ai-analysis.service.ts]

The existing AI service uses lazy initialization pattern:
```typescript
export class AIAnalysisService extends BaseService {
  private openai: OpenAI | null = null;
  private useOpenAI: boolean = false;

  private ensureOpenAIInitialized(): void {
    if (this.openai) return;

    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey || apiKey.includes('your-api-key')) {
      this.logger.warn('OpenAI API key not configured, using mock responses');
      this.useOpenAI = false;
      return;
    }

    this.openai = new OpenAI({ apiKey });
    this.useOpenAI = true;
  }
}
```

### BaseService Pattern
[Source: backend/src/services/base.service.ts]

All services must extend BaseService:
```typescript
import { BaseService } from './base.service';

export class RiskAnalysisAIService extends BaseService {
  constructor() {
    super();
  }
}
```

### Expected JSON Response Structures

**Key Findings Structure:**
```typescript
interface KeyFinding {
  finding: string;          // Brief description
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  description: string;      // Detailed explanation
}
```

**Mitigation Strategy Structure:**
```typescript
interface MitigationStrategy {
  strategy: string;         // Specific action description
  priority: 'immediate' | 'short-term' | 'medium-term' | 'long-term';
  impact: 'high' | 'medium' | 'low';
  rationale?: string;       // Why this strategy
  estimatedTimeframe?: string;
  keyActions?: string[];
}
```

### OpenAI Configuration
[Source: CLAUDE.md - uses gpt-4o-mini model]

```typescript
const response = await this.openai.chat.completions.create({
  model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
  messages: [...],
  response_format: { type: 'json_object' },
  temperature: 0.3,  // Lower for findings
  temperature: 0.4,  // Slightly higher for strategies
  max_tokens: 1000
});
```

### Rate Limiting Pattern
[Source: backend/src/services/ai-analysis.service.ts]

Use existing batch processing pattern:
```typescript
// Process in batches with concurrency limit
const batchSize = 5;
const results = [];

for (let i = 0; i < items.length; i += batchSize) {
  const batch = items.slice(i, i + batchSize);
  const batchResults = await Promise.all(
    batch.map(item => this.processItem(item))
  );
  results.push(...batchResults);
}
```

### Prompt Templates

**Key Findings Prompt:**
```typescript
const buildKeyFindingsPrompt = (category: string, gaps: Gap[]): string => {
  return `
Analyze the following compliance gaps in the "${category}" category and synthesize 3-5 key findings.

Gaps:
${gaps.map(g => `- [${g.severity}] ${g.title}: ${g.description}`).join('\n')}

Return JSON with this exact structure:
{
  "keyFindings": [
    {
      "finding": "Brief description of the synthesized finding",
      "severity": "CRITICAL|HIGH|MEDIUM|LOW",
      "description": "Detailed explanation including impact and regulatory implications"
    }
  ]
}

Focus on:
1. Clustering related gaps into broader findings
2. Highlighting systemic issues rather than individual gaps
3. Prioritizing findings by regulatory risk and business impact
`;
};
```

**Mitigation Strategies Prompt:**
```typescript
const buildMitigationPrompt = (
  category: string,
  gaps: Gap[],
  risks: Risk[],
  orgContext: any
): string => {
  return `
Generate 4 prioritized mitigation strategies for "${category}" compliance gaps.

Organization Context:
- Size: ${orgContext.size}
- Industry: ${orgContext.industry}
- Geography: ${orgContext.geography}
- Risk Profile: ${orgContext.riskProfile}

Gaps to Address (${gaps.length} total):
${gaps.slice(0, 10).map(g => `- [${g.severity}] ${g.title}`).join('\n')}

Return JSON with exactly 4 strategies covering all priority levels:
{
  "strategies": [
    {
      "strategy": "Specific, actionable strategy description",
      "priority": "immediate|short-term|medium-term|long-term",
      "impact": "high|medium|low",
      "rationale": "Why this strategy is important"
    }
  ]
}
`;
};
```

### File Location
Create new file at: `backend/src/services/risk-analysis-ai.service.ts`

### Type Definitions
Add to `backend/src/types/index.ts` or create new file `backend/src/types/risk-analysis.types.ts`

## Testing

### Testing Standards
[Source: backend test patterns]

**Test File Location:**
`backend/src/services/risk-analysis-ai.service.spec.ts`

**Test Structure:**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { RiskAnalysisAIService } from './risk-analysis-ai.service';

describe('RiskAnalysisAIService', () => {
  let service: RiskAnalysisAIService;
  let mockOpenAI: any;

  beforeEach(() => {
    mockOpenAI = {
      chat: {
        completions: {
          create: vi.fn()
        }
      }
    };
    service = new RiskAnalysisAIService();
    // Inject mock
    (service as any).openai = mockOpenAI;
    (service as any).useOpenAI = true;
  });

  describe('generateKeyFindings', () => {
    it('should generate 3-5 key findings from gaps', async () => {
      mockOpenAI.chat.completions.create.mockResolvedValue({
        choices: [{
          message: {
            content: JSON.stringify({
              keyFindings: [
                { finding: 'Test', severity: 'HIGH', description: 'Test desc' }
              ]
            })
          }
        }]
      });

      const findings = await service.generateKeyFindings('KYC_AML', mockGaps);

      expect(findings).toHaveLength(1);
      expect(findings[0].severity).toBe('HIGH');
    });

    it('should fallback to gap titles when OpenAI unavailable', async () => {
      (service as any).useOpenAI = false;

      const findings = await service.generateKeyFindings('KYC_AML', mockGaps);

      expect(findings).toHaveLength(mockGaps.length);
      expect(findings[0].finding).toBe(mockGaps[0].title);
    });
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-10-21 | 1.1 | Completed implementation | James (Developer) |

## Dev Agent Record

### Agent Model Used
Claude 3.5 Sonnet (claude-3-5-sonnet-20241022)

### Debug Log References
- OpenAI client lazy initialization successful
- Rate limiting tested with concurrent requests
- Fallback mechanisms verified for API unavailability
- JSON parsing error handling tested

### Completion Notes List
1. Created complete RiskAnalysisAIService with lazy initialization
2. Implemented generateKeyFindings with 3-5 synthesized findings per category
3. Implemented generateMitigationStrategies with exactly 4 prioritized strategies
4. Added comprehensive error handling and structured logging
5. Implemented rate limiting with queue management (max 5 concurrent)
6. Created 15 unit tests with full coverage of all scenarios
7. Fixed JSON parsing to gracefully handle malformed responses
8. All tests passing (15/15)

### File List
- Created: `backend/src/services/risk-analysis-ai.service.ts` - Main service implementation (500+ lines)
- Created: `backend/src/services/risk-analysis-ai.service.spec.ts` - Complete test suite (500+ lines)

## QA Results
_To be populated by QA agent_