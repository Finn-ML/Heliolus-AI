# Story 13.2: Frontend Revenue API Integration & Data Fetching

## Status
Draft

## Epic
Epic 13: Admin Revenue Reports - Backend Integration

## Story

**As a** frontend developer
**I want** typed API methods for revenue analytics with proper caching and error handling
**So that** I can fetch real data and replace hardcoded mock values in the RevenueReports page

## Description

This story creates the frontend infrastructure for consuming the revenue analytics API built in Story 13.1. It extends the existing `adminAnalyticsApi` with revenue methods, integrates TanStack Query for caching/state management, and updates the RevenueReports component to fetch real data instead of using mock arrays.

**Key Challenge**: The RevenueReports page currently has ~24 lines of hardcoded mock data that must be replaced with API calls. We need to maintain the same data structure the charts expect while handling loading states, errors, and empty data gracefully.

## Acceptance Criteria

### API Client Implementation
1. ✅ Method added to `adminAnalyticsApi` in `frontend/src/lib/api.ts` (after line 914)
2. ✅ Method signature: `getRevenueAnalytics(params?: RevenueAnalyticsParams)`
3. ✅ TypeScript interface defined for `RevenueAnalyticsParams`:
   - view?: 'overview' | 'trends' | 'customers' | 'breakdown'
   - startDate?: string (ISO 8601)
   - endDate?: string (ISO 8601)
   - groupBy?: 'day' | 'week' | 'month'
   - limit?: number
4. ✅ Query string properly builds from params (handles undefined values)
5. ✅ Returns unwrapped data (matches existing pattern: `response.data`)
6. ✅ Proper error handling (throws errors for 4xx/5xx responses)

### TanStack Query Integration
7. ✅ Query keys include all relevant parameters:
   - `['admin-analytics-revenue', view, startDate, endDate]`
   - Ensures proper cache invalidation when params change
8. ✅ Cache configuration matches existing analytics pattern:
   - `refetchInterval: 300000` (5 minutes)
   - `staleTime: 60000` (1 minute)
   - `retry: 3`
9. ✅ Multiple queries for different views (overview, trends, customers, breakdown)
10. ✅ Combined loading state: `isLoading = isLoadingOverview || isLoadingTrends || ...`

### RevenueReports.tsx Updates
11. ✅ All mock data arrays removed:
   - `revenueData` array (line 53-60) → replaced with API call
   - `revenueByProduct` array (line 62-68) → replaced with API call
   - `topCustomers` array (line 70-76) → replaced with API call
12. ✅ API calls triggered on component mount
13. ✅ API calls re-triggered when `timeRange` state changes
14. ✅ Loading states displayed (skeleton loaders during fetch)
15. ✅ Error states handled:
   - Network errors show user-friendly message
   - 403 Forbidden shows "Admin access required"
   - 500 Server Error shows "Unable to load revenue data"

### Empty State Handling
16. ✅ Empty data message shown when API returns no data
17. ✅ Message text: "No revenue data available for selected time range"
18. ✅ Charts display empty state (not crashes or errors)
19. ✅ Time range selector remains functional (not disabled)

### Data Flow
20. ✅ Time range selector triggers date calculation
21. ✅ Date calculation updates query params (startDate, endDate)
22. ✅ Query param change triggers cache invalidation
23. ✅ New API calls fetch updated data

## Tasks / Subtasks

- [ ] Task 1: Add TypeScript Interfaces (AC: 3)
  - [ ] Open `frontend/src/lib/api.ts`
  - [ ] Add interface after line 914 (after adminAnalyticsApi):
    ```typescript
    export interface RevenueAnalyticsParams {
      view?: 'overview' | 'trends' | 'customers' | 'breakdown';
      startDate?: string;
      endDate?: string;
      groupBy?: 'day' | 'week' | 'month';
      limit?: number;
    }
    ```
  - [ ] Add interface for response types (optional, can use `any` initially)

- [ ] Task 2: Implement getRevenueAnalytics Method (AC: 1, 2, 4, 5, 6)
  - [ ] Add method to `adminAnalyticsApi` object (after exportAnalytics, line 914)
  - [ ] Accept optional `params: RevenueAnalyticsParams`
  - [ ] Create URLSearchParams from params
  - [ ] Handle undefined params (don't add to query string)
  - [ ] Build endpoint: `/admin/analytics/revenue?${queryString}`
  - [ ] Call `apiRequest<ApiResponse<any>>(endpoint)`
  - [ ] Return `response.data` (unwrap ApiResponse)
  - [ ] Follow exact pattern from `getAssessmentAnalytics()` (lines 794-809)

- [ ] Task 3: Add Date Calculation Helper (AC: 20, 21)
  - [ ] Add function to RevenueReports.tsx: `calculateStartDate(timeRange: string)`
  - [ ] Map timeRange to date:
    - 'week' → 7 days ago
    - 'month' → 30 days ago
    - 'quarter' → 90 days ago
    - 'year' → 365 days ago
    - 'all' → null (no startDate param)
  - [ ] Return ISO date string: `new Date().toISOString()`

- [ ] Task 4: Add TanStack Query Hooks - Overview (AC: 7, 8, 9)
  - [ ] Open `frontend/src/pages/admin/RevenueReports.tsx`
  - [ ] Import useQuery from @tanstack/react-query
  - [ ] Add query for overview data:
    ```typescript
    const { data: overviewData, isLoading: isLoadingOverview, error: overviewError } = useQuery({
      queryKey: ['admin-analytics-revenue', 'overview', timeRange],
      queryFn: () => adminAnalyticsApi.getRevenueAnalytics({
        view: 'overview',
        startDate: calculateStartDate(timeRange),
        endDate: new Date().toISOString()
      }),
      refetchInterval: 300000,
      staleTime: 60000,
      retry: 3,
    });
    ```
  - [ ] Extract overview values: totalRevenue, avgMonthlyRevenue, lastMonthGrowth, etc.

- [ ] Task 5: Add TanStack Query Hooks - Trends (AC: 7, 8, 9)
  - [ ] Add query for trends data (line chart)
  - [ ] Use groupBy based on timeRange:
    - 'week' or 'month' → 'day'
    - 'quarter' → 'week'
    - 'year' or 'all' → 'month'
  - [ ] Store in `trendsData`
  - [ ] Store loading state in `isLoadingTrends`

- [ ] Task 6: Add TanStack Query Hooks - Customers (AC: 7, 8, 9)
  - [ ] Add query for top customers data (table)
  - [ ] Set limit: 5 (top 5 customers)
  - [ ] Store in `customersData`
  - [ ] Store loading state in `isLoadingCustomers`

- [ ] Task 7: Add TanStack Query Hooks - Breakdown (AC: 7, 8, 9)
  - [ ] Add query for revenue breakdown (pie chart)
  - [ ] Store in `breakdownData`
  - [ ] Store loading state in `isLoadingBreakdown`

- [ ] Task 8: Combine Loading States (AC: 10, 14)
  - [ ] Create combined loading state:
    ```typescript
    const isLoading = isLoadingOverview || isLoadingTrends || isLoadingCustomers || isLoadingBreakdown;
    ```
  - [ ] Update existing loading check to use new combined state
  - [ ] Keep existing loading spinner UI (lines 282-290)

- [ ] Task 9: Remove Mock Data Arrays (AC: 11)
  - [ ] Delete `revenueData` array (lines 53-60)
  - [ ] Delete `revenueByProduct` array (lines 62-68)
  - [ ] Delete `topCustomers` array (lines 70-76)
  - [ ] Delete calculated constants that use mock data:
    - `totalRevenue` calculation (line 83)
    - `avgMonthlyRevenue` calculation (line 84)
    - `lastMonthGrowth` calculation (lines 85-88)
  - [ ] Delete `totalCustomers` and `totalAssessments` constants (lines 89-90)

- [ ] Task 10: Replace Calculated Values with API Data (AC: 11, 12)
  - [ ] Replace `totalRevenue` with `overviewData?.overview?.totalRevenue || 0`
  - [ ] Replace `avgMonthlyRevenue` with `overviewData?.overview?.avgMonthlyRevenue || 0`
  - [ ] Replace `lastMonthGrowth` with `overviewData?.overview?.growth?.lastMonth || 0`
  - [ ] Replace `totalCustomers` with `overviewData?.overview?.totalCustomers || 0`
  - [ ] Replace `totalAssessments` with 0 (not applicable to revenue, can show invoiceCount)
  - [ ] Update all usages of these variables in JSX

- [ ] Task 11: Handle Error States (AC: 15)
  - [ ] Add error checking before render
  - [ ] Check for any errors: `const hasError = overviewError || trendsError || customersError || breakdownError`
  - [ ] Display error message based on error type:
    ```typescript
    if (hasError) {
      const errorMessage = overviewError?.message || 'Unable to load revenue data';
      return (
        <div className="min-h-screen bg-background flex items-center justify-center">
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{errorMessage}</AlertDescription>
          </Alert>
        </div>
      );
    }
    ```

- [ ] Task 12: Handle Empty Data States (AC: 16, 17, 18)
  - [ ] Check if all data is empty: `const isEmpty = !trendsData?.trends?.length && !customersData?.customers?.length`
  - [ ] Update existing empty state component (lines 482-493)
  - [ ] Keep existing UI, update condition to use `isEmpty` check
  - [ ] Ensure time range selector still works (don't disable)

- [ ] Task 13: Update Query Invalidation (AC: 22, 23)
  - [ ] Verify timeRange state change triggers re-render
  - [ ] Verify query keys include timeRange (done in Task 4-7)
  - [ ] TanStack Query auto-invalidates when query key changes
  - [ ] No manual invalidation needed

- [ ] Task 14: Test with Real API (AC: 12, 13, 14)
  - [ ] Start backend: `cd backend && npm run dev`
  - [ ] Start frontend: `cd frontend && npm run dev`
  - [ ] Navigate to `/admin/reports`
  - [ ] Verify data loads (not mock data)
  - [ ] Verify loading spinner shows during fetch
  - [ ] Change time range selector → verify data updates
  - [ ] Check browser console for errors

- [ ] Task 15: Test Error Scenarios (AC: 15)
  - [ ] Stop backend server → verify network error message
  - [ ] Login as non-admin user → verify 403 error (may auto-logout)
  - [ ] Corrupt backend response → verify error handling
  - [ ] Verify all error states show user-friendly messages

- [ ] Task 16: Test Empty Data Scenario (AC: 16, 17, 18, 19)
  - [ ] Clear all PAID invoices from database:
    ```sql
    UPDATE "Invoice" SET status = 'DRAFT' WHERE status = 'PAID';
    ```
  - [ ] Refresh page → verify empty state message shows
  - [ ] Verify no JavaScript errors in console
  - [ ] Verify time range selector still works
  - [ ] Restore data: Re-run seed script

## Testing Validation

```bash
# Prerequisites
cd backend
npm run db:seed:revenue  # Story 13.0 complete
npm run dev              # Start backend

# Open new terminal
cd frontend
npm run dev              # Start frontend

# Manual Testing Checklist:
# 1. Navigate to http://localhost:5173/admin/reports
# 2. Login as admin user
# 3. Verify page loads (shows loading spinner briefly)
# 4. Verify all charts render with real data (not mock)
# 5. Verify revenue numbers match backend calculations
# 6. Change time range dropdown → verify charts update
# 7. Open browser DevTools → verify no console errors
# 8. Network tab → verify API calls:
#    - /v1/admin/analytics/revenue?view=overview
#    - /v1/admin/analytics/revenue?view=trends
#    - /v1/admin/analytics/revenue?view=customers
#    - /v1/admin/analytics/revenue?view=breakdown
# 9. Verify each API call returns 200 OK
# 10. Wait 5 minutes → verify data auto-refreshes (refetchInterval)

# Error Testing:
# 1. Stop backend server
# 2. Refresh page → verify error message shows
# 3. Restart backend
# 4. Refresh page → verify data loads correctly

# Empty Data Testing:
# 1. Run SQL: UPDATE "Invoice" SET status='DRAFT' WHERE status='PAID';
# 2. Refresh page → verify empty state message
# 3. Re-run seed script to restore data
```

## Dev Notes

**Primary File**: `frontend/src/lib/api.ts`
- Add method after line 914 (after `exportAnalytics` method)
- Follow exact pattern from `getAssessmentAnalytics()` (lines 794-809)
- Use existing `apiRequest()` helper (handles auth, errors)

**Secondary File**: `frontend/src/pages/admin/RevenueReports.tsx`
- Remove lines 53-76 (mock data)
- Add TanStack Query hooks (4 queries total)
- Update JSX to use API data (lines 150+)
- Keep all existing UI components (cards, charts, tables)

**Data Flow**:
```
User selects timeRange
  ↓
calculateStartDate() returns ISO date
  ↓
Query key changes: ['admin-analytics-revenue', 'overview', timeRange]
  ↓
TanStack Query invalidates cache
  ↓
queryFn calls adminAnalyticsApi.getRevenueAnalytics()
  ↓
apiRequest() sends GET /admin/analytics/revenue?view=overview&startDate=...
  ↓
Backend returns ApiResponse<RevenueAnalytics>
  ↓
Frontend unwraps response.data
  ↓
Component re-renders with new data
  ↓
Charts update automatically (React state change)
```

**Query Key Strategy**:
- Include `timeRange` in key (not startDate/endDate)
- TanStack Query treats different keys as different cache entries
- Changing timeRange invalidates cache automatically
- No manual invalidation needed

**Error Handling**:
- `apiRequest()` already throws on 4xx/5xx (inherited from existing code)
- TanStack Query catches errors → stores in `error` state
- Display error using existing Alert components

**Performance**:
- 4 parallel API calls on mount (overview, trends, customers, breakdown)
- Fetches complete in ~500ms combined (backend optimized)
- TanStack Query caches for 1 minute (staleTime)
- Auto-refreshes every 5 minutes (refetchInterval)
- No redundant calls (query keys prevent duplicates)

## Related Files
- `frontend/src/lib/api.ts` - Add getRevenueAnalytics method
- `frontend/src/pages/admin/RevenueReports.tsx` - Update to use API
- `frontend/src/components/ui/alert.tsx` - Error display (already exists)

## Dependencies
- Story 13.0 complete (seed data)
- Story 13.1 complete (backend API functional)
- Backend server running on port 3001
- Admin user logged in

## Estimated Effort
**Story Points**: 5
**Time Estimate**: 4-5 hours

## Definition of Done
- [ ] All tasks completed and checked off
- [ ] All acceptance criteria verified
- [ ] TypeScript compilation passes (no errors)
- [ ] All mock data removed (verified with code search)
- [ ] API calls fetch real data (verified in Network tab)
- [ ] Loading states work correctly
- [ ] Error states display user-friendly messages
- [ ] Empty data state shows appropriate message
- [ ] Time range selector triggers data refresh
- [ ] No console errors when loading page
- [ ] No console errors when changing time range
- [ ] Data matches backend calculations (spot check)
- [ ] Ready for Story 13.3 chart transformations
