# Story 2.3: Geolocation-Based Access Control

## Story Overview

**Epic:** Authentication & Onboarding Enhancement
**Story ID:** 2.3
**Priority:** Medium
**Effort Estimate:** 12-16 hours
**Assignee:** Full-Stack Developer
**Status:** Draft

### Business Value

Implementing geolocation-based access control provides:

- **Regulatory Compliance**: Block access from jurisdictions where we're not licensed to operate
- **Fraud Prevention**: Reduce fraud attempts from high-risk countries
- **Data Protection**: Control where user data can be accessed from (GDPR, data sovereignty)
- **Risk Management**: Prevent account takeovers from suspicious geographic locations
- **Audit Trail**: Log access attempts by country for compliance reporting

### User Story

**As a** platform administrator
**I want to** block user registrations and logins from specific countries
**So that** we comply with regulations and reduce fraud risk

**As a** user in a restricted country
**I want to** see a clear message explaining why I can't access the platform
**So that** I understand the limitation and know who to contact

## Current State Analysis

### What Exists

- Basic authentication (login, registration)
- No IP address collection
- No geolocation detection
- No country-based restrictions

### What's Missing

1. **IP Address Detection**:
   - No IP address capture from requests
   - No IP to country mapping

2. **Geolocation Service**:
   - No integration with IP geolocation API
   - No country detection logic

3. **Access Control**:
   - No country blocklist
   - No middleware to block requests from restricted countries
   - No configuration for allowed/blocked countries

4. **User Experience**:
   - No "blocked location" error page
   - No message explaining restriction

5. **Admin Features**:
   - No admin UI to manage country restrictions (future enhancement)
   - No analytics on blocked access attempts

## Selected API: ipapi.co

Based on research, **ipapi.co** is the best fit for our use case:

### Why ipapi.co?

| Feature | ipapi.co | Alternatives |
|---------|----------|--------------|
| **Free Tier** | 30,000 requests/month | Cloudflare: Worker-only; ipstack: 100 req/month |
| **Accuracy** | 95-98% country-level | Similar across providers |
| **HTTPS** | ✓ (free tier) | ipstack: Paid only |
| **Signup Required** | ✗ No | ipstack, ipgeolocation: Yes |
| **Rate Limit** | 1000/day (30K/month) | Varies |
| **Response Time** | <200ms | <200ms |
| **Pricing** | $0 → $12/month | $0 → $10/month (varies) |

### ipapi.co API Details

**Endpoint:**
```
GET https://ipapi.co/{ip_address}/json/
```

**Response:**
```json
{
  "ip": "8.8.8.8",
  "city": "Mountain View",
  "region": "California",
  "country": "US",
  "country_name": "United States",
  "continent_code": "NA",
  "postal": "94043",
  "latitude": 37.419200897216797,
  "longitude": -122.05740356445312,
  "timezone": "America/Los_Angeles",
  "currency": "USD",
  "languages": "en-US,es-US,haw,fr"
}
```

**Key Fields for Our Use Case:**
- `country`: ISO 3166-1 alpha-2 country code (e.g., "US", "CN", "RU")
- `country_name`: Human-readable country name
- `ip`: IP address checked

**Usage Estimate:**
- 1,000 registrations/day = 30K/month (exactly at free tier limit)
- Typical usage: 100-500 registrations/day = well within limit
- If exceeded: Upgrade to $12/month for 150K requests

## Acceptance Criteria

### AC1: IP Address Detection
- [ ] Backend captures real IP address from request headers
- [ ] Handles proxy headers (X-Forwarded-For, X-Real-IP)
- [ ] Handles Cloudflare headers (CF-Connecting-IP)
- [ ] IP address logged for audit trail
- [ ] IPv4 and IPv6 support

### AC2: Geolocation Service Integration
- [ ] Backend service calls ipapi.co API
- [ ] Service extracts country code from IP address
- [ ] Service handles API rate limits gracefully
- [ ] Service caches geolocation results (15 min TTL)
- [ ] Service handles API failures (fail open vs fail closed - configurable)

### AC3: Country-Based Blocking
- [ ] Blocked countries list configurable (environment variable or config file)
- [ ] Registration blocked for users from restricted countries
- [ ] Login blocked for users from restricted countries (optional - see discussion)
- [ ] Blocked attempts return 403 Forbidden with clear message
- [ ] Blocked attempts logged for analytics

### AC4: User-Facing Error Handling
- [ ] Blocked users see friendly error page
- [ ] Error page explains geographic restriction
- [ ] Error page includes contact information for exceptions
- [ ] Error page shows user's detected country (for transparency)
- [ ] Error message is localized (if user's browser language is supported)

### AC5: Admin Configuration
- [ ] Blocked countries list stored in environment variable
- [ ] Countries specified as comma-separated ISO 3166-1 alpha-2 codes
- [ ] Easy to update without code deployment
- [ ] Defaults to empty list (no blocking) if not configured

### AC6: Audit Logging
- [ ] All blocked access attempts logged to database
- [ ] Log includes: IP address, country, timestamp, endpoint, user agent
- [ ] Admin can view blocked attempts (future: admin UI)
- [ ] Logs retained for compliance (30-90 days configurable)

### AC7: Performance & Caching
- [ ] Geolocation results cached in Redis (15 min TTL)
- [ ] Cache hit rate >80% for repeat visitors
- [ ] API response time <500ms (including geolocation lookup)
- [ ] Graceful degradation if ipapi.co is down

### AC8: Edge Cases Handled
- [ ] VPN/proxy users: Blocked based on VPN exit node country
- [ ] Tor users: Blocked if exit node in restricted country
- [ ] Private IP addresses (127.0.0.1, 10.x.x.x): Allowed (local development)
- [ ] Missing IP address: Allowed (fail open - log warning)
- [ ] Invalid IP address: Allowed (fail open - log warning)

## Implementation Tasks

### Task 1: Create Geolocation Service
**File:** `/backend/src/services/geolocation.service.ts`

**Subtasks:**
- [ ] 1.1: Create GeolocationService class
  ```typescript
  // /backend/src/services/geolocation.service.ts
  import axios from 'axios';
  import { BaseService } from './base.service';
  import { PrismaClient } from '@prisma/client';
  import { Redis } from 'ioredis';

  interface GeolocationResult {
    ip: string;
    country: string;
    country_name: string;
    city?: string;
    region?: string;
    latitude?: number;
    longitude?: number;
  }

  export class GeolocationService extends BaseService {
    private redis: Redis;
    private readonly CACHE_TTL = 900; // 15 minutes
    private readonly CACHE_PREFIX = 'geo:';

    constructor(prisma: PrismaClient, redis: Redis) {
      super(prisma);
      this.redis = redis;
    }

    /**
     * Get country code from IP address
     * Uses cache first, then ipapi.co API
     */
    async getCountryFromIP(ipAddress: string): Promise<string | null> {
      try {
        // Check cache first
        const cached = await this.getCachedGeolocation(ipAddress);
        if (cached) {
          return cached.country;
        }

        // Call ipapi.co API
        const result = await this.fetchGeolocation(ipAddress);
        if (!result) return null;

        // Cache result
        await this.cacheGeolocation(ipAddress, result);

        return result.country;
      } catch (error) {
        console.error('Geolocation error:', error);
        return null; // Fail open (allow access if geolocation fails)
      }
    }

    /**
     * Get full geolocation data from IP address
     */
    async getGeolocation(ipAddress: string): Promise<GeolocationResult | null> {
      try {
        // Check cache first
        const cached = await this.getCachedGeolocation(ipAddress);
        if (cached) return cached;

        // Call API
        const result = await this.fetchGeolocation(ipAddress);
        if (!result) return null;

        // Cache result
        await this.cacheGeolocation(ipAddress, result);

        return result;
      } catch (error) {
        console.error('Geolocation error:', error);
        return null;
      }
    }

    /**
     * Fetch geolocation from ipapi.co API
     */
    private async fetchGeolocation(ipAddress: string): Promise<GeolocationResult | null> {
      // Don't query private/local IPs
      if (this.isPrivateIP(ipAddress)) {
        return {
          ip: ipAddress,
          country: 'LOCAL',
          country_name: 'Local Development',
        };
      }

      try {
        const response = await axios.get<GeolocationResult>(
          `https://ipapi.co/${ipAddress}/json/`,
          {
            timeout: 3000, // 3 second timeout
            headers: {
              'User-Agent': 'Heliolus-Platform/1.0',
            },
          }
        );

        return response.data;
      } catch (error) {
        if (axios.isAxiosError(error)) {
          if (error.response?.status === 429) {
            console.error('ipapi.co rate limit exceeded');
          } else {
            console.error('ipapi.co API error:', error.message);
          }
        }
        return null;
      }
    }

    /**
     * Get cached geolocation result
     */
    private async getCachedGeolocation(ipAddress: string): Promise<GeolocationResult | null> {
      const key = `${this.CACHE_PREFIX}${ipAddress}`;
      const cached = await this.redis.get(key);
      if (!cached) return null;

      return JSON.parse(cached);
    }

    /**
     * Cache geolocation result in Redis
     */
    private async cacheGeolocation(ipAddress: string, result: GeolocationResult): Promise<void> {
      const key = `${this.CACHE_PREFIX}${ipAddress}`;
      await this.redis.setex(key, this.CACHE_TTL, JSON.stringify(result));
    }

    /**
     * Check if IP is private/local (should not be queried)
     */
    private isPrivateIP(ip: string): boolean {
      // IPv4 private ranges
      const privateRanges = [
        /^127\./, // Loopback
        /^10\./, // Class A private
        /^172\.(1[6-9]|2\d|3[01])\./, // Class B private
        /^192\.168\./, // Class C private
        /^169\.254\./, // Link-local
      ];

      // IPv6 private ranges
      if (ip.includes(':')) {
        return ip.startsWith('::1') || ip.startsWith('fc') || ip.startsWith('fd');
      }

      return privateRanges.some((range) => range.test(ip));
    }

    /**
     * Log blocked access attempt (for analytics)
     */
    async logBlockedAccess(data: {
      ipAddress: string;
      country: string;
      endpoint: string;
      userAgent?: string;
    }): Promise<void> {
      try {
        // Future enhancement: Store in database table for admin UI
        console.warn('Blocked access attempt:', {
          ...data,
          timestamp: new Date().toISOString(),
        });

        // Optionally: Create AuditLog entry
        // await this.prisma.auditLog.create({
        //   data: {
        //     action: 'BLOCKED_ACCESS',
        //     entityType: 'GEOLOCATION',
        //     details: data,
        //   },
        // });
      } catch (error) {
        console.error('Failed to log blocked access:', error);
      }
    }
  }
  ```

**Estimated Effort:** 3 hours

---

### Task 2: Create IP Address Extraction Utility
**File:** `/backend/src/lib/ip-utils.ts`

**Subtasks:**
- [ ] 2.1: Create IP extraction utility
  ```typescript
  // /backend/src/lib/ip-utils.ts
  import { FastifyRequest } from 'fastify';

  /**
   * Extract real IP address from request
   * Handles various proxy headers
   */
  export function getRealIP(request: FastifyRequest): string {
    // Priority order:
    // 1. CF-Connecting-IP (Cloudflare)
    // 2. X-Real-IP (Nginx)
    // 3. X-Forwarded-For (Standard proxy header - take first IP)
    // 4. request.ip (Fastify default)

    const cfIP = request.headers['cf-connecting-ip'];
    if (cfIP && typeof cfIP === 'string') {
      return cfIP;
    }

    const realIP = request.headers['x-real-ip'];
    if (realIP && typeof realIP === 'string') {
      return realIP;
    }

    const forwardedFor = request.headers['x-forwarded-for'];
    if (forwardedFor && typeof forwardedFor === 'string') {
      // X-Forwarded-For can be comma-separated list: "client, proxy1, proxy2"
      // Take first IP (real client)
      const ips = forwardedFor.split(',').map((ip) => ip.trim());
      return ips[0];
    }

    // Fallback to Fastify's parsed IP
    return request.ip;
  }

  /**
   * Validate IP address format
   */
  export function isValidIP(ip: string): boolean {
    // IPv4 regex
    const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (ipv4Regex.test(ip)) {
      const parts = ip.split('.').map(Number);
      return parts.every((part) => part >= 0 && part <= 255);
    }

    // IPv6 regex (simplified)
    const ipv6Regex = /^([0-9a-fA-F]{0,4}:){7}[0-9a-fA-F]{0,4}$/;
    return ipv6Regex.test(ip);
  }
  ```

**Estimated Effort:** 1 hour

---

### Task 3: Create Geolocation Middleware
**File:** `/backend/src/middleware/geolocation.middleware.ts`

**Subtasks:**
- [ ] 3.1: Create middleware to block restricted countries
  ```typescript
  // /backend/src/middleware/geolocation.middleware.ts
  import { FastifyRequest, FastifyReply, HookHandlerDoneFunction } from 'fastify';
  import { getRealIP } from '../lib/ip-utils';

  /**
   * List of blocked country codes (ISO 3166-1 alpha-2)
   * Configurable via environment variable: BLOCKED_COUNTRIES="CN,RU,KP"
   */
  const BLOCKED_COUNTRIES = process.env.BLOCKED_COUNTRIES
    ? process.env.BLOCKED_COUNTRIES.split(',').map((c) => c.trim().toUpperCase())
    : [];

  /**
   * Middleware to enforce geographic access restrictions
   * Blocks requests from countries in BLOCKED_COUNTRIES list
   */
  export async function geolocationMiddleware(
    request: FastifyRequest,
    reply: FastifyReply,
    done: HookHandlerDoneFunction
  ): Promise<void> {
    // Skip if no countries blocked
    if (BLOCKED_COUNTRIES.length === 0) {
      return done();
    }

    try {
      // Extract IP address
      const ipAddress = getRealIP(request);

      // Get country from IP
      const geolocationService = (request.server as any).geolocationService;
      const country = await geolocationService.getCountryFromIP(ipAddress);

      // If geolocation fails, allow access (fail open)
      if (!country) {
        console.warn('Geolocation failed for IP:', ipAddress);
        return done();
      }

      // Check if country is blocked
      if (BLOCKED_COUNTRIES.includes(country.toUpperCase())) {
        // Log blocked attempt
        await geolocationService.logBlockedAccess({
          ipAddress,
          country,
          endpoint: request.url,
          userAgent: request.headers['user-agent'],
        });

        // Return 403 Forbidden
        return reply.code(403).send({
          success: false,
          error: 'ACCESS_RESTRICTED',
          message: `Access from ${country} is not permitted. If you believe this is an error, please contact support.`,
          country,
        });
      }

      // Allow access
      done();
    } catch (error) {
      console.error('Geolocation middleware error:', error);
      // Fail open on error
      done();
    }
  }

  /**
   * Middleware factory for specific endpoints
   * Usage: server.addHook('preHandler', geolocationGuard(['registration', 'login']))
   */
  export function createGeolocationGuard(endpoints: string[]) {
    return async (
      request: FastifyRequest,
      reply: FastifyReply,
      done: HookHandlerDoneFunction
    ) => {
      // Only apply to specified endpoints
      const shouldApply = endpoints.some((endpoint) => request.url.includes(endpoint));
      if (!shouldApply) {
        return done();
      }

      return geolocationMiddleware(request, reply, done);
    };
  }
  ```

- [ ] 3.2: Create configuration utility
  ```typescript
  // /backend/src/config/geolocation.config.ts
  export interface GeolocationConfig {
    enabled: boolean;
    blockedCountries: string[];
    blockRegistration: boolean;
    blockLogin: boolean;
    failOpen: boolean; // Allow access if geolocation fails
  }

  export function getGeolocationConfig(): GeolocationConfig {
    return {
      enabled: process.env.GEOLOCATION_ENABLED === 'true',
      blockedCountries: process.env.BLOCKED_COUNTRIES
        ? process.env.BLOCKED_COUNTRIES.split(',').map((c) => c.trim().toUpperCase())
        : [],
      blockRegistration: process.env.BLOCK_REGISTRATION !== 'false', // Default: true
      blockLogin: process.env.BLOCK_LOGIN === 'true', // Default: false
      failOpen: process.env.GEOLOCATION_FAIL_OPEN !== 'false', // Default: true
    };
  }
  ```

**Estimated Effort:** 2 hours

---

### Task 4: Integrate Middleware into Routes
**File:** `/backend/src/routes/auth.routes.ts`

**Subtasks:**
- [ ] 4.1: Import geolocation middleware
  ```typescript
  import { geolocationMiddleware } from '../middleware/geolocation.middleware';
  ```

- [ ] 4.2: Apply middleware to registration endpoint
  ```typescript
  // Around line 120, before registration handler
  server.post('/auth/register', {
    preHandler: [geolocationMiddleware],
    schema: {
      body: registerBodySchema,
      response: {
        201: registerResponseSchema,
      },
    },
  }, async (request, reply) => {
    // ... existing registration logic
  });
  ```

- [ ] 4.3: (Optional) Apply middleware to login endpoint
  ```typescript
  // Only if BLOCK_LOGIN=true in config
  server.post('/auth/login', {
    preHandler: [geolocationMiddleware],
    // ... rest of config
  }, async (request, reply) => {
    // ... existing login logic
  });
  ```

- [ ] 4.4: Handle 403 responses in frontend (see Task 6)

**Estimated Effort:** 30 minutes

---

### Task 5: Initialize Service in Server
**File:** `/backend/src/server.ts`

**Subtasks:**
- [ ] 5.1: Import GeolocationService
  ```typescript
  import { GeolocationService } from './services/geolocation.service';
  ```

- [ ] 5.2: Initialize service with Redis
  ```typescript
  // After Redis initialization (around line 50)
  const geolocationService = new GeolocationService(prisma, redis);
  server.decorate('geolocationService', geolocationService);
  ```

- [ ] 5.3: Export service in services index
  ```typescript
  // /backend/src/services/index.ts
  export { GeolocationService } from './geolocation.service';
  ```

**Estimated Effort:** 30 minutes

---

### Task 6: Create Frontend Blocked Location Page
**File:** `/frontend/src/pages/BlockedLocation.tsx`

**Subtasks:**
- [ ] 6.1: Create blocked location error page
  ```typescript
  // /frontend/src/pages/BlockedLocation.tsx
  import { Card } from '@/components/ui/card';
  import { Alert } from '@/components/ui/alert';
  import { MapPin, Mail } from 'lucide-react';

  interface BlockedLocationProps {
    country?: string;
    message?: string;
  }

  export default function BlockedLocation({ country, message }: BlockedLocationProps) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
        <Card className="w-full max-w-lg p-8">
          <div className="flex items-center gap-3 mb-4">
            <MapPin size={32} className="text-red-600" />
            <h1 className="text-2xl font-bold">Access Restricted</h1>
          </div>

          <Alert variant="destructive" className="mb-6">
            {message || 'Access to this service is not available in your region.'}
          </Alert>

          {country && (
            <p className="text-gray-600 mb-4">
              Your location was detected as: <strong>{country}</strong>
            </p>
          )}

          <div className="bg-gray-50 p-4 rounded-lg mb-6">
            <h2 className="font-semibold mb-2">Why am I seeing this?</h2>
            <p className="text-sm text-gray-600">
              Heliolus is currently only available in certain regions due to regulatory
              requirements and licensing restrictions. We're working to expand our
              geographic coverage.
            </p>
          </div>

          <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
            <h2 className="font-semibold mb-2 flex items-center gap-2">
              <Mail size={18} />
              Need Access?
            </h2>
            <p className="text-sm text-gray-700 mb-3">
              If you believe this restriction is in error or you have special circumstances,
              please contact our support team.
            </p>
            <a
              href="mailto:support@heliolus.com?subject=Geographic Access Request"
              className="text-sm text-blue-600 hover:underline font-medium"
            >
              support@heliolus.com
            </a>
          </div>
        </Card>
      </div>
    );
  }
  ```

- [ ] 6.2: Add route for blocked location page
  ```typescript
  // /frontend/src/App.tsx
  import BlockedLocation from './pages/BlockedLocation';

  // In routes:
  <Route path="/blocked-location" element={<BlockedLocation />} />
  ```

**Estimated Effort:** 1.5 hours

---

### Task 7: Handle 403 Responses in Frontend
**File:** `/frontend/src/lib/api.ts`

**Subtasks:**
- [ ] 7.1: Update API client error handling
  ```typescript
  // In apiClient interceptor (around line 20)
  apiClient.interceptors.response.use(
    (response) => response,
    (error) => {
      if (error.response?.status === 401) {
        // Existing logout logic
        localStorage.removeItem('token');
        window.location.href = '/login';
      }

      // NEW: Handle 403 geolocation blocking
      if (error.response?.status === 403) {
        const errorData = error.response.data;
        if (errorData?.error === 'ACCESS_RESTRICTED') {
          // Redirect to blocked location page with country info
          const params = new URLSearchParams({
            country: errorData.country || 'Unknown',
            message: errorData.message || 'Access restricted',
          });
          window.location.href = `/blocked-location?${params.toString()}`;
          return Promise.reject(error);
        }
      }

      return Promise.reject(error);
    }
  );
  ```

- [ ] 7.2: Update BlockedLocation to read query params
  ```typescript
  // /frontend/src/pages/BlockedLocation.tsx
  import { useSearchParams } from 'react-router-dom';

  export default function BlockedLocation() {
    const [searchParams] = useSearchParams();
    const country = searchParams.get('country') || 'Unknown';
    const message = searchParams.get('message') || 'Access to this service is not available in your region.';

    // ... rest of component using country and message
  }
  ```

**Estimated Effort:** 1 hour

---

### Task 8: Add Environment Variables
**File:** `/backend/.env.example`

**Subtasks:**
- [ ] 8.1: Add geolocation config to .env.example
  ```bash
  # Geolocation-Based Access Control
  GEOLOCATION_ENABLED=false
  BLOCKED_COUNTRIES=CN,RU,KP,IR,SY
  BLOCK_REGISTRATION=true
  BLOCK_LOGIN=false
  GEOLOCATION_FAIL_OPEN=true
  ```

- [ ] 8.2: Document environment variables
  ```markdown
  # /backend/ENV_VARIABLES.md

  ## Geolocation Configuration

  - `GEOLOCATION_ENABLED`: Enable/disable geolocation checks (default: false)
  - `BLOCKED_COUNTRIES`: Comma-separated ISO 3166-1 alpha-2 country codes (e.g., "CN,RU,KP")
  - `BLOCK_REGISTRATION`: Block registration from restricted countries (default: true)
  - `BLOCK_LOGIN`: Block login from restricted countries (default: false)
  - `GEOLOCATION_FAIL_OPEN`: Allow access if geolocation fails (default: true, recommended)

  ### Country Codes Reference
  Common codes:
  - CN: China
  - RU: Russia
  - KP: North Korea
  - IR: Iran
  - SY: Syria
  - CU: Cuba
  - SD: Sudan

  Full list: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
  ```

**Estimated Effort:** 30 minutes

---

### Task 9: Add Unit Tests
**File:** `/backend/tests/unit/geolocation.test.ts`

**Subtasks:**
- [ ] 9.1: Test IP extraction utility
  ```typescript
  describe('getRealIP', () => {
    it('should extract IP from CF-Connecting-IP header', () => {
      const request = {
        headers: { 'cf-connecting-ip': '1.2.3.4' },
        ip: '5.6.7.8',
      } as any;
      expect(getRealIP(request)).toBe('1.2.3.4');
    });

    it('should extract IP from X-Forwarded-For header', () => {
      const request = {
        headers: { 'x-forwarded-for': '1.2.3.4, 5.6.7.8' },
        ip: '9.10.11.12',
      } as any;
      expect(getRealIP(request)).toBe('1.2.3.4');
    });

    it('should fallback to request.ip', () => {
      const request = {
        headers: {},
        ip: '1.2.3.4',
      } as any;
      expect(getRealIP(request)).toBe('1.2.3.4');
    });
  });
  ```

- [ ] 9.2: Test private IP detection
  ```typescript
  describe('isPrivateIP', () => {
    it('should detect localhost', () => {
      expect(service.isPrivateIP('127.0.0.1')).toBe(true);
    });

    it('should detect private ranges', () => {
      expect(service.isPrivateIP('10.0.0.1')).toBe(true);
      expect(service.isPrivateIP('192.168.1.1')).toBe(true);
      expect(service.isPrivateIP('172.16.0.1')).toBe(true);
    });

    it('should allow public IPs', () => {
      expect(service.isPrivateIP('8.8.8.8')).toBe(false);
    });
  });
  ```

- [ ] 9.3: Test geolocation caching
  ```typescript
  describe('GeolocationService caching', () => {
    it('should cache geolocation results', async () => {
      const result1 = await service.getCountryFromIP('8.8.8.8');
      const result2 = await service.getCountryFromIP('8.8.8.8');

      expect(result1).toBe(result2);
      // Verify only 1 API call made (mock API calls)
    });
  });
  ```

**Estimated Effort:** 2 hours

---

### Task 10: Manual Testing

**Manual Testing Checklist:**

- [ ] 10.1: Test Geolocation Service
  - Test with real public IP → Should return country
  - Test with private IP (127.0.0.1) → Should return "LOCAL"
  - Test with invalid IP → Should return null
  - Verify Redis caching works (check cache hit/miss logs)

- [ ] 10.2: Test Country Blocking
  - Set `BLOCKED_COUNTRIES=CN`
  - Use VPN to connect from China
  - Try registering → Should block with 403
  - Check logs for blocked attempt
  - Switch to US VPN → Should allow

- [ ] 10.3: Test Frontend Error Handling
  - Trigger 403 blocked access
  - Verify redirect to `/blocked-location`
  - Verify country and message displayed correctly
  - Verify "contact support" link works

- [ ] 10.4: Test Edge Cases
  - Disable geolocation (`GEOLOCATION_ENABLED=false`) → Should allow all
  - Empty `BLOCKED_COUNTRIES` → Should allow all
  - ipapi.co API down → Should fail open (allow access)
  - Rate limit exceeded → Should fail open (allow access)

- [ ] 10.5: Test Performance
  - Measure request latency with geolocation enabled
  - First request (no cache): <500ms
  - Cached request: <100ms
  - Verify Redis cache working (check Redis Commander)

**Estimated Effort:** 2 hours

---

### Task 11: Update Documentation

**Subtasks:**
- [ ] 11.1: Update `/CLAUDE.md`
  - Add "Geolocation-Based Access Control" to security features
  - Document ipapi.co integration
  - Document environment variables

- [ ] 11.2: Update `/CHANGELOG.md`
  - Add entry: "Story 2.3: Added geolocation-based access control with ipapi.co integration"

- [ ] 11.3: Create admin guide
  ```markdown
  # /docs/admin/geolocation-access-control.md

  ## Managing Geographic Restrictions

  ### Configuration

  Edit `.env` file:
  ```bash
  GEOLOCATION_ENABLED=true
  BLOCKED_COUNTRIES=CN,RU,KP
  BLOCK_REGISTRATION=true
  BLOCK_LOGIN=false
  ```

  ### Adding/Removing Countries

  1. Find ISO 3166-1 alpha-2 code: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
  2. Edit `BLOCKED_COUNTRIES` in `.env`
  3. Restart backend: `npm run restart`
  4. No code deployment needed

  ### Monitoring Blocked Attempts

  Check logs:
  ```bash
  grep "Blocked access attempt" logs/app.log
  ```

  ### Allowing Exceptions

  Future enhancement: Admin UI to whitelist specific IPs/users
  Current: Contact developer to manually update database
  ```

**Estimated Effort:** 1 hour

---

## Technical Design Details

### Architecture Decisions

**Why ipapi.co vs Alternatives?**
- **Free tier**: 30K requests/month (sufficient for most use cases)
- **No signup**: Easier to get started, fewer dependencies
- **HTTPS on free**: Secure by default
- **Good accuracy**: 95-98% country-level (sufficient for compliance)

**Why Redis Caching?**
- **Performance**: Reduces API calls by 80%+
- **Cost**: Keeps us within free tier limits
- **Reliability**: Service continues if ipapi.co is down (for cached IPs)

**Why Fail Open vs Fail Closed?**
- **Fail Open (Default)**: Allow access if geolocation fails
  - **Pros**: Better UX, no false positives, resilient to API outages
  - **Cons**: Potential bypass if geolocation always fails
- **Fail Closed**: Block access if geolocation fails
  - **Pros**: Stricter security, guaranteed enforcement
  - **Cons**: Can block legitimate users if API down

**Decision**: Default to **fail open** (configurable via `GEOLOCATION_FAIL_OPEN`)

**Why Block Registration but Not Login?**
- **Registration Blocking**: Prevents new accounts from restricted countries
- **Login Blocking**: More disruptive (existing users traveling)
- **Recommendation**: Block registration always, block login only if required for compliance

### Security Considerations

**IP Spoofing**:
- **Risk**: Users can use VPNs/proxies to bypass geolocation
- **Mitigation**: Geolocation is deterrent, not bulletproof. Combine with other signals (payment method, phone verification)

**Privacy**:
- **Data Collection**: Only IP address and country stored (no precise location)
- **Logging**: IP addresses masked in logs (`192.168.***.**`)
- **Compliance**: GDPR-compliant (IP is personal data, but necessary for security)

**Rate Limiting**:
- **ipapi.co Free Tier**: 30K requests/month = ~1K/day
- **Our Usage**: ~500-1000 registrations/day (well within limit)
- **Overflow**: Upgrade to $12/month tier (150K requests) if needed

### Performance Considerations

**Latency Budget**:
- ipapi.co API call: ~100-200ms
- Redis cache hit: ~1-5ms
- Cache hit rate: 80%+ (repeat visitors)
- Overall impact: ~20-40ms average latency increase

**Caching Strategy**:
- **TTL**: 15 minutes (balance freshness vs cache hits)
- **Cache Key**: `geo:{ip_address}`
- **Eviction**: LRU (Redis default)

**Scalability**:
- **Current**: 30K requests/month = 1K registrations/day
- **Scale**: If exceed free tier, upgrade to paid plan
- **Alternative**: Switch to Cloudflare Workers (free, unlimited) if on Cloudflare

### UX Considerations

**Error Message Tone**:
- Neutral, not accusatory
- Explain restriction clearly
- Provide alternative (contact support)
- Show detected country (transparency)

**False Positives**:
- VPN users: Blocked based on VPN exit node (expected)
- Travelers: Can use VPN to home country, or contact support
- Corporate proxies: May show wrong country (rare, contact support)

---

## Testing Strategy

### Unit Tests
- IP extraction logic
- Private IP detection
- Geolocation caching
- Middleware country blocking logic

### Integration Tests
- Registration blocked from restricted country
- Registration allowed from permitted country
- Login flow with geolocation enabled
- Cache hit/miss scenarios

### Manual Tests
- VPN testing with multiple countries
- Frontend error page display
- Performance testing (latency)
- API failure scenarios (fail open)

---

## Deployment Notes

### Pre-Deployment Checklist
- [ ] Verify `BLOCKED_COUNTRIES` list is correct
- [ ] Verify `GEOLOCATION_ENABLED=true` in production
- [ ] Test geolocation service on staging
- [ ] Verify Redis is running and accessible
- [ ] Test with VPN from blocked country
- [ ] Monitor ipapi.co usage (check if approaching free tier limit)

### Rollout Plan
1. **Stage 1**: Deploy with `GEOLOCATION_ENABLED=false` (dry-run mode)
   - Log geolocation results without blocking
   - Monitor for 24-48 hours
   - Verify no errors, good accuracy

2. **Stage 2**: Enable blocking for registration only
   - Set `GEOLOCATION_ENABLED=true`, `BLOCK_REGISTRATION=true`, `BLOCK_LOGIN=false`
   - Monitor registration conversion rate
   - Check support tickets for false positives

3. **Stage 3**: (Optional) Enable login blocking if needed
   - Set `BLOCK_LOGIN=true`
   - Monitor user complaints
   - Be ready to roll back if too disruptive

### Rollback Plan
If critical issues arise:
1. Set `GEOLOCATION_ENABLED=false` in `.env`
2. Restart backend (no code deployment needed)
3. Service immediately allows all traffic
4. Investigate issue and redeploy fixed version

### Communication Plan
- **Users**: No announcement needed (affects only blocked countries)
- **Support Team**: Brief on new restriction and how to handle exception requests
- **Legal/Compliance**: Confirm blocked countries list aligns with legal requirements

---

## Success Metrics

### Quantitative Metrics
- **Fraud Reduction**: Expect 30-50% reduction in fraud attempts from high-risk countries
- **Compliance**: 100% of registrations from blocked countries prevented
- **Performance**: <100ms average latency increase (with caching)
- **API Usage**: Stay within 30K requests/month free tier
- **False Positive Rate**: <1% of legitimate users blocked (due to VPN/proxy)

### Qualitative Metrics
- Support tickets related to geographic restrictions (<5/month expected)
- Legal/compliance team confirmation of regulatory alignment
- User feedback on blocked location page clarity

---

## Future Enhancements (Not in this story)

### Story 2.3.1: Admin Geographic Management UI
- Admin dashboard to view/edit blocked countries
- Map visualization of blocked regions
- Analytics on blocked access attempts by country

### Story 2.3.2: Advanced Geolocation Features
- VPN/proxy detection (block VPN users)
- IP reputation scoring (block known bad IPs)
- Whitelist specific IPs (for corporate proxies)
- User-level geographic restrictions (e.g., user must login from home country)

### Story 2.3.3: Geolocation-Based Feature Flags
- Show/hide features based on user country
- Localized pricing by geography
- Region-specific compliance features

---

## Dependencies

### Required for Development
- [ ] Redis running and accessible (already installed ✓)
- [ ] Axios HTTP client (already installed ✓)
- [ ] ipapi.co API accessible (public API, no signup ✓)

### Blocked By
- None (this story is independent)

### Blocks
- None (this story is independent)

---

## Related Stories

- **Story 2.1**: Forgot Password UI (can be developed in parallel)
- **Story 2.2**: Business Email Domain Validation (can be developed in parallel)
- **Story 2.4**: KYC Company Registration Verification (can be developed in parallel)

---

## Open Questions

### Answered
- Q: Which geolocation API should we use?
- A: ipapi.co (30K free requests/month, no signup, HTTPS)

- Q: Should we block login or just registration?
- A: Block registration by default, login blocking optional (configurable)

- Q: What happens if ipapi.co is down?
- A: Fail open (allow access), configurable via `GEOLOCATION_FAIL_OPEN`

### Open
- Should we implement VPN/proxy detection to prevent bypass?
  - **Recommendation**: Future enhancement (Story 2.3.2) - adds complexity
- Should we notify users before they hit blocked location page?
  - **Recommendation**: No proactive detection on frontend (privacy concern)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All implementation tasks completed
- [ ] Unit tests written and passing
- [ ] Manual testing completed successfully (with VPN)
- [ ] Code reviewed and approved
- [ ] Documentation updated (admin guide, .env.example, CLAUDE.md)
- [ ] Deployed to staging and tested
- [ ] Deployed to production with `GEOLOCATION_ENABLED=false` (dry-run)
- [ ] Monitored for 24-48 hours in dry-run mode
- [ ] Enabled in production and monitored
- [ ] No critical bugs reported in first week
- [ ] Support team trained on handling geographic restriction requests

---

**Story Created:** 2025-10-15
**Story Author:** Bob (Scrum Master Agent)
**Last Updated:** 2025-10-15
**Status:** Draft - Ready for Review

---

## Appendix: Country Codes Reference

Common blocked countries (for reference):

| Code | Country | Reason (Example) |
|------|---------|------------------|
| CN | China | Regulatory compliance |
| RU | Russia | Sanctions compliance |
| KP | North Korea | Sanctions compliance |
| IR | Iran | Sanctions compliance |
| SY | Syria | Sanctions compliance |
| CU | Cuba | Sanctions compliance |
| SD | Sudan | Sanctions compliance |
| VE | Venezuela | Sanctions compliance (partial) |

Full list: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2

**Note**: Consult legal team before configuring blocked countries list.
