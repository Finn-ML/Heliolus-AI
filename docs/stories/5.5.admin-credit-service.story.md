# Story 5.5: Create AdminCreditService

## Status
Draft

## Story
**As a** system administrator,
**I want** to manually grant credits to Enterprise users,
**so that** I can manage custom Enterprise billing arrangements.

## Acceptance Criteria
1. Service class `AdminCreditService` created extending `BaseService`
2. Method `addCreditsToUser(userId, amount, reason, context)`:
   - Requires admin role (uses `this.requireAdmin(context)`)
   - Creates `CreditTransaction` record with type `ADMIN_GRANT`
   - Updates `Subscription.creditsBalance`
   - Records granter's userId in transaction metadata
   - Creates audit log entry
3. Method `getUserCreditHistory(userId)` returns all credit transactions for user ordered by date descending
4. Service throws appropriate errors:
   - 404 if subscription not found
   - 403 if non-admin attempts to grant credits
5. All database operations wrapped in transaction for atomicity

## Tasks / Subtasks

- [ ] **Task 1: Create AdminCreditService File** (AC: 1)
  - [ ] Create file: `backend/src/services/admin-credit.service.ts`
  - [ ] Import BaseService, ServiceContext from base.service
  - [ ] Import types from generated Prisma client
  - [ ] Create class extending BaseService

- [ ] **Task 2: Add requireAdmin Helper to BaseService** (AC: 2)
  - [ ] Open `backend/src/services/base.service.ts`
  - [ ] Add protected method:
    ```typescript
    protected requireAdmin(context: ServiceContext): void {
      if (context.userRole !== 'ADMIN') {
        throw this.createError('Admin role required', 403, 'FORBIDDEN');
      }
    }
    ```
  - [ ] This method will be reused across all admin services

- [ ] **Task 3: Implement addCreditsToUser Method** (AC: 2, 4, 5)
  - [ ] Method signature:
    ```typescript
    async addCreditsToUser(
      userId: string,
      amount: number,
      reason: string,
      context: ServiceContext
    ): Promise<CreditTransaction>
    ```
  - [ ] Check admin permission: `this.requireAdmin(context)`
  - [ ] Query subscription (throw 404 if not found)
  - [ ] Wrap in Prisma transaction:
    - Create CreditTransaction with type ADMIN_GRANT
    - Update Subscription.creditsBalance atomically
    - Log audit event
  - [ ] Return created transaction

- [ ] **Task 4: Implement getUserCreditHistory Method** (AC: 3)
  - [ ] Method signature:
    ```typescript
    async getUserCreditHistory(userId: string): Promise<CreditTransaction[]>
    ```
  - [ ] Query subscription by userId
  - [ ] Throw 404 if subscription not found
  - [ ] Query all credit transactions for subscription
  - [ ] Order by createdAt DESC
  - [ ] Return transaction array

- [ ] **Task 5: Add Input Validation** (AC: 4)
  - [ ] Validate amount > 0
  - [ ] Validate reason is non-empty string
  - [ ] Validate userId is valid CUID format
  - [ ] Throw 400 Bad Request for invalid inputs

- [ ] **Task 6: Write Unit Tests** (AC: 1-5)
  - [ ] Create test: `backend/tests/unit/admin-credit-service.test.ts`
  - [ ] Test admin can grant credits successfully
  - [ ] Test non-admin gets 403 error
  - [ ] Test 404 error if subscription not found
  - [ ] Test credit balance updates correctly
  - [ ] Test audit log entry created
  - [ ] Test transaction atomicity (rollback on error)
  - [ ] Test getUserCreditHistory returns ordered list
  - [ ] Run tests: `npm test`

- [ ] **Task 7: Write Integration Test** (AC: 5)
  - [ ] Create test: `backend/tests/integration/admin-credit-workflow.test.ts`
  - [ ] Test complete workflow:
    1. Admin grants 100 credits
    2. Verify balance increased
    3. Verify transaction recorded
    4. Verify audit log created
    5. Get credit history
    6. Verify transaction appears in history
  - [ ] Test concurrent grant operations (race condition check)

## Dev Notes

### Service Purpose
**AdminCreditService** enables administrators to manually grant credits to Enterprise users for custom billing arrangements:

**Use Cases:**
- Enterprise customer needs 500 credits for Q1 2025
- Special promotion: grant 50 bonus credits
- Credit adjustment for billing error
- Trial period credit allocation

**Business Rules:**
- ONLY admins can grant credits
- All grants must have reason/justification
- All grants create audit trail
- Credits added immediately (no delay)

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Enterprise Management]

---

### BaseService Integration

**Location:** `backend/src/services/base.service.ts`

**Existing Methods to Use:**
- `this.prisma` - Database client
- `this.logger` - Logging
- `this.createError(message, statusCode, code)` - Error creation
- `this.logAudit(event, context)` - Audit logging (line 215)

**New Method to Add:**
```typescript
/**
 * Require admin role for operation
 * Throws 403 FORBIDDEN if user is not admin
 */
protected requireAdmin(context: ServiceContext): void {
  if (!context || context.userRole !== 'ADMIN') {
    throw this.createError('Admin role required for this operation', 403, 'FORBIDDEN');
  }
}
```

[Source: backend/src/services/base.service.ts]

---

### CreditTransaction Model

**Location:** `backend/prisma/schema.prisma` line 816

**Model Structure:**
```prisma
model CreditTransaction {
  id             String @id @default(cuid())
  subscriptionId String

  type    TransactionType  // ADMIN_GRANT (from Story 5.3)
  amount  Int             // Positive for credit, negative for debit
  balance Int             // After transaction

  // Context
  description  String
  metadata     Json?       // Store granter info here
  assessmentId String?

  createdAt DateTime @default(now())

  // Relations
  subscription Subscription @relation(...)
  assessment   Assessment?  @relation(...)
}
```

**Transaction Metadata Format:**
```json
{
  "grantedBy": "admin-user-id",
  "grantReason": "Q1 2025 Enterprise allocation",
  "grantedAt": "2025-10-23T10:30:00Z"
}
```

[Source: backend/prisma/schema.prisma#CreditTransaction]

---

### Implementation Example

```typescript
import { BaseService, ServiceContext } from './base.service';
import { CreditTransaction, TransactionType } from '../generated/prisma';

export class AdminCreditService extends BaseService {
  constructor() {
    super();
  }

  /**
   * Grant credits to user (admin only)
   *
   * @param userId - Target user ID
   * @param amount - Credits to grant (must be positive)
   * @param reason - Justification for grant
   * @param context - Request context with admin user info
   * @returns Created credit transaction
   * @throws 403 if non-admin
   * @throws 404 if subscription not found
   * @throws 400 if amount <= 0
   */
  async addCreditsToUser(
    userId: string,
    amount: number,
    reason: string,
    context: ServiceContext
  ): Promise<CreditTransaction> {
    // Require admin permission
    this.requireAdmin(context);

    // Validate inputs
    if (amount <= 0) {
      throw this.createError('Credit amount must be positive', 400, 'INVALID_AMOUNT');
    }

    if (!reason || reason.trim().length === 0) {
      throw this.createError('Reason is required', 400, 'MISSING_REASON');
    }

    // Get subscription
    const subscription = await this.prisma.subscription.findUnique({
      where: { userId },
    });

    if (!subscription) {
      throw this.createError('User subscription not found', 404, 'SUBSCRIPTION_NOT_FOUND');
    }

    // Calculate new balance
    const newBalance = subscription.creditsBalance + amount;

    // Atomic transaction: create transaction + update balance + audit
    const transaction = await this.prisma.$transaction(async (tx) => {
      // Create credit transaction
      const creditTx = await tx.creditTransaction.create({
        data: {
          subscriptionId: subscription.id,
          type: TransactionType.ADMIN_GRANT,
          amount,
          balance: newBalance,
          description: reason,
          metadata: {
            grantedBy: context.userId,
            grantReason: reason,
            grantedAt: new Date().toISOString(),
          },
        },
      });

      // Update subscription balance
      await tx.subscription.update({
        where: { id: subscription.id },
        data: { creditsBalance: newBalance },
      });

      return creditTx;
    });

    // Log audit event (outside transaction - non-critical)
    await this.logAudit({
      action: 'CREDITS_GRANTED',
      entity: 'User',
      entityId: userId,
      metadata: {
        amount,
        reason,
        newBalance,
        grantedBy: context.userId,
      },
    }, context);

    this.logger.info(
      `Admin ${context.userId} granted ${amount} credits to user ${userId}. New balance: ${newBalance}`
    );

    return transaction;
  }

  /**
   * Get credit transaction history for user
   *
   * @param userId - User ID to query
   * @returns Array of credit transactions, newest first
   * @throws 404 if subscription not found
   */
  async getUserCreditHistory(userId: string): Promise<CreditTransaction[]> {
    const subscription = await this.prisma.subscription.findUnique({
      where: { userId },
    });

    if (!subscription) {
      throw this.createError('User subscription not found', 404, 'SUBSCRIPTION_NOT_FOUND');
    }

    const transactions = await this.prisma.creditTransaction.findMany({
      where: { subscriptionId: subscription.id },
      orderBy: { createdAt: 'desc' },
    });

    this.logger.info(`Retrieved ${transactions.length} credit transactions for user ${userId}`);

    return transactions;
  }
}
```

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#AdminCreditService]

---

### Atomic Transaction Pattern

**Why Prisma Transaction?**
Ensures:
1. CreditTransaction record created
2. Subscription balance updated
3. Both succeed or both rollback (atomicity)

**Pattern:**
```typescript
const result = await this.prisma.$transaction(async (tx) => {
  // Operation 1: Create transaction record
  const creditTx = await tx.creditTransaction.create({ ... });

  // Operation 2: Update subscription balance
  await tx.subscription.update({ ... });

  return creditTx;
});

// If either operation fails, both rollback
```

**Race Condition Protection:**
- Prisma handles concurrent updates with row-level locking
- Balance updates are atomic: `creditsBalance: { increment: amount }`
- Multiple admins can grant credits concurrently safely

[Source: architecture.md#Transaction Management]

---

### Audit Log Structure

**AuditLog Model:** `backend/prisma/schema.prisma`

**Audit Event Format:**
```typescript
await this.logAudit({
  action: 'CREDITS_GRANTED',
  entity: 'User',
  entityId: userId,
  metadata: {
    amount: 100,
    reason: 'Q1 2025 Enterprise allocation',
    newBalance: 250,
    grantedBy: 'admin-user-id',
  },
}, context);
```

**Stored Fields:**
- `userId`: Admin who performed action (from context)
- `action`: 'CREDITS_GRANTED'
- `entity`: 'User'
- `entityId`: Target user ID
- `metadata`: Grant details (amount, reason, new balance)
- `ipAddress`: Admin's IP (from context)
- `userAgent`: Admin's browser (from context)

[Source: backend/src/services/base.service.ts#logAudit]

---

### Error Handling

**Error Types:**

1. **403 FORBIDDEN** - Non-admin attempts grant
   ```typescript
   throw this.createError('Admin role required', 403, 'FORBIDDEN');
   ```

2. **404 NOT_FOUND** - Subscription doesn't exist
   ```typescript
   throw this.createError('User subscription not found', 404, 'SUBSCRIPTION_NOT_FOUND');
   ```

3. **400 BAD_REQUEST** - Invalid input
   ```typescript
   throw this.createError('Credit amount must be positive', 400, 'INVALID_AMOUNT');
   ```

**Error Response Format:**
```json
{
  "success": false,
  "error": "Admin role required",
  "code": "FORBIDDEN",
  "statusCode": 403
}
```

[Source: backend/src/services/base.service.ts#createError]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Locations:**
- Unit: `backend/tests/unit/admin-credit-service.test.ts`
- Integration: `backend/tests/integration/admin-credit-workflow.test.ts`

**Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { AdminCreditService } from '../src/services/admin-credit.service';
import { PrismaClient, SubscriptionPlan, UserRole } from '../src/generated/prisma';

describe('AdminCreditService', () => {
  let service: AdminCreditService;
  let prisma: PrismaClient;
  let adminUserId: string;
  let enterpriseUserId: string;

  beforeAll(async () => {
    service = new AdminCreditService();
    prisma = new PrismaClient();

    // Create admin user
    const admin = await prisma.user.create({
      data: {
        email: 'admin@example.com',
        firstName: 'Admin',
        lastName: 'User',
        password: 'hashed',
        role: UserRole.ADMIN,
      },
    });
    adminUserId = admin.id;

    // Create enterprise user with subscription
    const enterprise = await prisma.user.create({
      data: {
        email: 'enterprise@example.com',
        firstName: 'Enterprise',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.ENTERPRISE,
            creditsBalance: 0,
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(),
          },
        },
      },
    });
    enterpriseUserId = enterprise.id;
  });

  afterAll(async () => {
    await prisma.user.delete({ where: { id: adminUserId } });
    await prisma.user.delete({ where: { id: enterpriseUserId } });
    await prisma.$disconnect();
  });

  describe('addCreditsToUser', () => {
    it('should grant credits when admin', async () => {
      const transaction = await service.addCreditsToUser(
        enterpriseUserId,
        100,
        'Q1 2025 allocation',
        { userId: adminUserId, userRole: 'ADMIN' }
      );

      expect(transaction.type).toBe('ADMIN_GRANT');
      expect(transaction.amount).toBe(100);
      expect(transaction.balance).toBe(100);
      expect(transaction.description).toBe('Q1 2025 allocation');
      expect(transaction.metadata.grantedBy).toBe(adminUserId);
    });

    it('should throw 403 when non-admin', async () => {
      await expect(
        service.addCreditsToUser(
          enterpriseUserId,
          100,
          'Unauthorized attempt',
          { userId: 'regular-user', userRole: 'USER' }
        )
      ).rejects.toThrow('Admin role required');
    });

    it('should throw 404 when subscription not found', async () => {
      await expect(
        service.addCreditsToUser(
          'nonexistent-user',
          100,
          'Test',
          { userId: adminUserId, userRole: 'ADMIN' }
        )
      ).rejects.toThrow('User subscription not found');
    });

    it('should throw 400 when amount is zero or negative', async () => {
      await expect(
        service.addCreditsToUser(
          enterpriseUserId,
          0,
          'Invalid',
          { userId: adminUserId, userRole: 'ADMIN' }
        )
      ).rejects.toThrow('Credit amount must be positive');
    });

    it('should update subscription balance atomically', async () => {
      const before = await prisma.subscription.findUnique({
        where: { userId: enterpriseUserId },
      });

      await service.addCreditsToUser(
        enterpriseUserId,
        50,
        'Test increment',
        { userId: adminUserId, userRole: 'ADMIN' }
      );

      const after = await prisma.subscription.findUnique({
        where: { userId: enterpriseUserId },
      });

      expect(after.creditsBalance).toBe(before.creditsBalance + 50);
    });
  });

  describe('getUserCreditHistory', () => {
    it('should return transactions ordered by date desc', async () => {
      // Grant credits twice
      await service.addCreditsToUser(
        enterpriseUserId,
        25,
        'First grant',
        { userId: adminUserId, userRole: 'ADMIN' }
      );

      await service.addCreditsToUser(
        enterpriseUserId,
        75,
        'Second grant',
        { userId: adminUserId, userRole: 'ADMIN' }
      );

      const history = await service.getUserCreditHistory(enterpriseUserId);

      expect(history.length).toBeGreaterThanOrEqual(2);
      expect(history[0].description).toBe('Second grant'); // Most recent first
      expect(history[0].createdAt.getTime()).toBeGreaterThan(history[1].createdAt.getTime());
    });

    it('should throw 404 if subscription not found', async () => {
      await expect(
        service.getUserCreditHistory('nonexistent-user')
      ).rejects.toThrow('User subscription not found');
    });
  });
});
```

[Source: architecture.md#Testing Strategy]

---

### File Locations
- **Service:** `backend/src/services/admin-credit.service.ts`
- **BaseService:** `backend/src/services/base.service.ts` (add requireAdmin method)
- **Unit Test:** `backend/tests/unit/admin-credit-service.test.ts`
- **Integration Test:** `backend/tests/integration/admin-credit-workflow.test.ts`

---

### Dependencies
**Depends On:**
- Story 5.3: ADMIN_GRANT enum value must exist
- Existing: CreditTransaction model, Subscription model, AuditLog model

**Depended On By:**
- Story 7.2: Admin Credit Grant API endpoint will use this service

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 5 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
_TBD_

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
