# Story 1.3: Implement Graceful Degradation for Missing Vendor Metadata

**Epic:** 1 - Vendor Matching Score Fixes
**Story:** 1.3
**Status:** Draft

---

## Story

**As a** product manager,
**I want** the vendor matching algorithm to provide reasonable scores even when vendor metadata is incomplete,
**so that** the marketplace appears functional while we enrich vendor data

---

## Acceptance Criteria

1. ✅ Empty `targetSegments` field awards 10 partial points (assume serves all segments)
2. ✅ Empty `geographicCoverage` field awards 10 partial points (assume global)
3. ✅ Empty `features` field awards 5 partial points (neutral stance)
4. ✅ Null `pricingRange` continues to award 10 partial points (existing behavior)
5. ✅ Overall match scores improve from ~15 to ~45 points average
6. ✅ Scoring logic clearly documents assumptions for missing data

---

## Tasks / Subtasks

- [ ] **Task 1: Update Company Size Fit Scoring** (AC: 1, 6)
  - [ ] Modify `calculateSizeFit()` in `backend/src/matching/base-scorer.ts` (lines 65-90)
  - [ ] Change empty `targetSegments` behavior from 0 points to 10 points
  - [ ] Add code comment explaining assumption: "Vendor serves all company sizes if not specified"
  - [ ] Return `SIZE_FIT_SCORES.PARTIAL_MATCH` (10 points) instead of `SIZE_FIT_SCORES.NO_MATCH` (0 points)
  - [ ] Keep exact match logic unchanged (20 points for direct match)

- [ ] **Task 2: Update Geographic Coverage Scoring** (AC: 2, 6)
  - [ ] Modify `calculateGeoCoverage()` in `backend/src/matching/base-scorer.ts` (lines 100-123)
  - [ ] Change empty `geographicCoverage` behavior from 0 points to 10 points
  - [ ] Add code comment: "Assume global coverage if not specified"
  - [ ] Return `SCORING_WEIGHTS.GEO_COVERAGE / 2` (10 points) when coverage array is empty
  - [ ] Keep exact match and "GLOBAL" keyword logic unchanged (20 points)

- [ ] **Task 3: Update Feature Matching Scoring** (AC: 3, 6)
  - [ ] Modify `calculateFeatureBoost()` in `backend/src/matching/priority-boost.ts` (lines 67-96)
  - [ ] Change empty `features` array behavior from special case to partial credit
  - [ ] Update logic: if vendor features empty AND user requires features → award 5 partial points
  - [ ] Add code comment: "Partial credit when features unknown - vendor might have capabilities"
  - [ ] Keep full match (10 points) and missing 1-2 features (5 points) logic unchanged

- [ ] **Task 4: Verify Pricing Range Behavior** (AC: 4)
  - [ ] Review `calculatePriceScore()` in `backend/src/matching/base-scorer.ts` (lines 133-153)
  - [ ] Confirm null pricing already awards `SCORING_WEIGHTS.PRICE / 2` (10 points)
  - [ ] No changes needed - existing behavior is correct
  - [ ] Add test to ensure behavior persists

- [ ] **Task 5: Add Unit Tests for Partial Scoring** (AC: 1, 2, 3, 4)
  - [ ] Test empty `targetSegments` returns 10 points (not 0)
  - [ ] Test empty `geographicCoverage` returns 10 points (not 0)
  - [ ] Test empty `features` returns 5 points (not 0)
  - [ ] Test null `pricingRange` returns 10 points
  - [ ] Test exact matches still award full points (regression tests)
  - [ ] Test files: `base-scorer.test.ts` and `priority-boost.test.ts`

- [ ] **Task 6: Validate Score Improvements** (AC: 5)
  - [ ] Run vendor matching against test assessment `cmgtah4e9003jlvglxp0ra3ri`
  - [ ] Document before/after scores for 5+ vendors
  - [ ] Verify average score increases from ~15 to ~45 points (200% improvement)
  - [ ] Confirm vendors still differentiated (not all same score)
  - [ ] Check that vendors with actual metadata still score higher than empty vendors

- [ ] **Task 7: Update Scoring Constants Documentation** (AC: 6)
  - [ ] Review `backend/src/types/matching.types.ts` for scoring weight constants
  - [ ] Add JSDoc comments explaining partial credit philosophy
  - [ ] Document assumption-based scoring approach in code
  - [ ] Update any related documentation in codebase

---

## Dev Notes

### Problem Context

**Root Cause:** All 10 approved vendors have completely empty metadata for 5 out of 7 scoring fields:
- `targetSegments`: 0% populated → -20 points
- `geographicCoverage`: 0% populated → -20 points
- `features`: 0% populated → -10 points
- `pricingRange`: 0% populated (but already gets 10 partial credit)
- `implementationTimeline`: 0% populated → -5 points

**Current Behavior:** Algorithm awards 0 points for empty fields, assuming "no fit."

**New Behavior:** Algorithm awards partial credit for empty fields, assuming "unknown but possible fit."

**Philosophy:** When vendor metadata is incomplete, assume the vendor *might* serve the user's needs rather than assuming they *don't*. This prevents artificially low scores due to data quality issues, not actual incompatibility.

---

### Technical Context

#### Scoring Components Affected

**Source:** [Analysis: docs/VENDOR_MATCH_SCORE_ANALYSIS.md - Root Cause #3]

| Component | Current (Empty Data) | After Fix (Empty Data) | Improvement |
|-----------|---------------------|------------------------|-------------|
| Risk Area Coverage | 0 (fixed in Story 1.1) | 15-30 | +15-30 |
| Company Size Fit | 0 | 10 | +10 |
| Geographic Coverage | 0 | 10 | +10 |
| Price Appropriateness | 10 (already partial) | 10 | 0 |
| Top Priority Boost | 0 (fixed in Story 1.2) | 15-20 | +15-20 |
| Must-Have Features | 0 | 5 | +5 |
| Deployment Match | 5 (already works) | 5 | 0 |
| Speed to Deploy | 0 | 0 | 0 |
| **TOTAL** | **15** | **60-80** | **+45-65** |

#### File Locations

1. **Base Scorer** (3 functions to modify):
   - File: `backend/src/matching/base-scorer.ts`
   - Function 1: `calculateSizeFit()` (lines 65-90)
   - Function 2: `calculateGeoCoverage()` (lines 100-123)
   - Function 3: `calculatePriceScore()` (lines 133-153) - verify only

2. **Priority Boost** (1 function to modify):
   - File: `backend/src/matching/priority-boost.ts`
   - Function: `calculateFeatureBoost()` (lines 67-96)

3. **Scoring Constants**:
   - File: `backend/src/types/matching.types.ts`
   - Constants: `SCORING_WEIGHTS`, `SIZE_FIT_SCORES`, `PRIORITY_BOOST_WEIGHTS`

#### Current Implementation

**Source:** [Project: backend/src/matching/base-scorer.ts]

**1. Company Size Fit (Lines 65-90):**
```typescript
export function calculateSizeFit(priorities: AssessmentPriorities, vendor: Vendor): number {
  const userSize = priorities.companySize;
  const vendorSegments = vendor.targetSegments || [];

  // Edge case: Vendor has no target segments
  if (vendorSegments.length === 0) {
    return SIZE_FIT_SCORES.NO_MATCH;  // ❌ Currently 0 points
  }

  // ... rest of logic
}
```

**Fix:**
```typescript
  // Edge case: Vendor has no target segments - assume serves all
  if (vendorSegments.length === 0) {
    return SIZE_FIT_SCORES.PARTIAL_MATCH;  // ✅ 10 points (generous assumption)
  }
```

**2. Geographic Coverage (Lines 100-123):**
```typescript
export function calculateGeoCoverage(priorities: AssessmentPriorities, vendor: Vendor): number {
  const requiredJurisdictions = priorities.jurisdictions || [];
  const vendorCoverage = vendor.geographicCoverage || [];

  // Edge case: No jurisdictions required
  if (requiredJurisdictions.length === 0) {
    return SCORING_WEIGHTS.GEO_COVERAGE;  // Full points if user doesn't care
  }

  // Global vendor covers everything
  if (vendorCoverage.includes('GLOBAL') || vendorCoverage.includes('Global')) {
    return SCORING_WEIGHTS.GEO_COVERAGE;
  }

  // ❌ If vendorCoverage is empty and user requires jurisdictions → 0 points
  const matched = requiredJurisdictions.filter((jurisdiction) =>
    vendorCoverageLower.includes(jurisdiction.toLowerCase())
  ).length;

  const coverage = matched / requiredJurisdictions.length;
  return coverage * SCORING_WEIGHTS.GEO_COVERAGE;  // 0 matched → 0 points
}
```

**Fix:**
```typescript
  // Add after "Global" check:
  // Edge case: Vendor coverage unknown - assume global as fallback
  if (vendorCoverage.length === 0) {
    return SCORING_WEIGHTS.GEO_COVERAGE / 2;  // ✅ 10 points (generous assumption)
  }
```

**3. Feature Matching (Lines 67-96 in priority-boost.ts):**
```typescript
export function calculateFeatureBoost(
  vendor: Vendor,
  priorities: AssessmentPriorities
): { boost: number; missingFeatures: string[] } {
  const requiredFeatures = priorities.mustHaveFeatures || [];
  const vendorFeatures = vendor.features || [];

  // If no features required, vendor gets full points
  if (requiredFeatures.length === 0) {
    return { boost: PRIORITY_BOOST_WEIGHTS.FEATURES_ALL, missingFeatures: [] };
  }

  // ❌ If vendor features empty but user requires features → 0 points
  const missing = requiredFeatures.filter(
    feature => !vendorFeatures.includes(feature)
  );

  // All features present
  if (missing.length === 0) {
    return { boost: PRIORITY_BOOST_WEIGHTS.FEATURES_ALL, missingFeatures: [] };
  }

  // Missing 1-2 features: partial credit
  if (missing.length <= 2) {
    return { boost: PRIORITY_BOOST_WEIGHTS.FEATURES_PARTIAL, missingFeatures: missing };
  }

  // Missing 3+ features: no points
  return { boost: 0, missingFeatures: missing };
}
```

**Fix:**
```typescript
  // Add after "no features required" check:
  // Edge case: Vendor features unknown - give benefit of doubt
  if (vendorFeatures.length === 0) {
    return { boost: PRIORITY_BOOST_WEIGHTS.FEATURES_PARTIAL, missingFeatures: [] };
    // ✅ 5 points (neutral stance)
  }
```

#### Scoring Constants Reference

**Source:** [Project: backend/src/types/matching.types.ts]

```typescript
export const SCORING_WEIGHTS = {
  RISK_AREA_COVERAGE: 40,
  SIZE_FIT: 20,
  GEO_COVERAGE: 20,
  PRICE: 20,
};

export const SIZE_FIT_SCORES = {
  EXACT_MATCH: 20,      // Vendor targets user's exact company size
  PARTIAL_MATCH: 10,    // Vendor targets adjacent segment (or unknown)
  NO_MATCH: 0,          // Vendor targets completely different segment
};

export const PRIORITY_BOOST_WEIGHTS = {
  TOP_PRIORITY_RANK_1: 20,
  TOP_PRIORITY_RANK_2: 10,
  TOP_PRIORITY_RANK_3: 5,
  FEATURES_ALL: 10,       // All required features present
  FEATURES_PARTIAL: 5,    // 1-2 features missing (or unknown)
  DEPLOYMENT_MATCH: 5,
  SPEED_BOOST: 5,
};
```

---

### Testing

#### Test Framework
- **Framework:** Vitest 3
- **Test Files:**
  - `backend/tests/matching/base-scorer.test.ts`
  - `backend/tests/matching/priority-boost.test.ts`
- **Command:** `npm run test` (from backend directory)

#### Test Coverage Requirements

1. **Base Scorer Tests:**
   ```typescript
   describe('calculateSizeFit with missing data', () => {
     test('empty targetSegments awards 10 partial points', () => {
       const vendor = { targetSegments: [] };
       const priorities = { companySize: 'SMB' };
       expect(calculateSizeFit(priorities, vendor)).toBe(10);
     });

     test('exact match still awards 20 points', () => {
       const vendor = { targetSegments: ['SMB'] };
       const priorities = { companySize: 'SMB' };
       expect(calculateSizeFit(priorities, vendor)).toBe(20);
     });
   });

   describe('calculateGeoCoverage with missing data', () => {
     test('empty geographicCoverage awards 10 partial points', () => {
       const vendor = { geographicCoverage: [] };
       const priorities = { jurisdictions: ['US', 'EU'] };
       expect(calculateGeoCoverage(priorities, vendor)).toBe(10);
     });

     test('GLOBAL coverage still awards 20 points', () => {
       const vendor = { geographicCoverage: ['GLOBAL'] };
       const priorities = { jurisdictions: ['US', 'EU'] };
       expect(calculateGeoCoverage(priorities, vendor)).toBe(20);
     });
   });
   ```

2. **Priority Boost Tests:**
   ```typescript
   describe('calculateFeatureBoost with missing data', () => {
     test('empty features awards 5 partial points when features required', () => {
       const vendor = { features: [] };
       const priorities = { mustHaveFeatures: ['API', 'Real-time'] };
       const result = calculateFeatureBoost(vendor, priorities);
       expect(result.boost).toBe(5);
       expect(result.missingFeatures).toEqual([]);
     });

     test('all features present still awards 10 points', () => {
       const vendor = { features: ['API', 'Real-time'] };
       const priorities = { mustHaveFeatures: ['API', 'Real-time'] };
       expect(calculateFeatureBoost(vendor, priorities).boost).toBe(10);
     });
   });
   ```

3. **Integration Test:**
   - Run full vendor matching with vendors that have empty metadata
   - Verify scores increase from 15 to 45+ points
   - Verify vendors with actual metadata still score higher

---

### Implementation Guidance

#### Code Change Locations (Exact Lines)

**File 1: backend/src/matching/base-scorer.ts**

Change 1 (Line 70):
```typescript
// BEFORE:
if (vendorSegments.length === 0) {
  return SIZE_FIT_SCORES.NO_MATCH;
}

// AFTER:
// Generous assumption: if target segments unknown, assume vendor serves all company sizes
if (vendorSegments.length === 0) {
  return SIZE_FIT_SCORES.PARTIAL_MATCH; // 10 points - benefit of doubt
}
```

Change 2 (After Line 111, insert new block):
```typescript
// After "Global vendor covers everything" check
if (vendorCoverage.includes('GLOBAL') || vendorCoverage.includes('Global')) {
  return SCORING_WEIGHTS.GEO_COVERAGE;
}

// ✅ ADD THIS NEW BLOCK:
// Generous assumption: if geographic coverage unknown, assume global reach
if (vendorCoverage.length === 0) {
  return SCORING_WEIGHTS.GEO_COVERAGE / 2; // 10 points - benefit of doubt
}
```

**File 2: backend/src/matching/priority-boost.ts**

Change 3 (After Line 76, insert new block):
```typescript
// If no features required, vendor gets full points
if (requiredFeatures.length === 0) {
  return { boost: PRIORITY_BOOST_WEIGHTS.FEATURES_ALL, missingFeatures: [] };
}

// ✅ ADD THIS NEW BLOCK:
// Neutral assumption: if vendor features unknown, give partial credit
// Vendor might have capabilities but hasn't documented them
if (vendorFeatures.length === 0) {
  return { boost: PRIORITY_BOOST_WEIGHTS.FEATURES_PARTIAL, missingFeatures: [] };
}
```

#### Logging Strategy

Add debug logging to track partial credit awards:

```typescript
this.logger.debug('Partial credit awarded for missing data', {
  vendorId: vendor.id,
  component: 'sizeFit', // or 'geoCoverage', 'features'
  reason: 'Empty targetSegments array',
  pointsAwarded: 10,
  assumption: 'Vendor serves all company sizes',
});
```

---

### Expected Impact

**Before Fix (After Stories 1.1 + 1.2):**
- Average Score: 15-30 points (10-21%)
- All vendors score similarly low due to missing metadata

**After Fix (Stories 1.1 + 1.2 + 1.3):**
- Average Score: 45-60 points (32-43%)
- Vendors differentiated by categories and priorities
- Marketplace appears functional with reasonable scores

**Score Breakdown Example (Napier AI):**
| Component | Before | After | Change |
|-----------|--------|-------|--------|
| Risk Coverage (Story 1.1) | 0 | 15 | +15 |
| Size Fit (Story 1.3) | 0 | 10 | +10 |
| Geo Coverage (Story 1.3) | 0 | 10 | +10 |
| Price | 10 | 10 | 0 |
| Priority Boost (Story 1.2) | 0 | 20 | +20 |
| Features (Story 1.3) | 0 | 5 | +5 |
| Deployment | 5 | 5 | 0 |
| **TOTAL** | **15** | **75** | **+60** |

**Success Criteria:**
- Vendors with empty metadata score 40-50 points (not 10-20)
- Vendors with partial metadata score 50-70 points
- Vendors with complete metadata score 70-100+ points
- Clear differentiation based on category/priority fit

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation from Epic 1 | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by development agent_

### Debug Log References
_To be filled by development agent_

### Completion Notes List
_To be filled by development agent_

### File List
_To be filled by development agent_

---

## QA Results
_To be filled by QA agent after implementation review_
