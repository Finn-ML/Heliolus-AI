# Story 5.2: Create UserAssessmentQuota Model

## Status
Draft

## Story
**As a** system,
**I want** to track assessment usage per user across all tiers,
**so that** we can enforce Freemium limits (2 total), Premium limits (2 per cycle), and Enterprise unlimited access.

## Acceptance Criteria
1. New `UserAssessmentQuota` model created with following fields:
   - `id` (cuid, primary key)
   - `userId` (string, unique, foreign key to User)
   - `totalAssessmentsCreated` (int, default 0) - for Freemium tracking
   - `assessmentsThisMonth` (int, default 0) - for Premium billing cycle
   - `assessmentsUsedThisMonth` (int, default 0) - for Premium tracking
   - `createdAt`, `updatedAt` timestamps
2. Index on `userId` for fast lookups
3. Cascade delete when user is deleted
4. Migration created and tested
5. Initial quota records created for all existing users (default values)

## Tasks / Subtasks

- [ ] **Task 1: Create UserAssessmentQuota Model in Prisma Schema** (AC: 1, 2, 3)
  - [ ] Open `backend/prisma/schema.prisma`
  - [ ] Add new model after User model (around line 299)
  - [ ] Define model structure:
    ```prisma
    model UserAssessmentQuota {
      id          String @id @default(cuid())
      userId      String @unique

      // Freemium tracking
      totalAssessmentsCreated  Int @default(0)

      // Premium tracking
      assessmentsThisMonth     Int @default(0)
      assessmentsUsedThisMonth Int @default(0)

      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt

      // Relations
      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@index([userId])
    }
    ```
  - [ ] Add relation to User model (in Relations section):
    ```prisma
    assessmentQuota UserAssessmentQuota?
    ```

- [ ] **Task 2: Generate Prisma Migration** (AC: 4)
  - [ ] Run: `npx prisma migrate dev --name create_user_assessment_quota`
  - [ ] Review generated SQL migration file
  - [ ] Verify foreign key constraint to User with CASCADE delete
  - [ ] Verify unique constraint on userId
  - [ ] Verify index on userId
  - [ ] Verify default values (0 for all int fields)

- [ ] **Task 3: Create Migration Seed Script for Existing Users** (AC: 5)
  - [ ] Create file: `backend/prisma/migrations/[timestamp]_create_user_assessment_quota/seed-quotas.ts`
  - [ ] Script should:
    - Query all existing User records
    - Create UserAssessmentQuota for each user with default values (all 0)
    - Use `createMany` with `skipDuplicates: true` for idempotency
  - [ ] Add script to migration documentation

- [ ] **Task 4: Update User Type to Include Quota Relation** (AC: 1)
  - [ ] Run: `npx prisma generate`
  - [ ] Verify generated types include `UserAssessmentQuota` model
  - [ ] Verify User type includes optional `assessmentQuota` relation
  - [ ] Check TypeScript compilation: `npm run build`

- [ ] **Task 5: Test Migration on Development Database** (AC: 4, 5)
  - [ ] Apply migration to dev database
  - [ ] Run seed script to create quota records for existing users
  - [ ] Query database to verify:
    - UserAssessmentQuota table exists
    - All existing users have quota records
    - All quota fields default to 0
    - Foreign key constraint works (try deleting test user)
    - Unique constraint prevents duplicate userId entries

- [ ] **Task 6: Write Unit Tests** (AC: 1-5)
  - [ ] Create test file: `backend/tests/unit/user-assessment-quota.test.ts`
  - [ ] Test model creation with default values
  - [ ] Test unique constraint on userId
  - [ ] Test cascade delete when user is deleted
  - [ ] Test incrementing quota counters
  - [ ] Test querying quota by userId
  - [ ] Run tests: `npm test`

- [ ] **Task 7: Create Helper Service Method** (AC: 1)
  - [ ] In `backend/src/services/user.service.ts`, add method:
    ```typescript
    async ensureUserQuota(userId: string): Promise<UserAssessmentQuota> {
      // Get or create quota record for user
      let quota = await this.prisma.userAssessmentQuota.findUnique({
        where: { userId }
      });

      if (!quota) {
        quota = await this.prisma.userAssessmentQuota.create({
          data: { userId }
        });
      }

      return quota;
    }
    ```
  - [ ] Use this method when creating new users or checking quotas

## Dev Notes

### Model Purpose & Usage
This model tracks assessment creation quotas across all subscription tiers:

**Freemium (FREE) Tier:**
- Uses: `totalAssessmentsCreated`
- Limit: 2 assessments LIFETIME (non-renewable)
- Check: `if (quota.totalAssessmentsCreated >= 2) throw error`

**Premium (PAID) Tier:**
- Uses: `assessmentsUsedThisMonth`
- Limit: 2 assessments per billing cycle (monthly/annual)
- Reset: Monthly on billing renewal
- Check: `if (quota.assessmentsUsedThisMonth >= 2) check if can purchase more`

**Enterprise Tier:**
- No quota checks (unlimited)
- Fields still tracked for analytics

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#User Tiers]

---

### Database Schema Context

**User Model Location:** `backend/prisma/schema.prisma` lines 257-297

**Existing User Relations (line 287-293):**
```prisma
// Relations
organization      Organization?
subscription      Subscription?
assessments       Assessment[]
auditLogs         AuditLog[]
vendorContacts    VendorContact[]
claimedSessions   AnonymousSession[]
```

**Add New Relation:**
```prisma
assessmentQuota   UserAssessmentQuota?  // NEW - 1:1 optional relationship
```

**New Model Placement:** After User model, before Organization model (around line 299)

[Source: backend/prisma/schema.prisma#User]

---

### Relationship Pattern

This follows the **1:1 optional relationship pattern** used by Subscription:

**Pattern:**
- Parent (User) has optional child: `assessmentQuota UserAssessmentQuota?`
- Child has required parent: `user User @relation(fields: [userId], references: [id])`
- Unique constraint on foreign key: `userId String @unique`
- Cascade delete: `onDelete: Cascade`

**Similar Pattern in Codebase:**
```prisma
// User → Subscription (1:1 optional)
model User {
  subscription Subscription?
}

model Subscription {
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}
```

[Source: backend/prisma/schema.prisma#Subscription]

---

### Field Definitions

**Primary Key:**
- `id String @id @default(cuid())` - Standard CUID pattern

**Foreign Key:**
- `userId String @unique` - One quota record per user
- Indexed automatically by unique constraint
- Additional explicit index for query performance

**Quota Counters:**
1. `totalAssessmentsCreated Int @default(0)`
   - Incremented on EVERY assessment creation
   - Never reset
   - Used for: Freemium 2-assessment lifetime limit

2. `assessmentsThisMonth Int @default(0)`
   - Incremented on assessment creation
   - Reset monthly on billing cycle renewal
   - Used for: Premium billing cycle tracking

3. `assessmentsUsedThisMonth Int @default(0)`
   - Incremented when assessment COMPLETED (not just created)
   - Reset monthly on billing cycle renewal
   - Used for: Premium 2-per-cycle enforcement

**Timestamps:**
- `createdAt DateTime @default(now())`
- `updatedAt DateTime @updatedAt` - Auto-updated by Prisma

---

### Migration Strategy

**Migration Name:** `create_user_assessment_quota`

**Expected SQL Operations:**
1. CREATE TABLE `UserAssessmentQuota`
2. ADD COLUMN to User table? NO - Relations are virtual in Prisma
3. CREATE UNIQUE INDEX on `userId`
4. CREATE INDEX on `userId` (@@index)
5. ADD FOREIGN KEY constraint with CASCADE delete

**Seed Script Location:**
`backend/prisma/migrations/[timestamp]_create_user_assessment_quota/seed-quotas.ts`

**Seed Script Logic:**
```typescript
import { PrismaClient } from '../../../src/generated/prisma';

const prisma = new PrismaClient();

async function seedUserQuotas() {
  const users = await prisma.user.findMany({
    select: { id: true }
  });

  await prisma.userAssessmentQuota.createMany({
    data: users.map(user => ({
      userId: user.id,
      totalAssessmentsCreated: 0,
      assessmentsThisMonth: 0,
      assessmentsUsedThisMonth: 0
    })),
    skipDuplicates: true
  });

  console.log(`✅ Created quota records for ${users.length} users`);
}

seedUserQuotas()
  .catch(e => console.error(e))
  .finally(() => prisma.$disconnect());
```

**Run After Migration:**
```bash
npx tsx backend/prisma/migrations/[timestamp]_create_user_assessment_quota/seed-quotas.ts
```

[Source: architecture.md#Database Migration Safety]

---

### Cascade Delete Behavior

**When User is Deleted:**
- `onDelete: Cascade` ensures UserAssessmentQuota is automatically deleted
- This prevents orphaned quota records
- Follows GDPR data deletion requirements

**Test Case:**
```typescript
// Delete user
await prisma.user.delete({ where: { id: testUserId } });

// Verify quota auto-deleted
const quota = await prisma.userAssessmentQuota.findUnique({
  where: { userId: testUserId }
});

expect(quota).toBeNull(); // Should be auto-deleted
```

[Source: backend/prisma/schema.prisma#Cascade Patterns]

---

### Helper Service Method

**Location:** `backend/src/services/user.service.ts`

**Purpose:** Ensure every user has a quota record (lazy creation)

**Usage in Other Services:**
```typescript
// In AssessmentService.createAssessment()
const userService = new UserService(this.prisma, this.logger);
const quota = await userService.ensureUserQuota(userId);

if (subscription.plan === 'FREE' && quota.totalAssessmentsCreated >= 2) {
  throw this.createError('Freemium quota exceeded', 402);
}

// Increment quota
await this.prisma.userAssessmentQuota.update({
  where: { userId },
  data: { totalAssessmentsCreated: { increment: 1 } }
});
```

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Assessment Service]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/unit/user-assessment-quota.test.ts`

**Required Test Cases:**

1. **Model Creation**
   - Create quota with default values (all 0)
   - Create quota with custom values
   - Verify timestamps auto-populated

2. **Unique Constraint**
   - Create quota for user A → success
   - Create second quota for user A → fails with unique constraint error
   - Error code: P2002 (Prisma unique constraint violation)

3. **Cascade Delete**
   - Create user with quota
   - Delete user
   - Verify quota auto-deleted

4. **Incrementing Counters**
   - Increment totalAssessmentsCreated using atomic update
   - Increment assessmentsThisMonth
   - Increment assessmentsUsedThisMonth
   - Verify counters increment correctly

5. **Querying by UserId**
   - Query quota by userId (unique lookup)
   - Verify fast query performance (indexed)

**Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { PrismaClient } from '../src/generated/prisma';

describe('UserAssessmentQuota Model', () => {
  let prisma: PrismaClient;
  let testUserId: string;

  beforeAll(async () => {
    prisma = new PrismaClient();

    // Create test user
    const user = await prisma.user.create({
      data: {
        email: 'quota-test@example.com',
        firstName: 'Test',
        lastName: 'User',
        password: 'hashed_password'
      }
    });
    testUserId = user.id;
  });

  afterAll(async () => {
    // Cleanup
    await prisma.user.delete({ where: { id: testUserId } });
    await prisma.$disconnect();
  });

  it('should create quota with default values', async () => {
    const quota = await prisma.userAssessmentQuota.create({
      data: { userId: testUserId }
    });

    expect(quota.totalAssessmentsCreated).toBe(0);
    expect(quota.assessmentsThisMonth).toBe(0);
    expect(quota.assessmentsUsedThisMonth).toBe(0);
    expect(quota.userId).toBe(testUserId);
  });

  it('should enforce unique constraint on userId', async () => {
    await expect(
      prisma.userAssessmentQuota.create({
        data: { userId: testUserId } // Duplicate
      })
    ).rejects.toThrow(); // P2002 error
  });

  it('should cascade delete when user deleted', async () => {
    const tempUser = await prisma.user.create({
      data: {
        email: 'temp@example.com',
        firstName: 'Temp',
        lastName: 'User',
        password: 'pass'
      }
    });

    await prisma.userAssessmentQuota.create({
      data: { userId: tempUser.id }
    });

    // Delete user
    await prisma.user.delete({ where: { id: tempUser.id } });

    // Verify quota deleted
    const quota = await prisma.userAssessmentQuota.findUnique({
      where: { userId: tempUser.id }
    });

    expect(quota).toBeNull();
  });

  it('should increment counters atomically', async () => {
    const quota = await prisma.userAssessmentQuota.create({
      data: { userId: testUserId }
    });

    // Increment totalAssessmentsCreated
    await prisma.userAssessmentQuota.update({
      where: { userId: testUserId },
      data: { totalAssessmentsCreated: { increment: 1 } }
    });

    const updated = await prisma.userAssessmentQuota.findUnique({
      where: { userId: testUserId }
    });

    expect(updated?.totalAssessmentsCreated).toBe(1);
  });
});
```

[Source: architecture.md#Testing Strategy]

---

### Previous Story Context

**Story 5.1 Completed:**
- Added `BillingCycle` enum (MONTHLY, ANNUAL)
- Added billing fields to Subscription model
- This story builds on subscription tier tracking

**Dependency:**
- UserAssessmentQuota needs User model (already exists)
- No dependency on Story 5.1 (can run in parallel if needed)

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 5 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
_TBD_

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
