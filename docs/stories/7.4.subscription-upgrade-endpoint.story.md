# Story 7.4: Create Subscription Upgrade Endpoint

## Status
Draft

## Story
**As a** user,
**I want** to upgrade my subscription via API,
**so that** I can move from FREE to PREMIUM tier.

## Acceptance Criteria
1. New endpoint: `POST /v1/subscriptions/:userId/upgrade`
2. Route protected by: `authMiddleware`
3. Request schema validation:
   ```typescript
   params: z.object({ userId: z.string() })
   body: z.object({
     plan: z.enum(['PREMIUM']),
     billingCycle: z.enum(['MONTHLY', 'ANNUAL']),
     stripePaymentMethodId: z.string()
   })
   ```
4. Endpoint calls: `subscriptionService.createSubscription(userId, plan, billingCycle)`
5. For now, payment processing is mocked (Stripe integration future story)
6. Success response (200):
   ```json
   {
     "success": true,
     "data": { /* Updated subscription record */ }
   }
   ```
7. Endpoint triggers assessment unlock for existing Freemium assessments (future enhancement)
8. Error responses:
   - 401 if unauthenticated
   - 403 if userId doesn't match authenticated user (unless admin)
   - 400 if invalid plan or billing cycle

## Tasks / Subtasks

- [ ] **Task 1: Define Request/Response Schemas** (AC: 3, 6)
  - [ ] Open `backend/src/routes/subscription.routes.ts`
  - [ ] Add Zod schemas after existing schemas (~line 40):
    ```typescript
    const UpgradeSubscriptionParamsSchema = z.object({
      userId: z.string().cuid('Invalid user ID format'),
    });

    const UpgradeSubscriptionBodySchema = z.object({
      plan: z.enum(['PREMIUM'], { errorMap: () => ({ message: 'Only PREMIUM plan upgrades supported' }) }),
      billingCycle: z.enum(['MONTHLY', 'ANNUAL']),
      stripePaymentMethodId: z.string().min(1, 'Payment method ID is required'),
    });
    ```
  - [ ] Add Fastify response schema:
    ```typescript
    const UpgradeSubscriptionResponseSchema = {
      200: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          data: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              userId: { type: 'string' },
              plan: { type: 'string' },
              status: { type: 'string' },
              billingCycle: { type: 'string', nullable: true },
              creditsBalance: { type: 'number' },
              currentPeriodStart: { type: 'string' },
              currentPeriodEnd: { type: 'string', nullable: true },
              renewalDate: { type: 'string', nullable: true },
              stripeCustomerId: { type: 'string', nullable: true },
              stripeSubscriptionId: { type: 'string', nullable: true },
              createdAt: { type: 'string' },
              updatedAt: { type: 'string' },
            },
          },
        },
      },
      400: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          message: { type: 'string' },
          code: { type: 'string' },
        },
      },
      401: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          message: { type: 'string' },
          code: { type: 'string' },
        },
      },
      403: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          message: { type: 'string' },
          code: { type: 'string' },
        },
      },
    };
    ```

- [ ] **Task 2: Create POST /subscriptions/:userId/upgrade Endpoint** (AC: 1, 2)
  - [ ] Add endpoint definition inside `subscriptionRoutes` function:
    ```typescript
    server.post('/:userId/upgrade', {
      schema: {
        description: 'Upgrade user subscription to PREMIUM plan',
        tags: ['Subscriptions'],
        params: UpgradeSubscriptionParamsSchema,
        body: UpgradeSubscriptionBodySchema,
        response: UpgradeSubscriptionResponseSchema,
      },
      preHandler: authenticationMiddleware,
    }, asyncHandler(async (request, reply) => {
      // Implementation in next task
    }));
    ```

- [ ] **Task 3: Implement Authorization Check** (AC: 8)
  - [ ] Parse request and check user ownership:
    ```typescript
    const { userId } = request.params as z.infer<typeof UpgradeSubscriptionParamsSchema>;
    const { plan, billingCycle, stripePaymentMethodId } = request.body as z.infer<typeof UpgradeSubscriptionBodySchema>;
    const user = (request as any).user ?? (request as any).currentUser;

    // User can only upgrade their own subscription (unless admin)
    if (user.id !== userId && user.role !== 'ADMIN') {
      return reply.status(403).send({
        success: false,
        message: 'You can only upgrade your own subscription',
        code: 'FORBIDDEN',
      });
    }
    ```

- [ ] **Task 4: Check for Existing Subscription** (AC: 4)
  - [ ] Query existing subscription:
    ```typescript
    const existingSubscription = await subscriptionService.getSubscriptionByUserId(userId);
    ```
  - [ ] Determine if creating new or updating existing:
    ```typescript
    let subscription;

    if (!existingSubscription.success || !existingSubscription.data) {
      // No existing subscription - create new
      subscription = await subscriptionService.createSubscription(
        userId,
        {
          plan,
          billingCycle,
          paymentMethodId: stripePaymentMethodId,
        },
        { userId: user.id, userRole: user.role }
      );
    } else {
      // Existing subscription - update it
      subscription = await subscriptionService.updateSubscription(
        existingSubscription.data.id,
        {
          plan,
          billingCycle,
          paymentMethodId: stripePaymentMethodId,
        },
        { userId: user.id, userRole: user.role }
      );
    }
    ```

- [ ] **Task 5: Add Mock Payment Processing Comment** (AC: 5)
  - [ ] Add TODO comment above service call:
    ```typescript
    // TODO: Stripe payment processing
    // In production, this endpoint should:
    // 1. Create Stripe checkout session
    // 2. Redirect user to Stripe payment page
    // 3. Handle webhook confirmation before activating subscription
    // For now, payment is mocked - subscription activated immediately
    ```

- [ ] **Task 6: Return Success Response** (AC: 6)
  - [ ] Return subscription data:
    ```typescript
    if (!subscription.success || !subscription.data) {
      throw new Error('Failed to create/update subscription');
    }

    reply.status(200).send({
      success: true,
      data: subscription.data,
    });
    ```

- [ ] **Task 7: Add Error Handling** (AC: 8)
  - [ ] Wrap handler in try-catch:
    ```typescript
    try {
      // Main logic
    } catch (error: any) {
      request.log.error({ error, userId }, 'Failed to upgrade subscription');

      if (error.code === 'INVALID_PLAN') {
        return reply.status(400).send({
          success: false,
          message: error.message || 'Invalid subscription plan',
          code: 'INVALID_PLAN',
        });
      }

      if (error.code === 'PAYMENT_REQUIRED') {
        return reply.status(402).send({
          success: false,
          message: error.message || 'Payment method invalid',
          code: 'PAYMENT_REQUIRED',
        });
      }

      // Let error middleware handle others
      throw error;
    }
    ```

- [ ] **Task 8: Add JSDoc Documentation** (AC: 1, 5, 7)
  - [ ] Add comment above endpoint:
    ```typescript
    /**
     * Upgrade Subscription to PREMIUM
     *
     * POST /v1/subscriptions/:userId/upgrade
     *
     * Allows users to upgrade from FREE to PREMIUM tier.
     * Currently supports PREMIUM plan only (ENTERPRISE requires admin).
     *
     * IMPORTANT: Payment processing is currently MOCKED.
     * In production, this will integrate with Stripe checkout flow.
     *
     * @param userId - User ID (must match authenticated user unless admin)
     * @param plan - Target plan (PREMIUM only)
     * @param billingCycle - MONTHLY or ANNUAL billing
     * @param stripePaymentMethodId - Stripe payment method ID
     * @returns Updated subscription record
     *
     * @future Story 9.x - Integrate Stripe checkout
     * @future Story 9.x - Unlock Freemium assessments after upgrade
     *
     * @see Story 6.2 - SubscriptionService.createSubscription()
     */
    ```

- [ ] **Task 9: Add Future Enhancement Comment for Assessment Unlock** (AC: 7)
  - [ ] Add TODO comment in handler after successful upgrade:
    ```typescript
    // TODO: Story 9.x - Unlock Freemium assessments
    // After successful upgrade, unlock any assessments marked as freemium-restricted
    // await assessmentService.unlockFreemiumAssessments(userId);
    ```

- [ ] **Task 10: Write Integration Test** (AC: 1-8)
  - [ ] Create test file: `backend/tests/integration/subscription-upgrade-endpoint.test.ts`
  - [ ] Test FREE user upgrading to PREMIUM (200)
  - [ ] Test subscription record updated with new plan and billing cycle
  - [ ] Test creditsBalance updated to PREMIUM allocation (100)
  - [ ] Test user can only upgrade own subscription (403 if different userId)
  - [ ] Test admin can upgrade any user's subscription (200)
  - [ ] Test invalid billing cycle gets 400
  - [ ] Test missing payment method ID gets 400
  - [ ] Test unauthenticated request gets 401
  - [ ] Run tests: `npm test`

- [ ] **Task 11: Update OpenAPI/Swagger Documentation** (AC: 1)
  - [ ] Verify Swagger UI includes new endpoint at `/documentation`
  - [ ] Verify "Subscriptions" tag grouping
  - [ ] Verify request/response examples shown

## Dev Notes

### Endpoint Purpose
This endpoint enables users to self-service upgrade from FREE to PREMIUM tier:
- User clicks "Upgrade to Premium" button in frontend
- Frontend calls this endpoint with billing cycle selection
- Backend creates/updates subscription with PREMIUM plan
- User immediately gains PREMIUM features (100 credits, unlimited assessments)

**Current Limitation:** Payment processing is mocked. Stripe integration planned for future story.

[Source: docs/prd/epic-7-api-endpoints.md#Story 3.4]

---

### SubscriptionService Integration

**Service Location:** `backend/src/services/subscription.service.ts`

**Method 1: createSubscription (from Story 6.2):**
```typescript
async createSubscription(
  userId: string,
  data: {
    plan: SubscriptionPlan,
    billingCycle?: BillingCycle,
    paymentMethodId?: string,
    trialDays?: number
  },
  context: ServiceContext
): Promise<ApiResponse<Subscription>>
```

**What createSubscription Does:**
1. Validates plan and billing cycle
2. Creates Stripe customer (mocked)
3. Creates Stripe subscription (mocked)
4. Calculates period dates based on billing cycle:
   - MONTHLY: now + 1 month
   - ANNUAL: now + 1 year
5. Sets creditsBalance based on plan (PREMIUM = 100 credits)
6. Creates Subscription record
7. Creates UserAssessmentQuota record
8. Logs audit event

**Method 2: updateSubscription:**
```typescript
async updateSubscription(
  subscriptionId: string,
  data: {
    plan?: SubscriptionPlan,
    billingCycle?: BillingCycle,
    paymentMethodId?: string
  },
  context: ServiceContext
): Promise<ApiResponse<Subscription>>
```

**What updateSubscription Does:**
1. Queries existing subscription
2. Updates Stripe subscription (mocked)
3. Updates plan, billing cycle, period dates
4. Recalculates creditsBalance if plan changed
5. Updates Subscription record
6. Logs audit event

[Source: docs/stories/6.2.update-create-subscription.story.md, backend/src/services/subscription.service.ts]

---

### Subscription Routes File Structure

**Location:** `backend/src/routes/subscription.routes.ts`

**Existing Endpoints (lines 115-150):**
- GET /current - Get current user subscription
- (Other subscription endpoints)

**What to Add:**
- POST /:userId/upgrade - Upgrade subscription endpoint

**Authentication Pattern:**
```typescript
export default async function subscriptionRoutes(server: FastifyInstance) {
  // Individual endpoints use preHandler for auth
  server.post('/:userId/upgrade', {
    preHandler: authenticationMiddleware,
    // ...
  });
}
```

[Source: backend/src/routes/subscription.routes.ts:115-150]

---

### Authorization Logic

**User Ownership Check:**
```typescript
const user = (request as any).user ?? (request as any).currentUser;

if (user.id !== userId && user.role !== 'ADMIN') {
  return reply.status(403).send({
    success: false,
    message: 'You can only upgrade your own subscription',
    code: 'FORBIDDEN',
  });
}
```

**Why This Check:**
- Users should only upgrade their own subscription
- Admins can upgrade any user's subscription (for support/corrections)
- Prevents user A from upgrading user B's subscription

**Test Cases:**
1. User upgrades own subscription → 200 OK
2. User tries to upgrade different user's subscription → 403 Forbidden
3. Admin upgrades any user's subscription → 200 OK

[Source: docs/prd/epic-7-api-endpoints.md#Story 3.4]

---

### Credit Allocation

**From Story 6.2 CREDIT_ALLOCATION:**
```typescript
export const CREDIT_ALLOCATION = {
  FREE: 0,
  PREMIUM: 100,
  ENTERPRISE: 0,  // Admin grants manually
};
```

**Upgrade Flow:**
1. User on FREE plan has creditsBalance = 0
2. User upgrades to PREMIUM
3. createSubscription/updateSubscription sets creditsBalance = 100
4. User can now complete ~2 assessments (50 credits each)

**Important:** Credits are allocated immediately (no delay), even though payment is mocked.

[Source: docs/stories/6.2.update-create-subscription.story.md#Task 5]

---

### Billing Cycle Calculation

**From SubscriptionService (Story 6.2):**
```typescript
// MONTHLY billing
const currentPeriodEnd = new Date(now);
currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);

// ANNUAL billing
const currentPeriodEnd = new Date(now);
currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);
```

**Upgrade Example:**
- User upgrades on 2025-10-23 with MONTHLY billing
- currentPeriodStart: 2025-10-23T10:30:00Z
- currentPeriodEnd: 2025-11-23T10:30:00Z
- renewalDate: 2025-11-23T10:30:00Z

**Frontend Display:**
- "Your plan renews on November 23, 2025"
- "Next billing date: November 23, 2025"

[Source: docs/stories/6.2.update-create-subscription.story.md#Task 4]

---

### Mock Payment Processing

**Current Implementation:**
Payment processing is MOCKED using `backend/src/lib/payment/mock.ts`.

**Mock Functions:**
```typescript
export async function createStripeCustomer(email: string, name?: string) {
  return { id: `cus_mock_${Date.now()}` };
}

export async function createStripeSubscription(customerId: string, priceId: string) {
  return { id: `sub_mock_${Date.now()}`, status: 'active' };
}
```

**Why Mocked:**
- No Stripe credentials configured yet
- Allows development/testing without payment gateway
- Subscription activated immediately

**Future Story:**
- Story 9.x will integrate real Stripe checkout
- Will use Stripe hosted payment page
- Will wait for webhook confirmation before activating subscription
- Will handle failed payments, retries, cancellations

[Source: backend/src/lib/payment/mock.ts, docs/prd/epic-7-api-endpoints.md#Story 3.4]

---

### Future Enhancement: Assessment Unlock

**From AC 7:** "Endpoint triggers assessment unlock for existing Freemium assessments (future enhancement)"

**Background:**
- FREE users can create 2 assessments
- These assessments may have freemium restrictions (e.g., limited vendor matches, no PDF reports)
- When user upgrades to PREMIUM, these assessments should be "unlocked"

**Unlock Logic (Future Story):**
```typescript
// After successful upgrade
await assessmentService.unlockFreemiumAssessments(userId);

// unlockFreemiumAssessments would:
// 1. Find all assessments owned by userId
// 2. Remove freemium restrictions
// 3. Generate full vendor matches
// 4. Enable PDF report download
// 5. Update assessment status
```

**For This Story:**
Add TODO comment only, no implementation required.

[Source: docs/prd/epic-7-api-endpoints.md#Story 3.4]

---

### Error Handling

**Error Types:**

| Error Code | HTTP Status | Cause | Handled By |
|------------|-------------|-------|-----------|
| AUTH_REQUIRED | 401 | Missing/invalid JWT | authenticationMiddleware |
| FORBIDDEN | 403 | userId mismatch (non-admin) | Route handler authorization check |
| INVALID_PLAN | 400 | Plan not PREMIUM | Zod validation |
| INVALID_BILLING_CYCLE | 400 | Billing cycle not MONTHLY/ANNUAL | Zod validation |
| PAYMENT_REQUIRED | 402 | Payment method invalid | SubscriptionService (future) |

**Route Error Handler:**
```typescript
try {
  const subscription = await subscriptionService.createSubscription(...);
  reply.status(200).send({ success: true, data: subscription.data });
} catch (error: any) {
  request.log.error({ error, userId }, 'Failed to upgrade subscription');

  if (error.code === 'INVALID_PLAN') {
    return reply.status(400).send({
      success: false,
      message: error.message || 'Invalid subscription plan',
      code: 'INVALID_PLAN',
    });
  }

  throw error;  // Let error middleware handle others
}
```

[Source: backend/src/services/base.service.ts#createError]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/integration/subscription-upgrade-endpoint.test.ts`

**Test Structure:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { FastifyInstance } from 'fastify';
import { PrismaClient, SubscriptionPlan, UserRole } from '../src/generated/prisma';
import { buildServer } from '../src/server';

describe('Subscription Upgrade Endpoint', () => {
  let server: FastifyInstance;
  let prisma: PrismaClient;
  let freeUserId: string;
  let freeUserToken: string;
  let otherUserId: string;
  let otherUserToken: string;
  let adminUserId: string;
  let adminToken: string;

  beforeAll(async () => {
    server = await buildServer();
    prisma = new PrismaClient();

    // Create FREE user
    const freeUser = await prisma.user.create({
      data: {
        email: 'free@example.com',
        firstName: 'Free',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.FREE,
            creditsBalance: 0,
          },
        },
      },
    });
    freeUserId = freeUser.id;

    const freeAuthResponse = await server.inject({
      method: 'POST',
      url: '/v1/auth/login',
      payload: { email: 'free@example.com', password: 'hashed' },
    });
    freeUserToken = freeAuthResponse.json().token;

    // Create another user (for 403 test)
    const otherUser = await prisma.user.create({
      data: {
        email: 'other@example.com',
        firstName: 'Other',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.FREE,
            creditsBalance: 0,
          },
        },
      },
    });
    otherUserId = otherUser.id;

    const otherAuthResponse = await server.inject({
      method: 'POST',
      url: '/v1/auth/login',
      payload: { email: 'other@example.com', password: 'hashed' },
    });
    otherUserToken = otherAuthResponse.json().token;

    // Create admin user
    const admin = await prisma.user.create({
      data: {
        email: 'admin@example.com',
        firstName: 'Admin',
        lastName: 'User',
        password: 'hashed',
        role: UserRole.ADMIN,
      },
    });
    adminUserId = admin.id;

    const adminAuthResponse = await server.inject({
      method: 'POST',
      url: '/v1/auth/login',
      payload: { email: 'admin@example.com', password: 'hashed' },
    });
    adminToken = adminAuthResponse.json().token;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: {
        email: { in: ['free@example.com', 'other@example.com', 'admin@example.com'] },
      },
    });
    await prisma.$disconnect();
    await server.close();
  });

  describe('POST /v1/subscriptions/:userId/upgrade', () => {
    it('should upgrade FREE user to PREMIUM', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${freeUserId}/upgrade`,
        headers: {
          authorization: `Bearer ${freeUserToken}`,
        },
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'MONTHLY',
          stripePaymentMethodId: 'pm_mock_123',
        },
      });

      expect(response.statusCode).toBe(200);
      const body = response.json();
      expect(body.success).toBe(true);
      expect(body.data.plan).toBe('PREMIUM');
      expect(body.data.billingCycle).toBe('MONTHLY');
      expect(body.data.creditsBalance).toBe(100);  // PREMIUM allocation
    });

    it('should calculate correct period end for MONTHLY billing', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${freeUserId}/upgrade`,
        headers: {
          authorization: `Bearer ${freeUserToken}`,
        },
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'MONTHLY',
          stripePaymentMethodId: 'pm_mock_123',
        },
      });

      const body = response.json();
      const periodStart = new Date(body.data.currentPeriodStart);
      const periodEnd = new Date(body.data.currentPeriodEnd);

      // Period end should be ~1 month after start
      const diffMs = periodEnd.getTime() - periodStart.getTime();
      const diffDays = diffMs / (1000 * 60 * 60 * 24);
      expect(diffDays).toBeGreaterThanOrEqual(28);
      expect(diffDays).toBeLessThanOrEqual(31);
    });

    it('should return 403 when user tries to upgrade different user', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${otherUserId}/upgrade`,  // Other user's ID
        headers: {
          authorization: `Bearer ${freeUserToken}`,  // Free user's token
        },
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'MONTHLY',
          stripePaymentMethodId: 'pm_mock_123',
        },
      });

      expect(response.statusCode).toBe(403);
      expect(response.json().code).toBe('FORBIDDEN');
    });

    it('should allow admin to upgrade any user', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${otherUserId}/upgrade`,  // Other user's ID
        headers: {
          authorization: `Bearer ${adminToken}`,  // Admin token
        },
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'MONTHLY',
          stripePaymentMethodId: 'pm_mock_123',
        },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json().data.plan).toBe('PREMIUM');
    });

    it('should return 400 for invalid billing cycle', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${freeUserId}/upgrade`,
        headers: {
          authorization: `Bearer ${freeUserToken}`,
        },
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'INVALID',  // Invalid
          stripePaymentMethodId: 'pm_mock_123',
        },
      });

      expect(response.statusCode).toBe(400);
    });

    it('should return 400 for missing payment method ID', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${freeUserId}/upgrade`,
        headers: {
          authorization: `Bearer ${freeUserToken}`,
        },
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'MONTHLY',
          // Missing stripePaymentMethodId
        },
      });

      expect(response.statusCode).toBe(400);
    });

    it('should return 401 for unauthenticated request', async () => {
      const response = await server.inject({
        method: 'POST',
        url: `/v1/subscriptions/${freeUserId}/upgrade`,
        // No authorization header
        payload: {
          plan: 'PREMIUM',
          billingCycle: 'MONTHLY',
          stripePaymentMethodId: 'pm_mock_123',
        },
      });

      expect(response.statusCode).toBe(401);
    });
  });
});
```

[Source: CLAUDE.md#Testing Infrastructure]

---

### File Locations
- **Route File:** `backend/src/routes/subscription.routes.ts`
- **Service:** `backend/src/services/subscription.service.ts` (from Story 6.2)
- **Test:** `backend/tests/integration/subscription-upgrade-endpoint.test.ts`

---

### Dependencies
**Depends On:**
- Story 6.2: SubscriptionService.createSubscription() with billingCycle support
- Existing: authenticationMiddleware
- Mock payment: backend/src/lib/payment/mock.ts

**Depended On By:**
- Story 8.x: Frontend upgrade UI will call this endpoint
- Story 9.x: Real Stripe checkout integration
- Story 9.x: Freemium assessment unlock after upgrade

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 7 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
_TBD_

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
