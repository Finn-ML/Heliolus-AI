# Story 1.09: Strategy Matrix Service - Timeline-Based Gap Organization

## Status
Ready for Review

## Story

**As a** backend developer,
**I want** to create a strategy matrix service that organizes gaps into timeline buckets with aggregated metrics,
**so that** users receive a phased remediation roadmap.

## Acceptance Criteria

1. New service file `strategy-matrix.service.ts` created
2. Method `generateStrategyMatrix(assessmentId: string): Promise<StrategyMatrix>` implemented
3. **Timeline Bucket Assignment:**
   - 0-6 months/Immediate: gaps with priority 8-10
   - 6-18 months/Near-term: gaps with priority 4-7
   - 18+ months/Strategic: gaps with priority 1-3
4. **Bucket Aggregation:**
   - Count gaps per bucket
   - Count effort distribution (small: X, medium: Y, large: Z)
   - Calculate cost range (sum individual gap costRanges, convert to human-readable total)
5. **Vendor Recommendations per Bucket:**
   - For each bucket, find vendors covering multiple gaps in that bucket
   - Rank by number of gaps covered
   - Return top 3 vendors per bucket with gap coverage details
6. Method returns:
   ```typescript
   {
     immediate: { gaps: Gap[], gapCount: number, effortDist: {S:x,M:y,L:z}, costRange: string, vendors: Vendor[] },
     nearTerm: { gaps: Gap[], gapCount: number, effortDist: {S:x,M:y,L:z}, costRange: string, vendors: Vendor[] },
     strategic: { gaps: Gap[], gapCount: number, effortDist: {S:x,M:y,L:z}, costRange: string, vendors: Vendor[] }
   }
   ```
7. Cache strategy matrix in Redis (key: `strategy_matrix:<assessmentId>`, TTL: 7 days)
8. Method invalidates cache when assessment updated or gaps modified
9. Unit tests verify bucket assignment logic, aggregation calculations, vendor ranking
10. Integration test: Generate matrix for assessment with 15 gaps across all priority levels, verify correct distribution

## Tasks / Subtasks

- [ ] Create strategy-matrix.service.ts (AC: 1)
  - [ ] Extend BaseService class
  - [ ] Import Prisma types: Gap, Vendor, Assessment
  - [ ] Import Redis client from config
  - [ ] Define StrategyMatrix, TimelineBucket interfaces
- [ ] Implement timeline bucket assignment (AC: 3)
  - [ ] Create helper: assignBucket(priority: number): 'immediate' | 'nearTerm' | 'strategic'
  - [ ] Priority 8-10 → 'immediate' (0-6 months)
  - [ ] Priority 4-7 → 'nearTerm' (6-18 months)
  - [ ] Priority 1-3 → 'strategic' (18+ months)
- [ ] Implement bucket aggregation (AC: 4)
  - [ ] Create helper: aggregateBucket(gaps: Gap[]): BucketMetrics
  - [ ] Count total gaps in bucket
  - [ ] Count effort distribution: {SMALL: x, MEDIUM: y, LARGE: z}
  - [ ] Sum cost ranges and convert to human-readable string
  - [ ] Return aggregated metrics
- [ ] Implement cost range summation
  - [ ] Create helper: sumCostRanges(gaps: Gap[]): string
  - [ ] Convert each gap.costRange to numeric midpoint
  - [ ] Sum all midpoints
  - [ ] Convert back to human-readable range (e.g., "€150K-€400K estimated")
  - [ ] Handle edge cases: no gaps, all "UNDER_10K", mix of ranges
- [ ] Implement vendor recommendations per bucket (AC: 5)
  - [ ] Create helper: findTopVendors(gaps: Gap[], limit: number): VendorRecommendation[]
  - [ ] Extract gap categories from bucket gaps
  - [ ] Query vendors matching those categories
  - [ ] For each vendor, count gaps covered (vendor.categories ∩ gap.categories)
  - [ ] Sort vendors by gaps covered descending
  - [ ] Return top 3 vendors with gap coverage count
- [ ] Implement generateStrategyMatrix method (AC: 2, 6)
  - [ ] Fetch all gaps for assessment with priority field
  - [ ] Group gaps by timeline bucket using assignBucket()
  - [ ] For each bucket (immediate, nearTerm, strategic):
    - Calculate aggregated metrics
    - Find top 3 vendor recommendations
    - Build TimelineBucket object
  - [ ] Return complete StrategyMatrix
- [ ] Implement Redis caching (AC: 7)
  - [ ] Generate cache key: `strategy_matrix:${assessmentId}`
  - [ ] Check cache before generating matrix
  - [ ] If cache hit: parse and return cached matrix
  - [ ] If cache miss: generate matrix, cache with TTL 7 days
  - [ ] Serialize matrix to JSON for Redis storage
- [ ] Implement cache invalidation (AC: 8)
  - [ ] Create method: invalidateCache(assessmentId: string)
  - [ ] Delete Redis key for assessment
  - [ ] Call from assessment.service.ts when gaps updated
  - [ ] Call when assessment re-scored or re-analyzed
- [ ] Write comprehensive unit tests (AC: 9)
  - [ ] Test assignBucket: priority 10 → 'immediate'
  - [ ] Test assignBucket: priority 5 → 'nearTerm'
  - [ ] Test assignBucket: priority 2 → 'strategic'
  - [ ] Test aggregateBucket: count gaps correctly
  - [ ] Test aggregateBucket: effort distribution {S:3, M:2, L:1}
  - [ ] Test sumCostRanges: mix of ranges → "€XXK-€YYK"
  - [ ] Test findTopVendors: ranks vendors by gap coverage
  - [ ] Test findTopVendors: returns top 3 only
  - [ ] Test generateStrategyMatrix: distributes 15 gaps correctly
  - [ ] Test caching: second call returns cached data
  - [ ] Test invalidation: cache cleared after update
- [ ] Integration test (AC: 10)
  - [ ] Create assessment with 15 gaps (varied priorities 1-10)
  - [ ] Create vendors covering different gap categories
  - [ ] Generate strategy matrix
  - [ ] Verify immediate bucket has priority 8-10 gaps
  - [ ] Verify nearTerm bucket has priority 4-7 gaps
  - [ ] Verify strategic bucket has priority 1-3 gaps
  - [ ] Verify vendor recommendations relevant to each bucket
  - [ ] Verify cost estimates reasonable
  - [ ] Test cache: generate twice, verify second call faster

## Dev Notes

### Relevant Source Tree
- `backend/src/services/strategy-matrix.service.ts` - NEW: Core strategy matrix service
- `backend/src/types/strategy-matrix.types.ts` - NEW: StrategyMatrix, TimelineBucket interfaces
- `backend/src/services/assessment.service.ts` - EXISTING: Will call invalidateCache on updates
- `backend/prisma/schema.prisma` - Gap model (priority, effort, costRange from Story 1.5)
- `backend/src/config/redis.ts` - Redis client configuration

### Strategy Matrix Data Structure

```typescript
interface StrategyMatrix {
  assessmentId: string
  generatedAt: Date
  immediate: TimelineBucket    // 0-6 months
  nearTerm: TimelineBucket     // 6-18 months
  strategic: TimelineBucket    // 18+ months
}

interface TimelineBucket {
  timeline: string             // "0-6 months", "6-18 months", "18+ months"
  gaps: Gap[]                  // Full gap objects
  gapCount: number             // Total gaps in bucket
  effortDistribution: {
    SMALL: number
    MEDIUM: number
    LARGE: number
  }
  estimatedCostRange: string   // "€50K-€150K estimated"
  topVendors: VendorRecommendation[]  // Top 3 vendors
}

interface VendorRecommendation {
  vendor: Vendor               // Full vendor object
  gapsCovered: number          // Number of gaps this vendor addresses
  coveredGapIds: string[]      // IDs of gaps covered
}
```

### Timeline Bucket Assignment Logic

```typescript
function assignBucket(priority: number): 'immediate' | 'nearTerm' | 'strategic' {
  if (priority >= 8) return 'immediate'   // Priority 8-10: Urgent
  if (priority >= 4) return 'nearTerm'    // Priority 4-7: Planned
  return 'strategic'                       // Priority 1-3: Long-term
}
```

**Rationale:**
- Priority scale from Story 1.5: 1-10 (1=lowest, 10=highest)
- High priority gaps (8-10) require immediate attention
- Medium priority gaps (4-7) planned for near-term
- Low priority gaps (1-3) strategic long-term improvements

### Bucket Aggregation

```typescript
function aggregateBucket(gaps: Gap[]): {
  gapCount: number
  effortDistribution: { SMALL: number, MEDIUM: number, LARGE: number }
  estimatedCostRange: string
} {
  const effortDist = {
    SMALL: gaps.filter(g => g.effort === 'SMALL').length,
    MEDIUM: gaps.filter(g => g.effort === 'MEDIUM').length,
    LARGE: gaps.filter(g => g.effort === 'LARGE').length
  }

  const estimatedCost = sumCostRanges(gaps)

  return {
    gapCount: gaps.length,
    effortDistribution: effortDist,
    estimatedCostRange: estimatedCost
  }
}
```

### Cost Range Summation

```typescript
function sumCostRanges(gaps: Gap[]): string {
  if (gaps.length === 0) return '€0'

  // Convert cost ranges to numeric midpoints
  const costMap: Record<CostRange, number> = {
    UNDER_10K: 5000,           // €5K midpoint
    RANGE_10K_50K: 30000,      // €30K midpoint
    RANGE_50K_100K: 75000,     // €75K midpoint
    RANGE_100K_250K: 175000,   // €175K midpoint
    OVER_250K: 400000          // €400K estimate for large projects
  }

  const totalCost = gaps.reduce((sum, gap) => {
    return sum + (costMap[gap.costRange] || 0)
  }, 0)

  // Convert back to human-readable range (±30% variance)
  const lowerBound = Math.round(totalCost * 0.7)
  const upperBound = Math.round(totalCost * 1.3)

  if (totalCost < 10000) return `€${Math.round(totalCost / 1000)}K estimated`
  if (totalCost < 100000) return `€${Math.round(lowerBound / 1000)}K-€${Math.round(upperBound / 1000)}K estimated`
  return `€${Math.round(lowerBound / 1000)}K-€${Math.round(upperBound / 1000)}K estimated`
}
```

**Example:**
- 3 gaps: RANGE_10K_50K, RANGE_50K_100K, RANGE_10K_50K
- Midpoints: €30K + €75K + €30K = €135K
- Range: €135K × 0.7 to €135K × 1.3 = €95K-€175K estimated

### Vendor Recommendations per Bucket

```typescript
async function findTopVendors(
  gaps: Gap[],
  limit: number = 3
): Promise<VendorRecommendation[]> {
  // Extract unique gap categories
  const gapCategories = [...new Set(gaps.map(g => g.category))]

  // Fetch vendors covering these categories
  const vendors = await this.prisma.vendor.findMany({
    where: {
      status: 'APPROVED',
      categories: { hasSome: gapCategories }
    }
  })

  // Score vendors by gaps covered
  const scoredVendors = vendors.map(vendor => {
    const coveredGaps = gaps.filter(gap =>
      vendor.categories.includes(gap.category)
    )

    return {
      vendor,
      gapsCovered: coveredGaps.length,
      coveredGapIds: coveredGaps.map(g => g.id)
    }
  })

  // Sort and return top N
  return scoredVendors
    .sort((a, b) => b.gapsCovered - a.gapsCovered)
    .slice(0, limit)
}
```

**Example:**
Immediate bucket has 5 gaps: [KYC, AML, Sanctions, Transaction Monitoring, Adverse Media]

- Vendor A covers: [KYC, AML, Sanctions] → 3 gaps covered
- Vendor B covers: [KYC, AML] → 2 gaps covered
- Vendor C covers: [Transaction Monitoring, Adverse Media] → 2 gaps covered
- Vendor D covers: [Sanctions] → 1 gap covered

Top 3: Vendor A (3), Vendor B (2), Vendor C (2)

### Redis Caching Implementation

```typescript
import { Redis } from 'ioredis'

export class StrategyMatrixService extends BaseService {
  private redis: Redis

  constructor(
    protected prisma: PrismaClient,
    protected logger: Logger,
    protected config: Config,
    redis: Redis
  ) {
    super(prisma, logger, config)
    this.redis = redis
  }

  async generateStrategyMatrix(assessmentId: string): Promise<StrategyMatrix> {
    // Check cache
    const cacheKey = `strategy_matrix:${assessmentId}`
    const cached = await this.redis.get(cacheKey)

    if (cached) {
      this.logger.info(`Strategy matrix cache hit for ${assessmentId}`)
      return JSON.parse(cached)
    }

    // Generate matrix
    const matrix = await this._generateMatrix(assessmentId)

    // Cache for 7 days
    const TTL = 7 * 24 * 60 * 60 // 7 days in seconds
    await this.redis.setex(cacheKey, TTL, JSON.stringify(matrix))

    this.logger.info(`Strategy matrix generated and cached for ${assessmentId}`)
    return matrix
  }

  async invalidateCache(assessmentId: string): Promise<void> {
    const cacheKey = `strategy_matrix:${assessmentId}`
    await this.redis.del(cacheKey)
    this.logger.info(`Strategy matrix cache invalidated for ${assessmentId}`)
  }

  private async _generateMatrix(assessmentId: string): Promise<StrategyMatrix> {
    // Core generation logic
  }
}
```

### Cache Invalidation Integration

When gaps are modified, strategy matrix cache must be invalidated:

```typescript
// In assessment.service.ts
async updateGaps(assessmentId: string, gaps: Gap[]): Promise<void> {
  // Update gaps in database
  await this.prisma.gap.updateMany({ /* ... */ })

  // Invalidate strategy matrix cache
  await this.strategyMatrixService.invalidateCache(assessmentId)
}
```

**Trigger points:**
- Assessment re-scored (new gap priorities)
- Gaps manually edited
- Assessment re-analyzed by AI

### Service Method Implementation

```typescript
async generateStrategyMatrix(assessmentId: string): Promise<StrategyMatrix> {
  // Fetch all gaps with priority
  const gaps = await this.prisma.gap.findMany({
    where: { assessmentId },
    orderBy: { priority: 'desc' }
  })

  // Partition gaps into buckets
  const immediate = gaps.filter(g => g.priority >= 8)
  const nearTerm = gaps.filter(g => g.priority >= 4 && g.priority < 8)
  const strategic = gaps.filter(g => g.priority < 4)

  // Build each bucket
  const [immediateBucket, nearTermBucket, strategicBucket] = await Promise.all([
    this._buildBucket(immediate, '0-6 months'),
    this._buildBucket(nearTerm, '6-18 months'),
    this._buildBucket(strategic, '18+ months')
  ])

  return {
    assessmentId,
    generatedAt: new Date(),
    immediate: immediateBucket,
    nearTerm: nearTermBucket,
    strategic: strategicBucket
  }
}

private async _buildBucket(gaps: Gap[], timeline: string): Promise<TimelineBucket> {
  const metrics = this.aggregateBucket(gaps)
  const topVendors = await this.findTopVendors(gaps, 3)

  return {
    timeline,
    gaps,
    gapCount: gaps.length,
    effortDistribution: metrics.effortDistribution,
    estimatedCostRange: metrics.estimatedCostRange,
    topVendors
  }
}
```

### Performance Considerations

**Target:** Generate matrix <500ms for assessment with 50 gaps

**Optimizations:**
1. **Batch Queries:** Fetch all gaps once, partition in memory
2. **Parallel Bucket Building:** Use Promise.all() for 3 buckets
3. **Vendor Query Optimization:** Single query for all gap categories
4. **Redis Caching:** Subsequent requests <10ms from cache

### Edge Cases

1. **No gaps:** Return empty buckets with zero counts
2. **All gaps in one bucket:** Other buckets empty (valid scenario)
3. **No vendors match gaps:** topVendors = [] (valid, shows gap in marketplace)
4. **Single gap per bucket:** Still calculate metrics (may show high cost for one item)

### Testing

**Unit Testing:**
Location: `backend/src/services/strategy-matrix.service.spec.ts`

Framework: Vitest 3

Test cases:
1. assignBucket: priority 10 → 'immediate'
2. assignBucket: priority 7 → 'nearTerm'
3. assignBucket: priority 3 → 'strategic'
4. aggregateBucket: counts gaps correctly
5. aggregateBucket: effort distribution correct
6. sumCostRanges: 3 gaps → "€95K-€175K"
7. sumCostRanges: no gaps → "€0"
8. sumCostRanges: all UNDER_10K → "€15K-€20K"
9. findTopVendors: returns vendors sorted by coverage
10. findTopVendors: limits to top 3
11. generateStrategyMatrix: distributes gaps correctly
12. generateStrategyMatrix: builds all 3 buckets
13. Cache: first call misses cache
14. Cache: second call hits cache
15. invalidateCache: clears cache successfully
16. Edge case: no gaps → empty buckets
17. Edge case: all gaps priority 10 → only immediate bucket filled

**Integration Testing:**
Location: `backend/tests/integration/strategy-matrix.spec.ts`

Test with real Prisma and Redis:
```typescript
it('should generate strategy matrix with correct distribution', async () => {
  // Setup: Create assessment with 15 gaps
  const assessment = await createTestAssessment()
  const gaps = await createTestGaps(assessment.id, [
    { priority: 10, category: 'KYC', effort: 'LARGE', costRange: 'RANGE_100K_250K' },
    { priority: 9, category: 'AML', effort: 'MEDIUM', costRange: 'RANGE_50K_100K' },
    { priority: 8, category: 'Sanctions', effort: 'SMALL', costRange: 'RANGE_10K_50K' },
    { priority: 6, category: 'Transaction Monitoring', effort: 'MEDIUM', costRange: 'RANGE_50K_100K' },
    { priority: 5, category: 'Adverse Media', effort: 'SMALL', costRange: 'UNDER_10K' },
    // ... 10 more gaps with varied priorities
  ])

  // Create vendors
  await createTestVendors([
    { categories: ['KYC', 'AML', 'Sanctions'] },
    { categories: ['Transaction Monitoring'] }
  ])

  // Execute
  const matrix = await service.generateStrategyMatrix(assessment.id)

  // Verify distribution
  expect(matrix.immediate.gapCount).toBe(3) // priorities 8-10
  expect(matrix.nearTerm.gapCount).toBeGreaterThan(0)
  expect(matrix.strategic.gapCount).toBeGreaterThan(0)

  // Verify vendor recommendations
  expect(matrix.immediate.topVendors.length).toBeGreaterThan(0)
  expect(matrix.immediate.topVendors[0].gapsCovered).toBeGreaterThan(0)

  // Verify caching
  const matrix2 = await service.generateStrategyMatrix(assessment.id)
  expect(matrix2).toEqual(matrix) // Same data from cache
})
```

**Coverage Target:** ≥80% for strategy-matrix.service.ts

## Change Log

| Date       | Version | Description                          | Author        |
|------------|---------|--------------------------------------|---------------|
| 2025-10-07 | 1.0     | Initial story created from PRD Epic 1 | SM (Winston)  |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None

### Completion Notes
- Added priorityScore (Int) field to Gap model for numeric 1-10 priority
- Created strategy-matrix.types.ts with all required interfaces
- Implemented StrategyMatrixService with bucket assignment, aggregation, and vendor recommendations
- Added Redis caching support (7-day TTL)
- Created comprehensive unit tests covering all scenarios
- All tests passing (7/7)

### File List
**New Files:**
- backend/src/types/strategy-matrix.types.ts
- backend/src/services/strategy-matrix.service.ts
- backend/src/services/strategy-matrix.service.spec.ts

**Modified Files:**
- backend/prisma/schema.prisma (added priorityScore to Gap model)

## QA Results

_To be populated by QA agent after implementation review_
