# Story 5.7: Update AssessmentService to Serve Mocked Content

## Status
Draft

## Story
**As a** Freemium user,
**I want** to receive mocked gap analysis and strategy matrix when viewing assessment results,
**so that** I see the structure but am prompted to upgrade for full details.

## Acceptance Criteria
1. `getAssessmentResultsUnfiltered()` method checks user subscription plan
2. For FREE tier users:
   - Call `FreemiumContentService.generateMockedGapAnalysis()` to replace real gaps
   - Mark `aiStrategyMatrix.isRestricted = true`
   - Replace strategy matrix content with '[UNLOCK PREMIUM TO SEE]'
   - Return assessment with `isRestricted: true` flag
   - Include `restrictionReason: 'Upgrade to Premium to see full analysis'`
3. For PREMIUM/ENTERPRISE users:
   - Return real gaps, risks, and strategy matrix from database
   - `isRestricted: false`
4. Compliance score (riskScore) is ALWAYS visible regardless of tier
5. Vendor AI matching is hidden for FREE tier (handled separately)

## Tasks / Subtasks

- [ ] **Task 1: Import FreemiumContentService** (AC: 1)
  - [ ] Open `backend/src/services/assessment.service.ts`
  - [ ] Add import at top of file:
    ```typescript
    import { FreemiumContentService } from './freemium-content.service';
    ```

- [ ] **Task 2: Locate getAssessmentResultsUnfiltered Method** (AC: 1)
  - [ ] Find `getAssessmentResultsUnfiltered()` method (line 298)
  - [ ] Review current implementation (fetches assessment with gaps/risks)
  - [ ] Identify insertion point: after permissions check, before return statement

- [ ] **Task 3: Add Subscription Plan Query** (AC: 1)
  - [ ] After permissions check (line 372), query user subscription:
    ```typescript
    // Check subscription plan to determine if content should be mocked
    const subscription = await this.prisma.subscription.findUnique({
      where: { userId: assessment.userId },
      select: { plan: true },
    });

    const plan = subscription?.plan || 'FREE';
    ```

- [ ] **Task 4: Implement Mocked Content Logic for FREE Tier** (AC: 2)
  - [ ] Add conditional logic:
    ```typescript
    if (plan === 'FREE') {
      const freemiumService = new FreemiumContentService();

      // Replace gaps with mocked gaps
      const mockedGaps = await freemiumService.generateMockedGapAnalysis(assessment.id);
      assessment.gaps = mockedGaps as any; // Cast to match type

      // Replace strategy matrix with mocked version
      if (assessment.aiStrategyMatrix) {
        assessment.aiStrategyMatrix = {
          ...assessment.aiStrategyMatrix,
          isRestricted: true,
          matrix: '[UNLOCK PREMIUM TO SEE]',
          summary: 'Upgrade to Premium to see personalized strategy recommendations',
        };
      }

      // Mark assessment as restricted
      (assessment as any).isRestricted = true;
      (assessment as any).restrictionReason = 'Upgrade to Premium to see full analysis';

      // Hide vendor matches (set to empty array)
      (assessment as any).vendorMatches = [];
    } else {
      // Premium/Enterprise users get full content
      (assessment as any).isRestricted = false;
    }
    ```

- [ ] **Task 5: Preserve riskScore Visibility** (AC: 4)
  - [ ] Ensure riskScore field is NOT modified for FREE users
  - [ ] Verify riskScore is included in return payload regardless of plan
  - [ ] Add comment:
    ```typescript
    // Note: riskScore is ALWAYS visible regardless of tier
    ```

- [ ] **Task 6: Update TypeScript Interface** (AC: 2, 3)
  - [ ] Add optional fields to `AssessmentWithDetails` interface (line 71):
    ```typescript
    export interface AssessmentWithDetails extends DatabaseAssessment {
      organization: { ... };
      user: { ... };
      template: { ... };
      gaps: Array<{ ... }>;
      risks: Array<{ ... }>;

      // NEW: Freemium restriction fields
      isRestricted?: boolean;
      restrictionReason?: string;
      vendorMatches?: any[];
    }
    ```

- [ ] **Task 7: Write Unit Tests** (AC: 1-5)
  - [ ] Test file: `backend/tests/unit/assessment-mocked-content.test.ts`
  - [ ] Test FREE user receives mocked gaps (not real gaps)
  - [ ] Test FREE user gaps have isRestricted: true
  - [ ] Test FREE user strategy matrix is blurred
  - [ ] Test FREE user assessment has isRestricted: true flag
  - [ ] Test FREE user riskScore is still visible
  - [ ] Test PREMIUM user receives real gaps/risks
  - [ ] Test PREMIUM user has isRestricted: false
  - [ ] Run tests: `npm test`

- [ ] **Task 8: Ensure No AI Analysis for FREE During Completion** (AC: 2)
  - [ ] Review `completeAssessment()` method (not modifying in this story)
  - [ ] Add TODO comment:
    ```typescript
    // TODO (Story 5.8): Skip real AI analysis for FREE users during completion
    // For now, AI analysis still runs but results are replaced with mocked content
    ```
  - [ ] Document that optimization to skip AI analysis will come in Story 5.8

## Dev Notes

### Current Method Location
**File:** `backend/src/services/assessment.service.ts`
**Method:** `getAssessmentResultsUnfiltered()` (line 298-380)

**Current Behavior:**
1. Fetches assessment with all relations (organization, user, template, gaps, risks)
2. Checks permissions (admin, owner, or organization member)
3. Returns full unfiltered results

**New Behavior:**
1. Same fetch and permissions check
2. **NEW:** Query user subscription plan
3. **NEW:** If FREE, replace gaps and strategy matrix with mocked content
4. **NEW:** Add isRestricted flag
5. Return results (mocked or real based on plan)

[Source: backend/src/services/assessment.service.ts:298]

---

### Mocked Content Generation

**FreemiumContentService Integration:**
```typescript
const freemiumService = new FreemiumContentService();
const mockedGaps = await freemiumService.generateMockedGapAnalysis(assessment.id);
```

**Why Instantiate in Method:**
- FreemiumContentService is stateless (extends BaseService)
- No need for class-level instance
- Can be instantiated on-demand when FREE user detected
- Keeps service dependencies minimal

**Mocked Gap Structure:**
```typescript
{
  id: 'mock-gap-assessment-1',
  assessmentId: assessment.id,
  category: 'HIDDEN_ANALYSIS',
  title: 'Risk Area 1',
  description: '[UNLOCK PREMIUM TO SEE DETAILS]',
  severity: 'HIGH',
  priority: 'MEDIUM',
  priorityScore: null,
  estimatedCost: null,
  estimatedEffort: null,
  suggestedVendors: [],
  isRestricted: true,
}
```

[Source: Story 5.4 - FreemiumContentService]

---

### Strategy Matrix Blurring

**Current Structure:**
```typescript
assessment.aiStrategyMatrix = {
  matrix: [...], // Array of strategy items
  summary: '...',
  createdAt: Date
}
```

**Mocked Structure:**
```typescript
assessment.aiStrategyMatrix = {
  isRestricted: true,
  matrix: '[UNLOCK PREMIUM TO SEE]',
  summary: 'Upgrade to Premium to see personalized strategy recommendations',
}
```

**Frontend Rendering:**
- Frontend checks `aiStrategyMatrix.isRestricted`
- If true, displays blur overlay with upgrade CTA
- If false, renders full strategy matrix

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Frontend Integration]

---

### Subscription Plan Query Pattern

**Query Location:** After permissions check, before return
**Query Pattern:**
```typescript
const subscription = await this.prisma.subscription.findUnique({
  where: { userId: assessment.userId },
  select: { plan: true },
});

const plan = subscription?.plan || 'FREE';
```

**Why Default to FREE:**
- New users might not have subscription record yet
- Safer to default to most restrictive tier
- Prevents accidental exposure of paid content

**Optimization:**
- Could include subscription in initial assessment query
- Current approach keeps changes minimal and clear
- Performance impact negligible (indexed userId lookup)

[Source: Story 5.6 - Subscription Plan Checking]

---

### isRestricted Flag Pattern

**Purpose:**
- Signals to frontend that content is mocked/blurred
- Triggers upgrade prompts and CTAs
- Consistent pattern across all restricted content

**Usage in Response:**
```typescript
{
  success: true,
  data: {
    id: 'assessment-123',
    riskScore: 67,           // ALWAYS visible
    gaps: [...mockedGaps],   // Mocked for FREE
    aiStrategyMatrix: { isRestricted: true, ... },
    isRestricted: true,      // Top-level flag
    restrictionReason: 'Upgrade to Premium to see full analysis',
    vendorMatches: []        // Hidden for FREE
  }
}
```

**Frontend Detection:**
```typescript
if (assessment.isRestricted) {
  // Show blur overlay
  // Display upgrade CTA
  // Hide detailed analysis
}
```

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Response Format]

---

### Performance Considerations

**Additional Query Overhead:**
- 1 extra query: subscription plan lookup
- Query is fast (indexed userId)
- Only happens when viewing assessment results
- Acceptable performance impact

**Mocked Content Generation:**
- In-memory generation (no API calls)
- Fast execution (<10ms)
- No database writes
- Significantly cheaper than real AI analysis

**Real AI Analysis Still Runs:**
- Story 5.7 does NOT prevent AI analysis during assessment completion
- Optimization to skip AI analysis for FREE users will come in Story 5.8
- For now: AI analysis runs, but results replaced with mocked content on retrieval
- This is acceptable because FREE users limited to 2 assessments (low cost impact)

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Cost Optimization]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/unit/assessment-mocked-content.test.ts`

**Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { AssessmentService } from '../src/services/assessment.service';
import { PrismaClient, SubscriptionPlan } from '../src/generated/prisma';

describe('Assessment Mocked Content - FREE Tier', () => {
  let service: AssessmentService;
  let prisma: PrismaClient;
  let freeUserId: string;
  let premiumUserId: string;
  let freeAssessmentId: string;
  let premiumAssessmentId: string;

  beforeAll(async () => {
    service = new AssessmentService();
    prisma = new PrismaClient();

    // Create FREE user with assessment
    const freeUser = await prisma.user.create({
      data: {
        email: 'free@example.com',
        firstName: 'Free',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.FREE,
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(),
          },
        },
      },
    });
    freeUserId = freeUser.id;

    // Create assessment for FREE user
    const freeAssessment = await prisma.assessment.create({
      data: {
        userId: freeUserId,
        templateId: 'test-template',
        organizationId: 'test-org',
        status: 'COMPLETED',
        riskScore: 67,
        gaps: {
          create: [
            {
              category: 'REAL_GAP',
              title: 'Real Gap 1',
              description: 'This is a real gap that should be hidden',
              severity: 'HIGH',
              priority: 'HIGH',
            },
          ],
        },
      },
    });
    freeAssessmentId = freeAssessment.id;

    // Create PREMIUM user with assessment
    const premiumUser = await prisma.user.create({
      data: {
        email: 'premium@example.com',
        firstName: 'Premium',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.PREMIUM,
            creditsBalance: 100,
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(),
          },
        },
      },
    });
    premiumUserId = premiumUser.id;

    // Create assessment for PREMIUM user
    const premiumAssessment = await prisma.assessment.create({
      data: {
        userId: premiumUserId,
        templateId: 'test-template',
        organizationId: 'test-org',
        status: 'COMPLETED',
        riskScore: 72,
        gaps: {
          create: [
            {
              category: 'REAL_GAP',
              title: 'Real Premium Gap',
              description: 'Real gap for premium user',
              severity: 'MEDIUM',
              priority: 'MEDIUM',
            },
          ],
        },
      },
    });
    premiumAssessmentId = premiumAssessment.id;
  });

  afterAll(async () => {
    await prisma.assessment.delete({ where: { id: freeAssessmentId } });
    await prisma.assessment.delete({ where: { id: premiumAssessmentId } });
    await prisma.user.delete({ where: { id: freeUserId } });
    await prisma.user.delete({ where: { id: premiumUserId } });
    await prisma.$disconnect();
  });

  it('should return mocked gaps for FREE user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      freeAssessmentId,
      { userId: freeUserId, userRole: 'USER' }
    );

    expect(response.success).toBe(true);
    expect(response.data.gaps.length).toBeGreaterThan(0);

    // Check gaps are mocked
    response.data.gaps.forEach((gap) => {
      expect(gap.description).toContain('[UNLOCK PREMIUM TO SEE DETAILS]');
      expect(gap.isRestricted).toBe(true);
    });
  });

  it('should mark assessment as restricted for FREE user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      freeAssessmentId,
      { userId: freeUserId, userRole: 'USER' }
    );

    expect(response.data.isRestricted).toBe(true);
    expect(response.data.restrictionReason).toContain('Upgrade to Premium');
  });

  it('should preserve riskScore for FREE user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      freeAssessmentId,
      { userId: freeUserId, userRole: 'USER' }
    );

    expect(response.data.riskScore).toBe(67); // Original score preserved
  });

  it('should blur strategy matrix for FREE user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      freeAssessmentId,
      { userId: freeUserId, userRole: 'USER' }
    );

    if (response.data.aiStrategyMatrix) {
      expect(response.data.aiStrategyMatrix.isRestricted).toBe(true);
      expect(response.data.aiStrategyMatrix.matrix).toBe('[UNLOCK PREMIUM TO SEE]');
    }
  });

  it('should hide vendor matches for FREE user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      freeAssessmentId,
      { userId: freeUserId, userRole: 'USER' }
    );

    expect(response.data.vendorMatches).toEqual([]);
  });

  it('should return real gaps for PREMIUM user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      premiumAssessmentId,
      { userId: premiumUserId, userRole: 'USER' }
    );

    expect(response.success).toBe(true);
    expect(response.data.gaps.length).toBeGreaterThan(0);

    // Check gaps are real (not mocked)
    response.data.gaps.forEach((gap) => {
      expect(gap.description).not.toContain('[UNLOCK PREMIUM TO SEE DETAILS]');
      expect(gap.isRestricted).toBeUndefined();
    });
  });

  it('should mark assessment as unrestricted for PREMIUM user', async () => {
    const response = await service.getAssessmentResultsUnfiltered(
      premiumAssessmentId,
      { userId: premiumUserId, userRole: 'USER' }
    );

    expect(response.data.isRestricted).toBe(false);
  });
});
```

[Source: architecture.md#Testing Strategy]

---

### File Locations
- **Service:** `backend/src/services/assessment.service.ts`
- **Method:** `getAssessmentResultsUnfiltered()` (line 298)
- **Dependency:** `backend/src/services/freemium-content.service.ts` (Story 5.4)
- **Test:** `backend/tests/unit/assessment-mocked-content.test.ts`

---

### Dependencies
**Depends On:**
- Story 5.4: FreemiumContentService must be implemented
- Existing: Subscription model with plan field

**Depended On By:**
- Story 5.8: Skip AI analysis during completion for FREE users (future optimization)
- Story 8.4: Blurred Content UI with Upgrade CTA (frontend)

---

### Future Optimizations (Not This Story)

**Story 5.8 Will Add:**
- Skip real AI analysis during assessment completion for FREE users
- Only generate mocked content from the start
- Save OpenAI API costs completely

**Current Behavior:**
1. FREE user completes assessment
2. Real AI analysis runs (costs â‚¬0.50-1.00)
3. Results stored in database
4. When viewing results, real content replaced with mocked content

**Future Behavior (Story 5.8):**
1. FREE user completes assessment
2. AI analysis skipped (no cost)
3. Mocked content generated and stored
4. When viewing results, mocked content returned

**Why Not Now:**
- Story 5.7 focuses on serving mocked content
- Story 5.8 will handle generation optimization
- Separation of concerns keeps changes manageable

[Source: Epic 5 - Story Dependencies]

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 5 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
_TBD_

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
