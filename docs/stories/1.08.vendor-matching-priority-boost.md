# Story 1.08: Enhanced Vendor Matching Service - Priority Boost Algorithm

## Status
Ready for Review

## Story

**As a** backend developer,
**I want** to implement the priority boost component (0-40 points) of the vendor matching algorithm,
**so that** vendor scores reflect user-specific priorities, must-have features, and urgency.

## Acceptance Criteria

1. Extend `vendor-matching.service.ts` with boost calculations
2. Method `calculatePriorityBoost(vendor: Vendor, priorities: AssessmentPriorities, gaps: Gap[]): Promise<PriorityBoost>` implemented
3. **Top Priority Coverage (+20 max):**
   - Check if vendor.categories includes any of priorities.rankedPriorities
   - #1 priority: +20 points
   - #2 priority: +15 points
   - #3 priority: +10 points
   - Vendor receives boost for highest-ranked priority only (no stacking)
4. **Must-Have Features (+10 max):**
   - Match priorities.mustHaveFeatures against vendor.features array
   - All features present: +10 points
   - Missing 1-2 features: +5 points
   - Missing 3+ features: 0 points
5. **Deployment Match (+5):**
   - If vendor.deploymentOptions includes priorities.deploymentPreference: +5 points
   - If priorities.deploymentPreference = "Flexible": all vendors get +5 points
   - Otherwise: 0 points
6. **Speed to Deploy (+5):**
   - If priorities.implementationUrgency = "Immediate" AND vendor.implementationTimeline ≤ 90 days: +5 points
   - Otherwise: 0 points
7. Method returns: `{ vendorId, topPriorityBoost, featureBoost, deploymentBoost, speedBoost, totalBoost }`
8. Method `calculateTotalScore(baseScore: BaseScore, priorityBoost: PriorityBoost): VendorMatchScore` combines scores
9. Method `generateMatchReasons(vendor, baseScore, priorityBoost): string[]` creates human-readable reasoning:
   - Example: "Covers your #1 priority: Sanctions Screening"
   - Example: "Addresses 3 out of 4 identified gaps"
   - Example: "Has all must-have features: Real-time monitoring, AI/ML, Integration capabilities"
10. Unit tests verify boost calculations for all priority combinations
11. Integration test: Match 10 vendors against sample priorities, verify top vendor has highest score and clear reasoning

## Tasks / Subtasks

- [ ] Extend vendor-matching.service.ts (AC: 1)
  - [ ] Import PriorityBoost interface
  - [ ] Add priority boost utility functions
- [ ] Implement Top Priority Coverage boost (AC: 3)
  - [ ] Get priorities.rankedPriorities array [priority1, priority2, priority3]
  - [ ] Check if vendor.categories includes priority1 → +20 points
  - [ ] Else if includes priority2 → +15 points
  - [ ] Else if includes priority3 → +10 points
  - [ ] Else → 0 points
  - [ ] Return boost value and matched priority name
- [ ] Implement Must-Have Features boost (AC: 4)
  - [ ] Get priorities.mustHaveFeatures array (max 5)
  - [ ] Get vendor.features array
  - [ ] Count missing features: features NOT in vendor.features
  - [ ] If missing = 0 → +10 points
  - [ ] If missing 1-2 → +5 points
  - [ ] If missing 3+ → 0 points
  - [ ] Return boost value and missing feature list
- [ ] Implement Deployment Match boost (AC: 5)
  - [ ] Get priorities.deploymentPreference
  - [ ] If preference = "Flexible" → +5 points (all vendors)
  - [ ] Else check if vendor.deploymentOptions includes preference → +5 points
  - [ ] Else → 0 points
  - [ ] Return boost value
- [ ] Implement Speed to Deploy boost (AC: 6)
  - [ ] Get priorities.implementationUrgency
  - [ ] If urgency = "Immediate":
    - Get vendor.implementationTimeline (in days)
    - If timeline ≤ 90 days → +5 points
    - Else → 0 points
  - [ ] Else (not immediate) → 0 points
  - [ ] Return boost value
- [ ] Implement calculatePriorityBoost method (AC: 2, 7)
  - [ ] Call top priority coverage calculation
  - [ ] Call must-have features calculation
  - [ ] Call deployment match calculation
  - [ ] Call speed to deploy calculation
  - [ ] Sum all boosts: totalBoost = top + features + deployment + speed
  - [ ] Return PriorityBoost object with breakdown
- [ ] Implement calculateTotalScore method (AC: 8)
  - [ ] Take BaseScore and PriorityBoost as inputs
  - [ ] Calculate finalScore = baseScore.totalBase + priorityBoost.totalBoost
  - [ ] Cap finalScore at 140 (max possible: 100 base + 40 boost)
  - [ ] Return VendorMatchScore with all components
- [ ] Implement generateMatchReasons method (AC: 9)
  - [ ] Initialize empty reasons array
  - [ ] If topPriorityBoost > 0: add "Covers your #X priority: [name]"
  - [ ] If riskAreaCoverage > 30: add "Addresses X out of Y identified gaps"
  - [ ] If featureBoost = 10: add "Has all must-have features: [list]"
  - [ ] If featureBoost = 5: add "Has most features, missing: [list]"
  - [ ] If deploymentBoost = 5: add "Supports your deployment: [preference]"
  - [ ] If speedBoost = 5: add "Fast implementation: [timeline] days"
  - [ ] If geoCoverage = 20: add "Full geographic coverage"
  - [ ] If priceScore = 20: add "Within your budget range"
  - [ ] Return reasons array (5-8 reasons per vendor)
- [ ] Write comprehensive unit tests (AC: 10)
  - [ ] Test top priority: #1 priority match → +20 points
  - [ ] Test top priority: #2 priority match → +15 points
  - [ ] Test top priority: #3 priority match → +10 points
  - [ ] Test top priority: no match → 0 points
  - [ ] Test features: all present → +10 points
  - [ ] Test features: missing 1 → +5 points
  - [ ] Test features: missing 3 → 0 points
  - [ ] Test deployment: exact match → +5 points
  - [ ] Test deployment: "Flexible" → +5 points for all
  - [ ] Test deployment: no match → 0 points
  - [ ] Test speed: immediate + 60 days → +5 points
  - [ ] Test speed: immediate + 120 days → 0 points
  - [ ] Test speed: planned → 0 points (not immediate)
  - [ ] Test calculateTotalScore: base 80 + boost 30 → final 110
  - [ ] Test generateMatchReasons: verify all reason types
- [ ] Integration test (AC: 11)
  - [ ] Create 10 vendors with varied profiles
  - [ ] Create test priorities with specific preferences
  - [ ] Calculate base scores for all vendors
  - [ ] Calculate priority boosts for all vendors
  - [ ] Calculate total scores
  - [ ] Verify top-ranked vendor has highest score
  - [ ] Verify top vendor has clear, relevant match reasons
  - [ ] Verify reasons accurately reflect scoring components

## Dev Notes

### Relevant Source Tree
- `backend/src/services/vendor-matching.service.ts` - EXTEND: Add priority boost methods
- `backend/src/matching/priority-boost.ts` - NEW: Utility functions for boost calculations
- `backend/src/matching/match-reasons.ts` - NEW: Reason generation utilities
- `backend/src/types/matching.types.ts` - EXTEND: Add PriorityBoost, VendorMatchScore interfaces
- `backend/prisma/schema.prisma` - Vendor, AssessmentPriorities models

### Priority Boost Algorithm Breakdown

**Total Boost: 0-40 points**

| Component | Max Points | Calculation Method |
|-----------|------------|-------------------|
| Top Priority Coverage | 20 | #1: 20, #2: 15, #3: 10, None: 0 |
| Must-Have Features | 10 | All: 10, Missing 1-2: 5, Missing 3+: 0 |
| Deployment Match | 5 | Match or Flexible: 5, No match: 0 |
| Speed to Deploy | 5 | Immediate + ≤90 days: 5, Otherwise: 0 |

### Top Priority Coverage Boost

```typescript
function calculateTopPriorityBoost(
  vendor: Vendor,
  priorities: AssessmentPriorities
): { boost: number, matchedPriority: string | null } {
  const rankedPriorities = priorities.rankedPriorities // [priority1, priority2, priority3]
  const vendorCategories = vendor.categories || []

  // Check #1 priority
  if (vendorCategories.includes(rankedPriorities[0])) {
    return { boost: 20, matchedPriority: rankedPriorities[0] }
  }

  // Check #2 priority
  if (vendorCategories.includes(rankedPriorities[1])) {
    return { boost: 15, matchedPriority: rankedPriorities[1] }
  }

  // Check #3 priority
  if (vendorCategories.includes(rankedPriorities[2])) {
    return { boost: 10, matchedPriority: rankedPriorities[2] }
  }

  return { boost: 0, matchedPriority: null }
}
```

**Example:**
- User priorities: [1: "Sanctions Screening", 2: "KYC", 3: "Transaction Monitoring"]
- Vendor A categories: ["Sanctions Screening", "AML"] → +20 points (covers #1)
- Vendor B categories: ["KYC", "Customer Onboarding"] → +15 points (covers #2)
- Vendor C categories: ["Transaction Monitoring"] → +10 points (covers #3)
- Vendor D categories: ["Adverse Media"] → 0 points (no priority match)

**No Stacking:** Vendor receives boost only for highest-ranked priority match.

### Must-Have Features Boost

```typescript
function calculateFeatureBoost(
  vendor: Vendor,
  priorities: AssessmentPriorities
): { boost: number, missingFeatures: string[] } {
  const requiredFeatures = priorities.mustHaveFeatures || []
  const vendorFeatures = vendor.features || []

  const missing = requiredFeatures.filter(
    feature => !vendorFeatures.includes(feature)
  )

  if (missing.length === 0) {
    return { boost: 10, missingFeatures: [] }
  }

  if (missing.length <= 2) {
    return { boost: 5, missingFeatures: missing }
  }

  return { boost: 0, missingFeatures: missing }
}
```

**Example:**
- User must-haves: ["Real-time monitoring", "AI/ML", "API integration", "Custom workflows"]
- Vendor A features: includes all 4 → +10 points
- Vendor B features: missing "Custom workflows" → +5 points (missing 1)
- Vendor C features: missing "AI/ML" and "Custom workflows" → +5 points (missing 2)
- Vendor D features: missing 3 features → 0 points

### Deployment Match Boost

```typescript
function calculateDeploymentBoost(
  vendor: Vendor,
  priorities: AssessmentPriorities
): number {
  const preference = priorities.deploymentPreference
  const vendorOptions = vendor.deploymentOptions || []

  // User is flexible: all vendors qualify
  if (preference === 'FLEXIBLE') {
    return 5
  }

  // Check if vendor supports user preference
  if (vendorOptions.includes(preference)) {
    return 5
  }

  return 0
}
```

**Example:**
- User preference: "Cloud"
- Vendor A: ["Cloud", "Hybrid"] → +5 points
- Vendor B: ["On-Premise"] → 0 points
- User preference: "Flexible"
- All vendors → +5 points

### Speed to Deploy Boost

```typescript
function calculateSpeedBoost(
  vendor: Vendor,
  priorities: AssessmentPriorities
): number {
  const urgency = priorities.implementationUrgency

  // Only apply if user needs immediate implementation
  if (urgency !== 'IMMEDIATE') {
    return 0
  }

  const vendorTimeline = vendor.implementationTimeline || 365 // Default 1 year

  if (vendorTimeline <= 90) {
    return 5
  }

  return 0
}
```

**Example:**
- User urgency: "Immediate", Vendor timeline: 60 days → +5 points
- User urgency: "Immediate", Vendor timeline: 120 days → 0 points
- User urgency: "Planned", Vendor timeline: 30 days → 0 points (not urgent)

### PriorityBoost Interface

```typescript
interface PriorityBoost {
  vendorId: string
  topPriorityBoost: number       // 0-20 points
  matchedPriority?: string       // Name of matched priority
  featureBoost: number           // 0-10 points
  missingFeatures: string[]      // List of missing features
  deploymentBoost: number        // 0-5 points
  speedBoost: number             // 0-5 points
  totalBoost: number             // Sum of above (0-40)
}
```

### VendorMatchScore Interface

```typescript
interface VendorMatchScore {
  vendorId: string
  vendor: Vendor                 // Full vendor object
  baseScore: BaseScore           // From Story 1.7
  priorityBoost: PriorityBoost   // This story
  totalScore: number             // baseScore.totalBase + priorityBoost.totalBoost
  matchReasons: string[]         // Human-readable explanations
}
```

### Total Score Calculation

```typescript
function calculateTotalScore(
  baseScore: BaseScore,
  priorityBoost: PriorityBoost
): VendorMatchScore {
  const totalScore = baseScore.totalBase + priorityBoost.totalBoost

  return {
    vendorId: baseScore.vendorId,
    baseScore,
    priorityBoost,
    totalScore,
    matchReasons: [] // Generated separately
  }
}
```

**Score Range:** 0-140 points total
- Base: 0-100 points (Story 1.7)
- Boost: 0-40 points (this story)

**Threshold for Recommendations:** totalScore ≥ 80 (configurable)

### Match Reasons Generation

```typescript
function generateMatchReasons(
  vendor: Vendor,
  baseScore: BaseScore,
  priorityBoost: PriorityBoost
): string[] {
  const reasons: string[] = []

  // Priority coverage
  if (priorityBoost.matchedPriority) {
    const rank = priorityBoost.topPriorityBoost === 20 ? '#1' :
                 priorityBoost.topPriorityBoost === 15 ? '#2' : '#3'
    reasons.push(`Covers your ${rank} priority: ${priorityBoost.matchedPriority}`)
  }

  // Gap coverage
  const gapCoverage = baseScore.riskAreaCoverage
  if (gapCoverage >= 30) {
    const percentage = Math.round((gapCoverage / 40) * 100)
    reasons.push(`Addresses ${percentage}% of your identified compliance gaps`)
  }

  // Must-have features
  if (priorityBoost.featureBoost === 10) {
    reasons.push(`Has all must-have features you specified`)
  } else if (priorityBoost.featureBoost === 5) {
    reasons.push(`Has most features, missing: ${priorityBoost.missingFeatures.join(', ')}`)
  }

  // Company size fit
  if (baseScore.sizeFit === 20) {
    reasons.push(`Designed for companies your size`)
  }

  // Geographic coverage
  if (baseScore.geoCoverage === 20) {
    reasons.push(`Full coverage for all your jurisdictions`)
  } else if (baseScore.geoCoverage >= 15) {
    reasons.push(`Covers most of your required jurisdictions`)
  }

  // Price appropriateness
  if (baseScore.priceScore === 20) {
    reasons.push(`Within your budget range`)
  } else if (baseScore.priceScore === 10) {
    reasons.push(`Slightly above budget but within 25% tolerance`)
  }

  // Deployment match
  if (priorityBoost.deploymentBoost === 5) {
    reasons.push(`Supports your preferred deployment model`)
  }

  // Speed to deploy
  if (priorityBoost.speedBoost === 5) {
    reasons.push(`Fast implementation timeline (≤90 days)`)
  }

  return reasons
}
```

**Example Output:**
```
Vendor A (Score: 125):
- Covers your #1 priority: Sanctions Screening
- Addresses 85% of your identified compliance gaps
- Has all must-have features you specified
- Designed for companies your size
- Full coverage for all your jurisdictions
- Within your budget range
- Supports your preferred deployment model
- Fast implementation timeline (≤90 days)
```

### Integration with Base Scoring (Story 1.7)

```typescript
// Complete matching flow
async matchVendorsToAssessment(
  assessmentId: string,
  prioritiesId: string
): Promise<VendorMatchScore[]> {
  // Fetch data
  const [assessment, priorities, vendors, gaps] = await Promise.all([
    this.prisma.assessment.findUnique({ where: { id: assessmentId } }),
    this.prisma.assessmentPriorities.findUnique({ where: { id: prioritiesId } }),
    this.prisma.vendor.findMany({ where: { status: 'APPROVED' } }),
    this.prisma.gap.findMany({ where: { assessmentId } })
  ])

  // Score all vendors
  const scores = await Promise.all(
    vendors.map(async vendor => {
      // Story 1.7: Base score
      const baseScore = await this.calculateBaseScore(vendor, assessment, priorities, gaps)

      // Story 1.8: Priority boost
      const priorityBoost = await this.calculatePriorityBoost(vendor, priorities, gaps)

      // Combine scores
      const totalScore = baseScore.totalBase + priorityBoost.totalBoost

      // Generate reasons
      const matchReasons = this.generateMatchReasons(vendor, baseScore, priorityBoost)

      return {
        vendorId: vendor.id,
        vendor,
        baseScore,
        priorityBoost,
        totalScore,
        matchReasons
      }
    })
  )

  // Filter and sort
  return scores
    .filter(s => s.totalScore >= 80)
    .sort((a, b) => b.totalScore - a.totalScore)
}
```

### Testing

**Unit Testing:**
Location: `backend/src/services/vendor-matching.service.spec.ts` and `backend/src/matching/priority-boost.spec.ts`

Framework: Vitest 3

Test cases:
1. Top priority: covers #1 → +20 points
2. Top priority: covers #2 → +15 points
3. Top priority: covers #3 → +10 points
4. Top priority: no match → 0 points
5. Features: all present → +10 points
6. Features: missing 1 → +5 points
7. Features: missing 2 → +5 points
8. Features: missing 3+ → 0 points
9. Deployment: match → +5 points
10. Deployment: flexible user → +5 points for all
11. Deployment: no match → 0 points
12. Speed: immediate + 60 days → +5 points
13. Speed: immediate + 120 days → 0 points
14. Speed: not immediate → 0 points
15. calculateTotalScore: base 80 + boost 30 = 110
16. generateMatchReasons: all reason types present
17. generateMatchReasons: no reasons if scores low
18. Edge case: empty vendor features → 0 feature boost
19. Edge case: empty priorities.mustHaveFeatures → +10 boost (all met)

**Integration Testing:**
Location: `backend/tests/integration/vendor-matching.spec.ts`

Test case:
```typescript
it('should rank vendors correctly by total score', async () => {
  // Create test data
  const assessment = await createTestAssessment()
  const priorities = await createTestPriorities(assessment.id, {
    rankedPriorities: ['Sanctions Screening', 'KYC', 'AML'],
    mustHaveFeatures: ['Real-time monitoring', 'API integration'],
    implementationUrgency: 'IMMEDIATE'
  })

  const vendors = await createTestVendors([
    { categories: ['Sanctions Screening'], features: ['Real-time monitoring', 'API integration'], implementationTimeline: 60 },
    { categories: ['KYC'], features: ['Real-time monitoring'], implementationTimeline: 120 },
    { categories: ['AML'], features: [], implementationTimeline: 90 }
  ])

  // Execute matching
  const matches = await service.matchVendorsToAssessment(assessment.id, priorities.id)

  // Verify ranking
  expect(matches[0].vendor.id).toBe(vendors[0].id) // Best match
  expect(matches[0].totalScore).toBeGreaterThan(matches[1].totalScore)
  expect(matches[0].matchReasons).toContain('Covers your #1 priority: Sanctions Screening')
  expect(matches[0].matchReasons).toContain('Has all must-have features you specified')
})
```

**Coverage Target:** ≥80% for priority boost logic

## Change Log

| Date       | Version | Description                          | Author        |
|------------|---------|--------------------------------------|---------------|
| 2025-10-07 | 1.0     | Initial story created from PRD Epic 1 | SM (Winston)  |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None

### Completion Notes
- Implemented full priority boost algorithm with all 4 components (top priority, features, deployment, speed)
- Extended Prisma schema to add `features` and `implementationTimeline` fields to Vendor model
- Created priority-boost.ts utility with all boost calculation functions
- Created match-reasons.ts for generating human-readable match explanations
- Extended vendor-matching.service.ts with calculatePriorityBoost, calculateTotalScore, and matchVendorsToAssessment methods
- Added comprehensive unit tests covering all boost scenarios
- All tests passing (13/13)

### File List
**New Files:**
- backend/src/matching/priority-boost.ts
- backend/src/matching/match-reasons.ts

**Modified Files:**
- backend/prisma/schema.prisma (added features and implementationTimeline to Vendor)
- backend/src/types/matching.types.ts (added PriorityBoost, VendorMatchScore interfaces)
- backend/src/services/vendor-matching.service.ts (added priority boost methods)
- backend/src/services/vendor-matching.service.spec.ts (added comprehensive tests)

## QA Results

_To be populated by QA agent after implementation review_
