# Story 6.5: Implement Invoice Generation Helper

## Status
Draft

## Story
**As a** billing system,
**I want** to generate invoice records for subscriptions,
**so that** we have a financial audit trail.

## Acceptance Criteria
1. Private method `generateInvoice(subscription)` created in `BillingService`
2. Method creates `Invoice` record with:
   - `subscriptionId`: from parameter
   - `stripeInvoiceId`: `draft-{timestamp}` (real Stripe ID in production)
   - `amount`: Based on billingCycle (ANNUAL: 6469.20, MONTHLY: 599.00)
   - `currency`: 'EUR'
   - `status`: InvoiceStatus.DRAFT
   - `periodStart`: subscription.currentPeriodStart
   - `periodEnd`: subscription.currentPeriodEnd
   - `dueDate`: currentPeriodEnd + 14 days
3. Method returns created Invoice record
4. Amount stored in euros (not cents) for Invoice model
5. Method does NOT process payment (that's Stripe's job)

## Tasks / Subtasks

- [ ] **Task 1: Reference Story 6.4 Implementation** (AC: 1)
  - [ ] Note: `generateInvoice()` method already implemented in Story 6.4, Task 3
  - [ ] Location: `backend/src/services/billing.service.ts`
  - [ ] This story provides additional documentation and testing guidance

- [ ] **Task 2: Verify Invoice Field Mappings** (AC: 2, 4)
  - [ ] Review Invoice model in `backend/prisma/schema.prisma` (line 816)
  - [ ] Verify all required fields are populated:
    ```prisma
    model Invoice {
      id                String @id @default(cuid())
      subscriptionId    String
      stripeInvoiceId   String @unique
      amount            Float           // In euros (not cents!)
      currency          String @default("EUR")
      status            InvoiceStatus @default(DRAFT)
      periodStart       DateTime
      periodEnd         DateTime
      dueDate           DateTime
      pdfUrl            String?         // Optional PDF storage
      createdAt         DateTime @default(now())
      subscription      Subscription @relation(...)
    }
    ```
  - [ ] Confirm cents-to-euros conversion: `amountInCents / 100`

- [ ] **Task 3: Verify Amount Calculation Logic** (AC: 2)
  - [ ] Confirm monthly amount: €599.00
  - [ ] Confirm annual amount: €6,469.20
  - [ ] Verify calculation uses PRICING constants from Story 6.1

- [ ] **Task 4: Verify Due Date Calculation** (AC: 2)
  - [ ] Confirm 14-day grace period after period end
  - [ ] Example: periodEnd = Feb 15 → dueDate = Mar 1
  - [ ] Verify timezone-safe calculation

- [ ] **Task 5: Add Integration Tests** (AC: 1-5)
  - [ ] Test file: `backend/tests/integration/invoice-generation.test.ts`
  - [ ] Test invoice created with monthly amount
  - [ ] Test invoice created with annual amount
  - [ ] Test stripeInvoiceId format is correct
  - [ ] Test dueDate is 14 days after periodEnd
  - [ ] Test amount is in euros (not cents)
  - [ ] Test invoice linked to subscription
  - [ ] Run tests: `npm test`

## Dev Notes

### Implementation Reference

**Note:** This method was implemented as part of Story 6.4, Task 3.

**Location:** `backend/src/services/billing.service.ts`

**Method Signature:**
```typescript
private async generateInvoice(
  tx: any,  // Prisma transaction client
  subscription: any
): Promise<void>
```

**Why Private Method:**
- Only called by `processSubscriptionRenewal()`
- Not meant to be used independently
- Keeps invoice generation logic encapsulated

[Source: Story 6.4 - BillingService]

---

### Invoice Model Structure

**Location:** `backend/prisma/schema.prisma` (line 816)

**Full Model:**
```prisma
model Invoice {
  id              String         @id @default(cuid())
  subscriptionId  String
  stripeInvoiceId String         @unique
  amount          Float          // In euros
  currency        String         @default("EUR")
  status          InvoiceStatus  @default(DRAFT)
  periodStart     DateTime
  periodEnd       DateTime
  dueDate         DateTime
  pdfUrl          String?        // Optional PDF storage URL
  metadata        Json?          // Additional invoice data

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([stripeInvoiceId])
  @@index([status])
}
```

**InvoiceStatus Enum:**
```prisma
enum InvoiceStatus {
  DRAFT       // Created but not finalized
  OPEN        // Awaiting payment
  PAID        // Payment received
  VOID        // Cancelled/voided
  UNCOLLECTIBLE  // Payment failed repeatedly
}
```

[Source: backend/prisma/schema.prisma]

---

### Amount Storage Convention

**Important Distinction:**
- **Stripe API**: Amounts in smallest currency unit (cents)
- **Invoice Model**: Amounts in major currency unit (euros)

**Why Different:**
- Stripe: Avoids floating-point errors in payment processing
- Database: Human-readable for reports and accounting

**Conversion:**
```typescript
// From Stripe (cents) to Database (euros)
const amountInCents = PRICING.PREMIUM_MONTHLY.price;  // 59900
const amountInEuros = amountInCents / 100;             // 599.00

// To display
const formatted = `€${amountInEuros.toFixed(2)}`;     // "€599.00"
```

**Example:**
```typescript
// Monthly invoice
const amountInCents = 59900;          // Stripe format
const amountInEuros = 599.00;         // Database format
const amountForDisplay = "€599.00";   // User-facing format

// Annual invoice
const amountInCents = 646920;         // Stripe format
const amountInEuros = 6469.20;        // Database format
const amountForDisplay = "€6,469.20"; // User-facing format
```

[Source: Stripe API documentation]

---

### Stripe Invoice ID Format

**Mock Format (MVP):**
```typescript
const stripeInvoiceId = `draft-${Date.now()}-${subscription.id}`;
// Example: "draft-1729692345678-sub_abc123xyz"
```

**Real Stripe Format:**
```
in_1234567890abcdef  // Real Stripe invoice ID
```

**Why Mock:**
- Real Stripe integration comes later
- Need placeholder for database unique constraint
- Draft prefix clearly indicates it's not real

**Future Implementation:**
```typescript
// Create invoice in Stripe
const stripeInvoice = await stripe.invoices.create({
  customer: subscription.stripeCustomerId,
  subscription: subscription.stripeSubscriptionId,
  auto_advance: true,
});

const stripeInvoiceId = stripeInvoice.id;  // Real Stripe ID
```

[Source: Story 6.4 - BillingService]

---

### Due Date Calculation

**Grace Period:** 14 days after billing period ends

**Rationale:**
- Gives time for payment processing
- Standard industry practice
- Prevents immediate account suspension

**Calculation:**
```typescript
const dueDate = new Date(subscription.currentPeriodEnd);
dueDate.setDate(dueDate.getDate() + 14);
```

**Example:**
```typescript
const periodEnd = new Date('2025-02-15');
const dueDate = new Date(periodEnd);
dueDate.setDate(dueDate.getDate() + 14);
// Result: 2025-03-01
```

**Edge Cases:**
- End of month: Feb 14 + 14 days = Feb 28
- Month boundaries: Jan 30 + 14 days = Feb 13
- Leap years: Handled correctly by JavaScript Date

[Source: Industry billing standards]

---

### Invoice Lifecycle

**Status Flow:**
```
DRAFT → OPEN → PAID
  ↓             ↓
VOID      UNCOLLECTIBLE
```

**State Transitions:**
1. **DRAFT**: Invoice created during renewal, awaiting Stripe confirmation
2. **OPEN**: Stripe invoice finalized, awaiting customer payment
3. **PAID**: Payment received and confirmed
4. **VOID**: Invoice cancelled before payment (e.g., subscription cancelled)
5. **UNCOLLECTIBLE**: Payment failed after multiple retries

**Current Implementation:**
- All invoices created as DRAFT
- Real Stripe integration will update status via webhooks:
  - `invoice.finalized` → OPEN
  - `invoice.paid` → PAID
  - `invoice.voided` → VOID

[Source: Stripe webhook events]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/integration/invoice-generation.test.ts`

**Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { BillingService } from '../src/services/billing.service';
import { PrismaClient, SubscriptionPlan, BillingCycle } from '../src/generated/prisma';

describe('Invoice Generation', () => {
  let service: BillingService;
  let prisma: PrismaClient;
  let monthlySubscriptionId: string;
  let annualSubscriptionId: string;

  beforeAll(async () => {
    service = new BillingService();
    prisma = new PrismaClient();

    // Create MONTHLY subscription
    const monthlyUser = await prisma.user.create({
      data: {
        email: 'invoice-monthly@example.com',
        firstName: 'Invoice',
        lastName: 'Monthly',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.PREMIUM,
            billingCycle: BillingCycle.MONTHLY,
            currentPeriodStart: new Date('2025-01-15'),
            currentPeriodEnd: new Date('2025-02-15'),
            renewalDate: new Date('2025-02-15'),
            creditsBalance: 100,
          },
        },
      },
    });

    const monthlySubscription = await prisma.subscription.findUnique({
      where: { userId: monthlyUser.id },
    });
    monthlySubscriptionId = monthlySubscription.id;

    // Create ANNUAL subscription
    const annualUser = await prisma.user.create({
      data: {
        email: 'invoice-annual@example.com',
        firstName: 'Invoice',
        lastName: 'Annual',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.PREMIUM,
            billingCycle: BillingCycle.ANNUAL,
            currentPeriodStart: new Date('2024-01-15'),
            currentPeriodEnd: new Date('2025-01-15'),
            renewalDate: new Date('2025-01-15'),
            creditsBalance: 100,
          },
        },
      },
    });

    const annualSubscription = await prisma.subscription.findUnique({
      where: { userId: annualUser.id },
    });
    annualSubscriptionId = annualSubscription.id;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: {
        email: { in: ['invoice-monthly@example.com', 'invoice-annual@example.com'] },
      },
    });
    await prisma.$disconnect();
  });

  describe('Monthly invoice', () => {
    it('should generate invoice with correct monthly amount', async () => {
      // Trigger renewal (which generates invoice)
      await service.processSubscriptionRenewal(monthlySubscriptionId);

      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: monthlySubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      expect(invoices.length).toBe(1);
      expect(invoices[0].amount).toBe(599.00);  // In euros
      expect(invoices[0].currency).toBe('EUR');
    });

    it('should have DRAFT status', async () => {
      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: monthlySubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      expect(invoices[0].status).toBe('DRAFT');
    });

    it('should have stripeInvoiceId in mock format', async () => {
      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: monthlySubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      expect(invoices[0].stripeInvoiceId).toMatch(/^draft-\d+-/);
    });

    it('should have dueDate 14 days after periodEnd', async () => {
      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: monthlySubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      const periodEnd = new Date(invoices[0].periodEnd);
      const dueDate = new Date(invoices[0].dueDate);
      const daysDiff = (dueDate.getTime() - periodEnd.getTime()) / (1000 * 60 * 60 * 24);

      expect(daysDiff).toBe(14);
    });

    it('should be linked to subscription', async () => {
      const invoice = await prisma.invoice.findFirst({
        where: { subscriptionId: monthlySubscriptionId },
        include: { subscription: true },
      });

      expect(invoice.subscription).toBeDefined();
      expect(invoice.subscription.id).toBe(monthlySubscriptionId);
    });
  });

  describe('Annual invoice', () => {
    it('should generate invoice with correct annual amount', async () => {
      await service.processSubscriptionRenewal(annualSubscriptionId);

      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: annualSubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      expect(invoices.length).toBe(1);
      expect(invoices[0].amount).toBe(6469.20);  // In euros, with 10% discount
    });
  });

  describe('Invoice uniqueness', () => {
    it('should have unique stripeInvoiceId', async () => {
      const invoice1 = await prisma.invoice.findFirst({
        where: { subscriptionId: monthlySubscriptionId },
      });

      // Try to create duplicate (should fail)
      await expect(
        prisma.invoice.create({
          data: {
            subscriptionId: monthlySubscriptionId,
            stripeInvoiceId: invoice1.stripeInvoiceId,  // Duplicate
            amount: 599,
            currency: 'EUR',
            status: 'DRAFT',
            periodStart: new Date(),
            periodEnd: new Date(),
            dueDate: new Date(),
          },
        })
      ).rejects.toThrow();  // Unique constraint violation
    });
  });
});
```

[Source: architecture.md#Testing Strategy]

---

### File Locations
- **Service:** `backend/src/services/billing.service.ts` (implemented in Story 6.4)
- **Method:** `generateInvoice()` (private helper method)
- **Test:** `backend/tests/integration/invoice-generation.test.ts`
- **Schema:** `backend/prisma/schema.prisma` (line 816 - Invoice model)

---

### Dependencies
**Depends On:**
- Story 6.1: PRICING constants
- Story 6.4: BillingService class
- Existing: Invoice model

**Depended On By:**
- Future: Stripe webhook integration for invoice status updates
- Future: Invoice PDF generation

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 6 | Bob (Scrum Master) |
| 2025-10-23 | 1.1 | Note: Implementation already in Story 6.4 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
**Note:** This method was implemented as part of Story 6.4, Task 3. This story provides additional testing and documentation only.

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
