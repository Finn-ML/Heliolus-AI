# Story 3.5: Frontend Component Integration

## Status
Draft

## Story

**As a** frontend developer,
**I want** to update RiskAreasAnalysis and RemediationStrategy components,
**So that** they display real AI-generated content

## Acceptance Criteria

1. Remove mock `setTimeout` generation code
2. Fetch from new `/ai-analysis` endpoint
3. Loading states show "Generating AI analysis (one-time process)..."
4. Error states handle API failures gracefully
5. Cache with infinite stale time (never refetch after success)
6. Display generation date to users ("Generated on: {date}")
7. Components handle null AI fields gracefully
8. No performance regression from current mock implementation

## Tasks / Subtasks

- [ ] Task 1: Update API client (AC: 2)
  - [ ] Open `frontend/src/lib/api.ts`
  - [ ] Add `getAIAnalysis` method to assessmentApi
  - [ ] Add query key for AI analysis
  - [ ] Follow existing API client patterns

- [ ] Task 2: Update RiskAreasAnalysis component (AC: 1, 2, 3, 4, 5)
  - [ ] Open `frontend/src/pages/AssessmentResults.tsx`
  - [ ] Locate RiskAreasAnalysis component (lines 145-420)
  - [ ] Remove mock setTimeout generation
  - [ ] Add React Query hook for API call
  - [ ] Implement loading state with proper message

- [ ] Task 3: Update RemediationStrategy component (AC: 1, 2, 3, 4, 5)
  - [ ] Locate RemediationStrategy component (lines 422-805)
  - [ ] Remove mock setTimeout generation
  - [ ] Use same React Query data from parent
  - [ ] Handle strategy matrix data structure

- [ ] Task 4: Implement infinite caching (AC: 5)
  - [ ] Set staleTime: Infinity in query options
  - [ ] Set cacheTime: Infinity
  - [ ] Ensure data never refetches after success
  - [ ] Test cache persistence

- [ ] Task 5: Add generation date display (AC: 6)
  - [ ] Format generatedAt timestamp
  - [ ] Display in both components
  - [ ] Use relative time format (e.g., "2 hours ago")
  - [ ] Add tooltip with exact timestamp

- [ ] Task 6: Handle null AI fields (AC: 7)
  - [ ] Check for null values before rendering
  - [ ] Provide fallback UI for missing data
  - [ ] Ensure no component crashes
  - [ ] Test with assessments lacking AI data

- [ ] Task 7: Performance testing (AC: 8)
  - [ ] Measure component render time
  - [ ] Compare with previous mock implementation
  - [ ] Ensure no blocking operations
  - [ ] Verify React Query caching works

## Dev Notes

### API Client Update
[Source: frontend/src/lib/api.ts]

Add new method to assessmentApi:
```typescript
export const assessmentApi = {
  // ... existing methods ...

  /**
   * Get AI-generated analysis (generates if not exists)
   */
  getAIAnalysis: async (assessmentId: string) => {
    return apiRequest<{
      riskAnalysis: any;
      strategyMatrix: any[];
      generatedAt: string;
    }>(`/assessments/${assessmentId}/ai-analysis`);
  }
};

// Add query key
export const queryKeys = {
  // ... existing keys
  assessmentAIAnalysis: (id: string) => ['assessment', id, 'ai-analysis'] as const,
};
```

### RiskAreasAnalysis Component Update
[Source: frontend/src/pages/AssessmentResults.tsx lines 145-420]

Current mock implementation to replace:
```typescript
// REMOVE THIS:
useEffect(() => {
  const generateAnalysis = async () => {
    setIsGenerating(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 1000));
      // ... mock data generation
    }
  };
}, [gaps]);
```

Replace with:
```typescript
const RiskAreasAnalysis = ({ gaps, assessmentId }: { gaps: Gap[]; assessmentId: string }) => {
  const [analysisData, setAnalysisData] = useState<any>(null);

  // Fetch AI analysis from database (generates if not exists)
  const { data: aiData, isLoading: isGenerating, error } = useQuery({
    queryKey: queryKeys.assessmentAIAnalysis(assessmentId),
    queryFn: () => assessmentApi.getAIAnalysis(assessmentId),
    enabled: gaps.length > 0,
    staleTime: Infinity, // Never refetch - it's permanent
    cacheTime: Infinity, // Keep in cache forever
    retry: 1, // Only retry once on failure
  });

  useEffect(() => {
    if (aiData?.data?.riskAnalysis) {
      setAnalysisData(aiData.data.riskAnalysis);
    }
  }, [aiData]);

  if (isGenerating) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="text-center">
          <Brain className="h-12 w-12 text-cyan-400 animate-pulse mx-auto mb-4" />
          <p className="text-gray-400">
            {!aiData ? 'Generating AI analysis (one-time process)...' : 'Loading analysis...'}
          </p>
          <p className="text-xs text-gray-500 mt-2">
            This may take up to 5 seconds on first generation
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <Alert className="border-red-800">
        <AlertTriangle className="h-4 w-4" />
        <AlertDescription>
          Failed to load AI analysis. Please try refreshing the page.
        </AlertDescription>
      </Alert>
    );
  }

  // Add generation date display
  const generatedAt = aiData?.data?.generatedAt;

  // Rest of component remains the same
  // ...
};
```

### RemediationStrategy Component Update
[Source: frontend/src/pages/AssessmentResults.tsx lines 422-805]

Similar update pattern:
```typescript
const RemediationStrategy = ({ gaps, risks, assessmentId }: any) => {
  const [strategyData, setStrategyData] = useState<any[]>([]);

  // Use the same query as RiskAreasAnalysis (will share cache)
  const { data: aiData, isLoading: isGenerating, error } = useQuery({
    queryKey: queryKeys.assessmentAIAnalysis(assessmentId),
    queryFn: () => assessmentApi.getAIAnalysis(assessmentId),
    enabled: gaps.length > 0,
    staleTime: Infinity,
    cacheTime: Infinity,
  });

  useEffect(() => {
    if (aiData?.data?.strategyMatrix) {
      setStrategyData(aiData.data.strategyMatrix);
    }
  }, [aiData]);

  // Remove all the mock generation code
  // Keep the sorting and display logic
  // ...
};
```

### Date Formatting
[Source: Use existing date utilities or add new]

```typescript
import { formatDistanceToNow } from 'date-fns'; // If available

// Or simple formatter
const formatGeneratedDate = (dateString: string) => {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins} minutes ago`;
  if (diffMins < 1440) return `${Math.floor(diffMins / 60)} hours ago`;
  return date.toLocaleDateString();
};
```

Display in UI:
```typescript
{generatedAt && (
  <div className="text-xs text-gray-500 mt-2">
    <span title={new Date(generatedAt).toLocaleString()}>
      Generated {formatGeneratedDate(generatedAt)}
    </span>
  </div>
)}
```

### Error Handling Pattern
[Source: Existing React Query patterns in codebase]

```typescript
// Consistent error handling
if (error) {
  const errorMessage = error instanceof Error ? error.message : 'An error occurred';

  return (
    <Alert className="border-red-800">
      <AlertTriangle className="h-4 w-4" />
      <AlertDescription>
        {errorMessage.includes('404')
          ? 'Assessment not found'
          : 'Failed to load AI analysis. Please try refreshing the page.'}
      </AlertDescription>
    </Alert>
  );
}
```

### Null Field Handling

```typescript
// Safe access with optional chaining
const criticalGaps = analysisData?.criticalGaps ?? 0;
const keyFindings = analysisData?.keyFindings ?? [];

// Conditional rendering
{analysisData ? (
  <div>
    {/* Render analysis data */}
  </div>
) : (
  <div className="text-gray-500">
    No analysis data available
  </div>
)}
```

### React Query Configuration
[Source: Existing query configuration]

The queries will automatically share cached data because they use the same query key. This means only one API call will be made even though both components use the hook.

### Type Definitions

Add to `frontend/src/types/assessment.ts`:
```typescript
export interface AIAnalysisResponse {
  success: boolean;
  data: {
    riskAnalysis: Record<string, RiskCategoryAnalysis>;
    strategyMatrix: StrategyMatrixRow[];
    generatedAt: string;
  };
}

export interface RiskCategoryAnalysis {
  score: number;
  totalGaps: number;
  criticalGaps: number;
  keyFindings: KeyFinding[];
  mitigationStrategies: MitigationStrategy[];
}

export interface KeyFinding {
  finding: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  description: string;
}

export interface MitigationStrategy {
  strategy: string;
  priority: 'immediate' | 'short-term' | 'medium-term' | 'long-term';
  impact: 'high' | 'medium' | 'low';
  rationale?: string;
}

export interface StrategyMatrixRow {
  priority: number;
  riskArea: string;
  adjustedRisk: string;
  urgency: string;
  impact: string;
  primaryMitigation: string;
  timeline: string;
  budget: string;
  businessOwner: string;
  gapCount: number;
  criticalGaps: number;
}
```

## Testing

### Testing Standards

**Test File Location:**
`frontend/src/pages/AssessmentResults.test.tsx`

**Component Test Example:**
```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AssessmentResults } from './AssessmentResults';

describe('AI Analysis Integration', () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false }
    }
  });

  it('should display loading state during generation', async () => {
    vi.mock('@/lib/api', () => ({
      assessmentApi: {
        getAIAnalysis: vi.fn(() => new Promise(resolve => setTimeout(resolve, 100)))
      }
    }));

    render(
      <QueryClientProvider client={queryClient}>
        <AssessmentResults />
      </QueryClientProvider>
    );

    expect(screen.getByText(/Generating AI analysis/i)).toBeInTheDocument();
  });

  it('should display generated date', async () => {
    const mockData = {
      success: true,
      data: {
        riskAnalysis: {},
        strategyMatrix: [],
        generatedAt: new Date().toISOString()
      }
    };

    vi.mock('@/lib/api', () => ({
      assessmentApi: {
        getAIAnalysis: vi.fn().mockResolvedValue(mockData)
      }
    }));

    render(
      <QueryClientProvider client={queryClient}>
        <AssessmentResults />
      </QueryClientProvider>
    );

    await waitFor(() => {
      expect(screen.getByText(/Generated/i)).toBeInTheDocument();
    });
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_