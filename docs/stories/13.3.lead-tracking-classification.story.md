# Story 13.3: Lead Tracking & Classification System

## Status
Draft

## Story

**As an** admin
**I want** to see all RFPs and contacts classified by type (Basic vs Premium)
**So that** I can track lead quality and prioritize sales follow-up

## Acceptance Criteria

1. Admin dashboard shows two tabs:
   - **Premium Leads**: Full RFPs with strategic context
   - **Basic Leads**: Simple contact form submissions
2. Each lead displays:
   - Company name, user email, submission date
   - Lead type badge (Premium/Basic)
   - Status (New, Contacted, Qualified, Closed)
   - Associated vendors
   - Quick actions: View details, Export, Update status
3. Export functionality:
   - CSV export of filtered leads
   - Columns: Date, Company, User, Type, Status, Vendors, Budget, Timeline
4. API endpoints:
   - `GET /v1/admin/leads` - List all leads with filters (type, status, date range)
   - `GET /v1/admin/leads/:id` - Lead details
   - `PATCH /v1/admin/leads/:id` - Update lead status
   - `GET /v1/admin/leads/export` - CSV export
5. Backend: Unified "Lead" view combining RFP and VendorContact records
6. Analytics query: Count by type, status, conversion rates

## Tasks / Subtasks

### Backend Tasks

- [ ] **Task 1: Lead Classification Logic** (AC: 5)
  - [ ] Create `backend/src/services/lead.service.ts` extending BaseService
  - [ ] Implement `getLeads(filters)` method aggregating:
    - Premium leads: Query RFP table where status = SENT
    - Basic leads: Query VendorContact table where type != RFP
  - [ ] For each lead, return unified structure:
    ```typescript
    interface Lead {
      id: string,            // RFP ID or VendorContact ID
      type: 'PREMIUM' | 'BASIC',
      companyName: string,   // From Organization
      userEmail: string,     // From User
      submissionDate: DateTime,
      status: LeadStatus,    // NEW, CONTACTED, QUALIFIED, CLOSED
      vendors: string[],     // Vendor company names
      budget?: string,
      timeline?: string,
      rfpTitle?: string,     // Premium only
      objectives?: string,   // Premium only
      message?: string       // Basic only
    }
    ```
  - [ ] Classification: RFP records = PREMIUM, VendorContact (type != RFP) = BASIC

- [ ] **Task 2: Lead Filtering** (AC: 1, 4)
  - [ ] Add filter parameters to `getLeads`:
    - `type`: 'PREMIUM' | 'BASIC' | 'ALL' (default: ALL)
    - `status`: LeadStatus[] (filter by status)
    - `startDate`, `endDate`: Date range filters
    - `page`, `limit`: Pagination (default: page 1, limit 50)
  - [ ] Apply filters to queries:
    - Type filter: Query only RFP or only VendorContact
    - Status filter: WHERE status IN (...)
    - Date range: WHERE createdAt BETWEEN startDate AND endDate
  - [ ] Return paginated results with total count

- [ ] **Task 3: Lead Details Endpoint** (AC: 2, 4)
  - [ ] Implement `getLeadById(leadId, leadType)` method
  - [ ] If type = PREMIUM:
    - Query RFP by ID with includes: user, organization, vendorContacts
    - Return full RFP data + associated vendor responses
  - [ ] If type = BASIC:
    - Query VendorContact by ID with includes: user, organization, vendor
    - Return contact details
  - [ ] Return unified Lead structure with all available details

- [ ] **Task 4: Update Lead Status** (AC: 2, 4)
  - [ ] Add `updateLeadStatus(leadId, leadType, newStatus)` method
  - [ ] Add LeadStatus enum (if not exists): NEW, CONTACTED, QUALIFIED, CLOSED
  - [ ] If type = PREMIUM: Update RFP.status (add LeadStatus field to RFP model via migration)
  - [ ] If type = BASIC: Update VendorContact.status (already exists)
  - [ ] Validate status transitions (optional: state machine)
  - [ ] Log status change to audit trail

- [ ] **Task 5: Lead Analytics** (AC: 6)
  - [ ] Implement `getLeadAnalytics()` method returning:
    ```typescript
    {
      totalLeads: number,
      premiumLeads: number,
      basicLeads: number,
      byStatus: { NEW: number, CONTACTED: number, QUALIFIED: number, CLOSED: number },
      conversionRate: number,  // QUALIFIED / totalLeads
      avgResponseTime: number  // Hours from NEW to CONTACTED
    }
    ```
  - [ ] Use Prisma aggregations: count, groupBy
  - [ ] Cache results for 5 minutes (similar to Epic 11 analytics)

- [ ] **Task 6: CSV Export** (AC: 3, 4)
  - [ ] Implement `exportLeadsToCSV(filters)` method
  - [ ] Query leads with same filters as getLeads (no pagination)
  - [ ] Use papaparse library (already in project) to generate CSV
  - [ ] CSV columns: Date, Company, User Email, Type, Status, Vendors, Budget, Timeline, RFP Title
  - [ ] Return CSV string for download

- [ ] **Task 7: Lead API Routes** (AC: 4)
  - [ ] Add routes to `backend/src/routes/admin.routes.ts`:
    - `GET /v1/admin/leads` - List leads with filters
    - `GET /v1/admin/leads/:id` - Lead details (requires `type` query param)
    - `PATCH /v1/admin/leads/:id` - Update status (requires `type` query param)
    - `GET /v1/admin/leads/export` - CSV export (same filters as list)
    - `GET /v1/admin/leads/analytics` - Lead analytics summary
  - [ ] Apply requireRole('ADMIN') middleware to all routes
  - [ ] Add Zod validation for query parameters and request bodies

### Frontend Tasks

- [ ] **Task 8: Lead List Component** (AC: 1, 2)
  - [ ] Create `frontend/src/components/admin/LeadListPage.tsx`
  - [ ] Add tabs: "Premium Leads" | "Basic Leads" | "All Leads"
  - [ ] Lead table with columns:
    - Submission Date (sortable)
    - Company Name
    - User Email
    - Type Badge (Premium: blue, Basic: gray)
    - Status Badge (colored: New=green, Contacted=yellow, Qualified=blue, Closed=gray)
    - Vendors (comma-separated list)
    - Actions (View Details, Update Status)
  - [ ] Implement filters:
    - Status dropdown (multi-select)
    - Date range picker
  - [ ] Pagination: 50 leads per page with page controls

- [ ] **Task 9: Lead Details Modal** (AC: 2)
  - [ ] Create `frontend/src/components/admin/LeadDetailsModal.tsx`
  - [ ] On "View Details" click: Open modal with full lead info
  - [ ] Premium Lead Details:
    - Company overview, RFP title, objectives, requirements
    - Timeline, budget
    - Attached documents (download links)
    - Vendors sent to (list with contact status per vendor)
  - [ ] Basic Lead Details:
    - Company name, user info
    - Message, budget, timeline
    - Single vendor contacted
  - [ ] Close button

- [ ] **Task 10: Status Update Dropdown** (AC: 2)
  - [ ] Add status dropdown in each lead row
  - [ ] Options: New, Contacted, Qualified, Closed
  - [ ] On change: Call PATCH /v1/admin/leads/:id with new status
  - [ ] Show loading spinner during update
  - [ ] Success: Update table row with new status badge
  - [ ] Error: Show error toast, revert dropdown

- [ ] **Task 11: CSV Export Button** (AC: 3)
  - [ ] Add "Export CSV" button above lead table
  - [ ] On click: Call GET /v1/admin/leads/export with current filters
  - [ ] Download CSV file: `leads-export-{date}.csv`
  - [ ] Show loading spinner during export
  - [ ] Handle errors with toast notification

- [ ] **Task 12: Lead Analytics Cards** (AC: 6)
  - [ ] Add analytics summary cards at top of page:
    - Total Leads (with Premium/Basic breakdown)
    - Conversion Rate (QUALIFIED / total)
    - Average Response Time
    - Leads by Status (pie chart)
  - [ ] Fetch data from GET /v1/admin/leads/analytics
  - [ ] Auto-refresh every 5 minutes

- [ ] **Task 13: API Hooks** (AC: 4)
  - [ ] Create `frontend/src/hooks/useLeads.ts` (TanStack Query)
    - `useLeads(filters)` - List leads with pagination
    - `useLeadDetails(leadId, leadType)` - Fetch lead details
    - `useUpdateLeadStatus()` - Mutation for status update
    - `useExportLeads(filters)` - Trigger CSV download
    - `useLeadAnalytics()` - Fetch analytics summary

### Testing

- [ ] **Task 14: Backend Unit Tests** (AC: 5, 6)
  - [ ] Test lead.service.ts:
    - Test getLeads: Premium only, Basic only, All, with filters
    - Test classification logic: RFP = Premium, VendorContact = Basic
    - Test pagination, date filters
    - Test getLeadAnalytics: counts, conversion rate
    - Test exportLeadsToCSV: correct CSV format

- [ ] **Task 15: API Contract Tests** (AC: 4)
  - [ ] Test GET /v1/admin/leads: As admin (200), as user (403), with filters
  - [ ] Test GET /v1/admin/leads/:id: Valid lead (200), invalid ID (404)
  - [ ] Test PATCH /v1/admin/leads/:id: Update status (200), invalid status (400)
  - [ ] Test GET /v1/admin/leads/export: Returns CSV with correct columns
  - [ ] Test GET /v1/admin/leads/analytics: Returns correct structure

- [ ] **Task 16: Frontend Component Tests**
  - [ ] Test LeadListPage: Renders tabs, table, filters
  - [ ] Test status dropdown: Updates status on change
  - [ ] Test CSV export: Triggers download
  - [ ] Test pagination: Navigates pages

## Dev Notes

### Project Context
Story 13.3 enables admin visibility into all leads (both Premium RFPs and Basic contact forms) with classification, status tracking, and CSV export for CRM integration. This story builds on Stories 13.1 (RFP creation) and 13.2 (RFP delivery).

**Dependencies:**
- Story 13.1 (RFP model)
- Story 13.2 (RFP sending, VendorContact with rfpId)

[Source: docs/prd/epic-13-rfp-vendor-engagement.md#Story 13.3]

### Tech Stack
- **Backend**: Fastify 4 + TypeScript | Prisma 6 | papaparse (CSV generation)
- **Frontend**: React 18 + TypeScript | TanStack Query 5 | Recharts (for analytics charts)

[Source: CLAUDE.md#Tech Stack, backend/src/routes/admin.routes.ts:7]

### Lead Classification Model

**Virtual "Lead" Model:**
This story does NOT create a new database table. Instead, it creates a unified view combining two existing tables:
- **Premium Leads**: RFP records (status = SENT)
- **Basic Leads**: VendorContact records (type != RFP)

**Unified Lead Interface:**
```typescript
interface Lead {
  id: string;              // RFP.id or VendorContact.id
  type: 'PREMIUM' | 'BASIC';

  // Common fields (from User + Organization)
  companyName: string;
  userEmail: string;
  submissionDate: DateTime;
  status: LeadStatus;      // NEW, CONTACTED, QUALIFIED, CLOSED

  // Vendor associations
  vendors: string[];        // Vendor company names

  // Optional fields (some Premium, some Basic)
  budget?: string;
  timeline?: string;
  rfpTitle?: string;        // Premium only
  objectives?: string;      // Premium only
  requirements?: string;    // Premium only
  message?: string;         // Basic only (from VendorContact.message)
}
```

**Classification Logic:**
```typescript
async getLeads(filters: LeadFilters): Promise<Lead[]> {
  const leads: Lead[] = [];

  // Premium leads from RFP
  if (filters.type === 'PREMIUM' || filters.type === 'ALL') {
    const rfps = await this.prisma.rFP.findMany({
      where: {
        status: 'SENT',  // Only sent RFPs are leads
        ...(filters.startDate && { createdAt: { gte: filters.startDate } }),
        ...(filters.endDate && { createdAt: { lte: filters.endDate } }),
      },
      include: {
        user: true,
        organization: true,
        contacts: { include: { vendor: true } }
      }
    });

    leads.push(...rfps.map(rfp => ({
      id: rfp.id,
      type: 'PREMIUM' as const,
      companyName: rfp.organization.name,
      userEmail: rfp.user.email,
      submissionDate: rfp.sentAt,
      status: rfp.leadStatus || 'NEW',  // New field added in Task 4
      vendors: rfp.contacts.map(c => c.vendor.companyName),
      budget: rfp.budget,
      timeline: rfp.timeline,
      rfpTitle: rfp.title,
      objectives: rfp.objectives,
      requirements: rfp.requirements
    })));
  }

  // Basic leads from VendorContact
  if (filters.type === 'BASIC' || filters.type === 'ALL') {
    const contacts = await this.prisma.vendorContact.findMany({
      where: {
        type: { not: 'RFP' },  // Exclude RFP-generated contacts
        ...(filters.startDate && { createdAt: { gte: filters.startDate } }),
        ...(filters.endDate && { createdAt: { lte: filters.endDate } }),
      },
      include: {
        user: true,
        organization: true,
        vendor: true
      }
    });

    leads.push(...contacts.map(contact => ({
      id: contact.id,
      type: 'BASIC' as const,
      companyName: contact.organization.name,
      userEmail: contact.user.email,
      submissionDate: contact.createdAt,
      status: contact.status,  // VendorContact already has status
      vendors: [contact.vendor.companyName],
      budget: contact.budget,
      timeline: contact.timeline,
      message: contact.message
    })));
  }

  // Sort by date, filter by status, paginate
  return leads
    .filter(lead => !filters.status || filters.status.includes(lead.status))
    .sort((a, b) => b.submissionDate.getTime() - a.submissionDate.getTime())
    .slice(filters.page * filters.limit, (filters.page + 1) * filters.limit);
}
```

[Source: docs/prd/epic-13-rfp-vendor-engagement.md#Story 13.3 Technical Notes]

### Database Schema Changes

**Add LeadStatus to RFP Model:**
The RFP model currently has `RFPStatus` (DRAFT, SENT, ACTIVE, CLOSED, ARCHIVED) for RFP lifecycle. We need a separate `leadStatus` field for sales tracking.

**Migration Required:**
```prisma
model RFP {
  // ... existing fields

  // Add new field for lead tracking
  leadStatus  LeadStatus? @default(NEW)  // NEW, CONTACTED, QUALIFIED, CLOSED

  // ... rest of model
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  CLOSED
}
```

**VendorContact Status:**
VendorContact already has a `status` field (`ContactStatus` enum: PENDING, RESPONDED, CLOSED). We'll map this to LeadStatus:
- PENDING → NEW
- RESPONDED → CONTACTED
- CLOSED → CLOSED

Alternatively, add `leadStatus` field to VendorContact for consistency (optional enhancement).

[Source: backend/prisma/schema.prisma:316-359, docs/prd/epic-13-rfp-vendor-engagement.md]

### Existing Admin Dashboard Patterns

**Admin Routes:**
- File: `backend/src/routes/admin.routes.ts`
- Middleware: `requireRole('ADMIN')` for all admin endpoints
- Response pattern: Standard `ApiResponse<T>` wrapper
- CSV generation: Uses `papaparse` library (imported as `Papa`)

**Example Admin Endpoint Pattern:**
```typescript
fastify.get(
  '/v1/admin/users',
  {
    preHandler: [authenticationMiddleware, requireRole('ADMIN')],
    schema: {
      querystring: {
        type: 'object',
        properties: {
          page: { type: 'number', default: 1 },
          limit: { type: 'number', default: 50 },
          status: { type: 'string' }
        }
      }
    }
  },
  asyncHandler(async (request, reply) => {
    const { page, limit, status } = request.query;
    const users = await userService.getUsers({ page, limit, status });
    return reply.send({ success: true, data: users });
  })
);
```

[Source: backend/src/routes/admin.routes.ts:1-80]

### CSV Export with Papaparse

**Library:** papaparse (already in project dependencies)
**Usage:**
```typescript
import Papa from 'papaparse';

function exportLeadsToCSV(leads: Lead[]): string {
  const csvData = leads.map(lead => ({
    Date: lead.submissionDate.toISOString(),
    Company: lead.companyName,
    'User Email': lead.userEmail,
    Type: lead.type,
    Status: lead.status,
    Vendors: lead.vendors.join(', '),
    Budget: lead.budget || 'N/A',
    Timeline: lead.timeline || 'N/A',
    'RFP Title': lead.rfpTitle || 'N/A'
  }));

  return Papa.unparse(csvData);
}
```

**Frontend Download:**
```typescript
async function downloadCSV() {
  const response = await fetch('/v1/admin/leads/export?type=ALL');
  const csv = await response.text();

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = window.URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `leads-export-${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
  window.URL.revokeObjectURL(url);
}
```

[Source: backend/src/routes/admin.routes.ts:7, papaparse documentation]

### Lead Analytics Calculations

**Analytics Metrics:**
```typescript
interface LeadAnalytics {
  totalLeads: number;
  premiumLeads: number;
  basicLeads: number;
  byStatus: {
    NEW: number;
    CONTACTED: number;
    QUALIFIED: number;
    CLOSED: number;
  };
  conversionRate: number;       // (QUALIFIED + CLOSED) / totalLeads * 100
  avgResponseTime: number;      // Hours from NEW to CONTACTED (average)
}
```

**Prisma Aggregation Queries:**
```typescript
async getLeadAnalytics(): Promise<LeadAnalytics> {
  // Count Premium leads (RFPs)
  const premiumCount = await this.prisma.rFP.count({ where: { status: 'SENT' } });

  // Count Basic leads (VendorContacts)
  const basicCount = await this.prisma.vendorContact.count({ where: { type: { not: 'RFP' } } });

  // Group by status for Premium
  const rfpByStatus = await this.prisma.rFP.groupBy({
    by: ['leadStatus'],
    _count: true,
    where: { status: 'SENT' }
  });

  // Group by status for Basic
  const contactByStatus = await this.prisma.vendorContact.groupBy({
    by: ['status'],
    _count: true,
    where: { type: { not: 'RFP' } }
  });

  // Calculate conversion rate
  const qualified = rfpByStatus.find(s => s.leadStatus === 'QUALIFIED')?._count || 0;
  const closed = rfpByStatus.find(s => s.leadStatus === 'CLOSED')?._count || 0;
  const conversionRate = ((qualified + closed) / (premiumCount + basicCount)) * 100;

  // ... aggregate response time

  return { /* assembled analytics */ };
}
```

[Source: Epic 11 analytics patterns from docs/prd/epic-11-admin-assessment-reports.md]

### Frontend Admin Dashboard Integration

**Admin Dashboard Location:**
- Page: `frontend/src/pages/admin/AdminDashboard.tsx` (existing)
- New page: `frontend/src/pages/admin/LeadsPage.tsx`
- Components: `frontend/src/components/admin/`

**Navigation:**
Add "Leads" tab to admin dashboard navigation (alongside Users, Vendors, Reports).

**Table Component Pattern:**
Use existing Radix UI Table components:
```tsx
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Select } from '@/components/ui/select';

function LeadListTable({ leads }: { leads: Lead[] }) {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Date</TableHead>
          <TableHead>Company</TableHead>
          <TableHead>User</TableHead>
          <TableHead>Type</TableHead>
          <TableHead>Status</TableHead>
          <TableHead>Vendors</TableHead>
          <TableHead>Actions</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {leads.map(lead => (
          <TableRow key={lead.id}>
            <TableCell>{formatDate(lead.submissionDate)}</TableCell>
            <TableCell>{lead.companyName}</TableCell>
            <TableCell>{lead.userEmail}</TableCell>
            <TableCell>
              <Badge variant={lead.type === 'PREMIUM' ? 'default' : 'secondary'}>
                {lead.type}
              </Badge>
            </TableCell>
            <TableCell>
              <Badge variant={getStatusVariant(lead.status)}>
                {lead.status}
              </Badge>
            </TableCell>
            <TableCell>{lead.vendors.join(', ')}</TableCell>
            <TableCell>
              {/* View Details, Update Status actions */}
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}
```

[Source: frontend/src/components/ui/ Radix UI patterns]

### API Routes

**All routes require ADMIN role:**
```typescript
// In admin.routes.ts
fastify.get('/v1/admin/leads',
  { preHandler: [authenticationMiddleware, requireRole('ADMIN')] },
  asyncHandler(async (request, reply) => { /* ... */ })
);
```

**Route Specifications:**

1. **GET /v1/admin/leads** - List leads with filters
   - Query params: `type`, `status[]`, `startDate`, `endDate`, `page`, `limit`
   - Response: `{ success: true, data: { leads: Lead[], total: number, page, limit } }`

2. **GET /v1/admin/leads/:id** - Lead details
   - Query param: `type` (PREMIUM | BASIC) - required to know which table to query
   - Response: `{ success: true, data: Lead }`

3. **PATCH /v1/admin/leads/:id** - Update lead status
   - Query param: `type` (PREMIUM | BASIC)
   - Body: `{ status: LeadStatus }`
   - Response: `{ success: true, data: Lead }`

4. **GET /v1/admin/leads/export** - CSV export
   - Query params: Same as list (type, status, date range)
   - Response: CSV string (Content-Type: text/csv)

5. **GET /v1/admin/leads/analytics** - Analytics summary
   - No params
   - Response: `{ success: true, data: LeadAnalytics }`

[Source: docs/prd/epic-13-rfp-vendor-engagement.md#Story 13.3 AC 4]

### File Locations

**Backend:**
- New service: `backend/src/services/lead.service.ts`
- Add routes: `backend/src/routes/admin.routes.ts` (append to existing file)
- Schema update: `backend/prisma/schema.prisma` (add leadStatus to RFP, LeadStatus enum)

**Frontend:**
- New page: `frontend/src/pages/admin/LeadsPage.tsx`
- New components:
  - `frontend/src/components/admin/LeadListTable.tsx`
  - `frontend/src/components/admin/LeadDetailsModal.tsx`
  - `frontend/src/components/admin/LeadAnalyticsCards.tsx`
- New hooks: `frontend/src/hooks/useLeads.ts`
- Update navigation: `frontend/src/components/admin/AdminNav.tsx` (add Leads link)

[Source: CLAUDE.md#Project Structure]

### Testing

#### Backend Testing

**Service Tests:**
- File: `backend/tests/services/lead.service.test.ts`
- Test classification: RFP = Premium, VendorContact = Basic
- Test filtering: type, status, date range
- Test pagination
- Test analytics calculations
- Test CSV generation

**Contract Tests:**
- File: `backend/tests/contract/admin.routes.test.ts` (append)
- Test all 5 admin/leads endpoints
- Test authorization: Admin only (403 for USER role)
- Test filters and pagination
- Test CSV download

**Run Commands:**
- `npm run test` (from backend/)
- `npm run test:contract` (from backend/)

[Source: CLAUDE.md#Testing]

#### Frontend Testing

**Component Tests:**
- Test LeadListTable: Renders leads, badges, actions
- Test LeadDetailsModal: Shows correct details for Premium/Basic
- Test status dropdown: Updates on change
- Test CSV export button: Triggers download
- Test filters: Date range, status multi-select

[Source: CLAUDE.md#Testing patterns]

## Codebase Review Findings

**Review Date**: 2025-10-27
**Review Document**: `.ai/epic-13-codebase-review.md`

### Confirmed Missing Components (Must Create)

✅ **Services**:
- lead.service.ts does NOT exist - must create from scratch (Task 1)
- This is a NEW service creating a virtual "Lead" model by aggregating RFP + VendorContact

✅ **Routes**:
- admin.routes.ts EXISTS ✅
- **MUST ADD**: 5 new admin lead routes to existing file (Task 7):
  - GET /v1/admin/leads
  - GET /v1/admin/leads/:id
  - PATCH /v1/admin/leads/:id
  - GET /v1/admin/leads/export
  - GET /v1/admin/leads/analytics

✅ **Infrastructure** (Already Available):
- papaparse library ALREADY INSTALLED ✅ (used at line 7 of admin.routes.ts)
- requireRole('ADMIN') middleware EXISTS ✅
- CSV export pattern EXISTS in admin.routes.ts ✅

✅ **Database**:
- RFP model does NOT exist (dependency from Story 13.1)
- LeadStatus enum needs to be added to RFP model
- VendorContact model EXISTS ✅
- VendorContact.status field EXISTS ✅

### Dependencies

**BLOCKING**: Story 13.1 and 13.2 must be completed first:
- RFP model must exist
- RFP.leadStatus field must exist
- VendorContact.rfpId field must exist (for linking)
- RFP records must be sent (status = SENT) to appear as leads

### Lead Classification Logic Confirmed

**Premium Leads**: RFP records where status = 'SENT'
- Source table: RFP
- Includes: rfpTitle, objectives, requirements, budget, timeline
- Linked vendors via VendorContact (where rfpId IS NOT NULL)

**Basic Leads**: VendorContact records where type != 'RFP'
- Source table: VendorContact
- Includes: message, budget, timeline
- Single vendor per contact

**Virtual Lead Model**: Service aggregates both types into unified interface

### Implementation Priority

**Story 13.3 Order**:
1. Create lead.service.ts with classification logic (Task 1)
2. Implement filtering and pagination (Task 2)
3. Add getLeadById with type discrimination (Task 3)
4. Add updateLeadStatus with type handling (Task 4)
5. Implement analytics aggregation (Task 5)
6. Add CSV export with papaparse (Task 6)
7. Add 5 admin routes to admin.routes.ts (Task 7)

**Estimated Effort**: 6-8 hours

### Notes for Dev Agent

- **NO NEW DATABASE TABLES** - this is a virtual model aggregating existing data
- LeadStatus field goes on RFP model (already specified in Story 13.1)
- VendorContact.status mapping: PENDING→NEW, RESPONDED→CONTACTED, CLOSED→CLOSED
- CSV export: Use Papa.unparse() pattern (already in admin.routes.ts)
- Analytics: Use Prisma groupBy and aggregations
- Type query param required for GET /:id and PATCH /:id (to know which table to query)

### Status Field Mapping

**RFP.leadStatus** (NEW field, LeadStatus enum):
- NEW (default after sending)
- CONTACTED (admin marks as contacted)
- QUALIFIED (admin marks as qualified lead)
- CLOSED (admin marks as closed)

**VendorContact.status** (EXISTING field, ContactStatus enum):
- PENDING → Maps to NEW
- ACKNOWLEDGED → Maps to CONTACTED
- IN_PROGRESS → Maps to CONTACTED
- COMPLETED → Maps to CLOSED
- REJECTED → Maps to CLOSED

## Architectural Decisions & Issue Resolutions

**Decision Document**: `.ai/epic-13-architectural-decisions.md`
**Review Date**: 2025-10-27

### Status Enum Clarification (MEDIUM)

**Problem**: LeadStatus and RFPStatus enums appear to overlap, causing confusion about which to use.

**Clarification**: These enums serve **different purposes** and both are needed:

**RFPStatus** (User workflow):
- `DRAFT` → User creating RFP
- `SENT` → RFP delivered to vendors
- `FAILED` → Email delivery failed
- `ARCHIVED` → User archived RFP

**LeadStatus** (Admin sales funnel):
- `NEW` → Lead just created (maps to RFP.SENT)
- `IN_PROGRESS` → Admin actively working lead
- `QUALIFIED` → Lead meets criteria
- `CONVERTED` → Lead became customer
- `LOST` → Lead not converted (maps to RFP.ARCHIVED)

**Mapping Logic**:
```typescript
// backend/src/services/lead.service.ts
private mapRFPToLeadStatus(rfpStatus: RFPStatus): LeadStatus | null {
  switch (rfpStatus) {
    case 'SENT':
      return 'NEW';        // Initial lead state
    case 'ARCHIVED':
      return 'LOST';       // User archived = lead lost
    case 'DRAFT':
    case 'FAILED':
      return null;         // Don't create leads for drafts/failures
    default:
      return 'NEW';
  }
}
```

**Key Point**: RFP.leadStatus is nullable - only SENT RFPs become leads.

**Update Task 2**: Add status mapping logic to getLeads() method.

### Virtual Lead Model (LOW)

**Decision**: Lead is a **virtual model** (not a database table), aggregating data from RFP and VendorContact tables.

**Benefits**:
- No data duplication
- No sync issues between tables
- Flexible querying (filter by type, status, date)

**Implementation**:
```typescript
interface Lead {
  id: string;           // RFP.id or VendorContact.id
  type: 'PREMIUM' | 'BASIC';
  companyName: string;  // from Organization or VendorContact
  contactEmail: string; // from User or VendorContact
  submissionDate: Date; // RFP.sentAt or VendorContact.contactedAt
  status: LeadStatus;   // RFP.leadStatus or mapped from VendorContact
  // ... other aggregated fields
}
```

**Update Task 2**: Confirm virtual model approach (no new database table).

### References

- Architectural Decisions: `.ai/epic-13-architectural-decisions.md` (Section 6)
- Deep Analysis: `.ai/epic-13-deep-analysis-issues.md` (Issue #13)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-27 | 1.0 | Initial story creation for Epic 13: RFP System | Bob (Scrum Master) |
| 2025-10-27 | 1.1 | Added codebase review findings - confirmed lead service is new, papaparse exists | Claude (Dev Agent) |
| 2025-10-27 | 1.2 | Added architectural decisions - status enum clarification, virtual lead model | Claude (Dev Agent) |

## Dev Agent Record

### Agent Model Used
(To be populated by dev agent)

### Debug Log References
(To be populated by dev agent)

### Completion Notes List
(To be populated by dev agent)

### File List
(To be populated by dev agent)

## QA Results
(To be populated by QA agent)
