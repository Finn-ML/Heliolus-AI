# Story 13.1: Backend Revenue Analytics Service & API Endpoint

## Status
Draft

## Epic
Epic 13: Admin Revenue Reports - Backend Integration

## Story

**As an** admin user
**I want** to query real revenue data from the backend API
**So that** I can see accurate financial metrics for the platform

## Description

This story implements the core backend infrastructure for revenue analytics by extending the existing `AnalyticsService` with revenue-specific methods and adding a flexible API endpoint. The implementation focuses on accurate revenue calculations from the `Invoice` table, handling edge cases, and providing multiple views of revenue data (overview, trends, customers, breakdown).

**Key Challenge**: Revenue must be calculated ONLY from PAID invoices, with proper handling of edge cases (VOID, NULL paidAt, refunds). The system must correctly attribute revenue to organizations and normalize monthly/annual subscriptions for MRR/ARR calculations.

## Acceptance Criteria

### Revenue Calculation Logic
1. ✅ Only `Invoice` records with `status = 'PAID'` count toward revenue
2. ✅ Handles edge cases correctly:
   - VOID invoices excluded from revenue calculations
   - Invoices with NULL paidAt are excluded
   - Zero/negative amounts handled gracefully
3. ✅ Currency displayed as EUR (€) with proper formatting
4. ✅ MRR calculation normalizes ANNUAL subscriptions: `amount / 12`
5. ✅ ARR calculation normalizes MONTHLY subscriptions: `amount × 12`
6. ✅ Date range validation enforces max 1 year span (matches existing analytics pattern)

### API Endpoint
7. ✅ Route added: `GET /admin/analytics/revenue` in `backend/src/routes/admin.routes.ts`
8. ✅ Query parameters supported:
   - `view`: 'overview' | 'trends' | 'customers' | 'breakdown'
   - `startDate`: ISO date string (optional, defaults to 30 days ago)
   - `endDate`: ISO date string (optional, defaults to now)
   - `groupBy`: 'day' | 'week' | 'month' (for trends view)
   - `limit`: number (for customers view, default 10)
9. ✅ Admin auth middleware applied (only ADMIN role can access)
10. ✅ Returns proper `ApiResponse<RevenueAnalytics>` format

### View Types Implemented
11. ✅ **view=overview**: Returns summary metrics
    - totalRevenue (sum of PAID invoices)
    - mrr (Monthly Recurring Revenue)
    - arr (Annual Recurring Revenue)
    - avgMonthlyRevenue
    - totalCustomers (distinct organizations)
    - totalInvoices (count of PAID)
    - growth percentages (month-over-month, quarter-over-quarter)
12. ✅ **view=trends**: Returns time-series data
    - Array of {date, revenue, subscriptions, credits, invoiceCount}
    - Grouped by day/week/month based on groupBy param
    - Sorted chronologically
13. ✅ **view=customers**: Returns top customers by revenue
    - Array of {organizationId, organizationName, totalRevenue, invoiceCount, firstPurchase, lastPurchase, growth}
    - Ordered by totalRevenue DESC
    - Limited by limit param (default 10)
14. ✅ **view=breakdown**: Returns revenue categorization
    - byProduct: [{type, revenue, percentage}]
    - byPlan: [{plan, revenue, customerCount, percentage}]
    - byBillingCycle: [{cycle, revenue, percentage}]

### Data Accuracy
15. ✅ Customer revenue correctly JOINs: Invoice → Subscription → User → Organization
16. ✅ Growth percentages calculate correctly (current period vs previous period)
17. ✅ Handles empty data gracefully (returns zeros, not errors)
18. ✅ Handles missing Organization (shows "Unknown Organization")

### Performance & Error Handling
19. ✅ Response time < 500ms for 1000+ invoices
20. ✅ Uses existing database indexes (no new migrations required)
21. ✅ Error responses match existing analytics pattern (proper status codes, messages)

## Tasks / Subtasks

- [ ] Task 1: Add TypeScript Interfaces (AC: 10)
  - [ ] Add interfaces to `backend/src/services/analytics.service.ts`
  - [ ] `RevenueAnalyticsParams` interface (view, startDate, endDate, groupBy, limit)
  - [ ] `RevenueOverview` interface (totalRevenue, mrr, arr, growth, etc.)
  - [ ] `RevenueTrend` interface (date, revenue, subscriptions, credits, invoiceCount)
  - [ ] `CustomerRevenue` interface (organizationId, name, totalRevenue, growth, etc.)
  - [ ] `RevenueBreakdown` interface (byProduct, byPlan, byBillingCycle)
  - [ ] `RevenueAnalytics` union type (overview | trends | customers | breakdown)

- [ ] Task 2: Implement getRevenueAnalytics Method - Overview (AC: 1-6, 11)
  - [ ] Add method to AnalyticsService class
  - [ ] Add admin permission check: `this.requirePermission(context, [UserRole.ADMIN])`
  - [ ] Parse and validate date range (default: last 30 days)
  - [ ] Enforce max 1 year range validation
  - [ ] Query total PAID invoice revenue: `SUM(amount) WHERE status='PAID'`
  - [ ] Query invoice count and distinct customer count
  - [ ] Calculate MRR from current period subscriptions
  - [ ] Calculate ARR from MRR
  - [ ] Calculate avgMonthlyRevenue (total / months in range)
  - [ ] Calculate growth percentages (compare to previous period)
  - [ ] Return overview object

- [ ] Task 3: Implement Revenue Trends Query (AC: 12)
  - [ ] Add trends view logic with DATE_TRUNC grouping
  - [ ] Use raw SQL with Prisma for efficient aggregation:
    ```sql
    SELECT
      DATE_TRUNC($groupBy, paidAt)::date as date,
      SUM(amount) as revenue,
      COUNT(*) as invoice_count
    FROM Invoice
    WHERE status = 'PAID'
      AND paidAt >= $startDate
      AND paidAt <= $endDate
    GROUP BY DATE_TRUNC($groupBy, paidAt)
    ORDER BY date ASC
    ```
  - [ ] Handle groupBy parameter (day/week/month)
  - [ ] Format results as array of {date, revenue, invoiceCount}
  - [ ] Note: subscriptions/credits split requires invoice type classification (simplified in V1)

- [ ] Task 4: Implement Top Customers Query (AC: 13, 15)
  - [ ] Add customers view logic with Organization JOIN
  - [ ] Use raw SQL for multi-table aggregation:
    ```sql
    SELECT
      o.id as organization_id,
      o.name as organization_name,
      SUM(i.amount) as total_revenue,
      COUNT(i.id) as invoice_count,
      MIN(i.paidAt) as first_purchase,
      MAX(i.paidAt) as last_purchase
    FROM Invoice i
    JOIN Subscription s ON i.subscriptionId = s.id
    JOIN User u ON s.userId = u.id
    LEFT JOIN Organization o ON u.id = o.userId
    WHERE i.status = 'PAID'
      AND i.paidAt >= $startDate
      AND i.paidAt <= $endDate
    GROUP BY o.id, o.name
    ORDER BY total_revenue DESC
    LIMIT $limit
    ```
  - [ ] Handle missing Organization (LEFT JOIN, show "Unknown Organization")
  - [ ] Calculate growth percentage (compare to previous period)
  - [ ] Return ordered array limited by limit param

- [ ] Task 5: Implement Revenue Breakdown Query (AC: 14)
  - [ ] Add breakdown view logic with plan/cycle grouping
  - [ ] Query revenue by plan: GROUP BY subscription.plan
  - [ ] Query revenue by billing cycle: GROUP BY subscription.billingCycle
  - [ ] Calculate percentages for each category
  - [ ] Note: byProduct (subscription vs credits) simplified in V1 (all treated as subscriptions)
  - [ ] Return breakdown object with all categories

- [ ] Task 6: Edge Case Handling (AC: 2, 17, 18)
  - [ ] Handle empty database (no invoices): Return zeros, not errors
  - [ ] Handle all DRAFT/OPEN invoices: totalRevenue = 0
  - [ ] Handle VOID invoices: Explicitly exclude in WHERE clause
  - [ ] Handle NULL paidAt: Add `AND paidAt IS NOT NULL` to all queries
  - [ ] Handle date range with no data: Return empty arrays
  - [ ] Handle missing Organization: Use COALESCE or LEFT JOIN
  - [ ] Add try-catch error handling around all queries
  - [ ] Use this.handleDatabaseError() for consistent error responses

- [ ] Task 7: Add API Route (AC: 7-10)
  - [ ] Open `backend/src/routes/admin.routes.ts`
  - [ ] Add route after existing analytics routes (around line 1395)
  - [ ] Define route: `server.get('/analytics/revenue', { ... })`
  - [ ] Add Swagger/OpenAPI schema documentation
  - [ ] Add query parameter validation schema (Zod or Fastify schema)
  - [ ] Apply admin auth middleware (already applied at route level)
  - [ ] Call `analyticsService.getRevenueAnalytics(params, context)`
  - [ ] Return ApiResponse format: `{ success: true, data: result }`
  - [ ] Add error handling (return proper status codes)

- [ ] Task 8: MRR/ARR Calculation Logic (AC: 4, 5)
  - [ ] Query current period subscriptions (active only)
  - [ ] For each subscription, calculate monthly value:
    - MONTHLY: Use invoice amount directly
    - ANNUAL: Divide invoice amount by 12
  - [ ] Sum all monthly values = MRR
  - [ ] Multiply MRR by 12 = ARR
  - [ ] Handle edge case: No active subscriptions (MRR/ARR = 0)

- [ ] Task 9: Growth Calculation Helper (AC: 16)
  - [ ] Add private method: `calculateGrowth(current, previous)`
  - [ ] Formula: `((current - previous) / previous) * 100`
  - [ ] Handle division by zero: Return 100% if previous = 0 and current > 0
  - [ ] Handle both zero: Return 0%
  - [ ] Round to 2 decimal places

- [ ] Task 10: Testing & Validation (AC: 19-21)
  - [ ] Test with seed data from Story 13.0
  - [ ] Verify response times < 500ms with 1000+ invoices
  - [ ] Test all view types return correct data
  - [ ] Test date range filtering works
  - [ ] Test admin auth (non-admin gets 403)
  - [ ] Test empty database returns zeros
  - [ ] Test invalid date range returns error
  - [ ] Verify no new database indexes needed (use EXPLAIN ANALYZE)

## Testing Validation

```bash
# Prerequisites
cd backend
npm run db:seed:revenue  # Story 13.0 must be complete

# Start server
npm run dev

# Test API endpoints (using curl or Postman)

# 1. Test overview
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  "http://localhost:3001/v1/admin/analytics/revenue?view=overview"

# Expected response:
{
  "success": true,
  "data": {
    "overview": {
      "totalRevenue": 23960.00,
      "mrr": 2496.00,
      "arr": 29952.00,
      "avgMonthlyRevenue": 1996.67,
      "totalCustomers": 8,
      "totalInvoices": 40,
      "growth": {
        "lastMonth": 15.3,
        "lastQuarter": 45.2
      }
    }
  }
}

# 2. Test trends
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  "http://localhost:3001/v1/admin/analytics/revenue?view=trends&groupBy=month"

# Expected: Array of monthly revenue data

# 3. Test customers
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  "http://localhost:3001/v1/admin/analytics/revenue?view=customers&limit=5"

# Expected: Top 5 customers by revenue

# 4. Test breakdown
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  "http://localhost:3001/v1/admin/analytics/revenue?view=breakdown"

# Expected: Revenue categorized by plan/cycle

# 5. Test auth (should fail)
curl "http://localhost:3001/v1/admin/analytics/revenue?view=overview"
# Expected: 401 Unauthorized

# 6. Test date range
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  "http://localhost:3001/v1/admin/analytics/revenue?view=overview&startDate=2024-01-01&endDate=2024-03-31"

# Expected: Revenue for Q1 2024 only
```

## Dev Notes

**Primary File**: `backend/src/services/analytics.service.ts`
- Add method starting at line 1061 (after exportAnalytics method)
- Follow pattern from `getAssessmentMetrics()` (lines 141-290)
- Use `this.requirePermission()`, `this.createResponse()`, `this.handleDatabaseError()`

**Route File**: `backend/src/routes/admin.routes.ts`
- Add route starting at line 1395 (after existing analytics routes)
- Follow pattern from `/admin/analytics/assessments` route
- Import AnalyticsService dynamically (same as existing routes)

**SQL Performance**:
- All queries use existing indexes: `@@index([status])`, `@@index([paidAt])`
- DATE_TRUNC is efficient in PostgreSQL (indexed automatically)
- JOINs follow foreign key paths (fast lookups)
- No N+1 queries (use aggregation, not loops)

**Currency Formatting**:
```typescript
// Store in cents or euros?
// Schema uses Float for Invoice.amount → stores €599.00
// No conversion needed, display as-is

// Format for display (frontend handles this in Story 13.3)
const formatCurrency = (amount: number): string => {
  return `€${amount.toFixed(2)}`;
};
```

**MRR/ARR Formula**:
```typescript
// Example calculation
const subscriptions = [
  { plan: 'PREMIUM', billingCycle: 'MONTHLY', amount: 599 },   // €599/mo
  { plan: 'PREMIUM', billingCycle: 'ANNUAL', amount: 5388 },   // €449/mo (5388/12)
  { plan: 'ENTERPRISE', billingCycle: 'MONTHLY', amount: 1999 }, // €1999/mo
];

// MRR = 599 + 449 + 1999 = €3,047/month
// ARR = 3047 × 12 = €36,564/year
```

**Date Range Helper**:
```typescript
// Default date range (30 days)
const endDate = params.endDate ? new Date(params.endDate) : new Date();
const startDate = params.startDate
  ? new Date(params.startDate)
  : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

// Validate max 1 year
const daysDiff = Math.abs(endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);
if (daysDiff > 365) {
  throw this.createError('Date range cannot exceed 1 year', 400, 'INVALID_DATE_RANGE');
}
```

## Related Files
- `backend/src/services/analytics.service.ts` - Add getRevenueAnalytics method
- `backend/src/routes/admin.routes.ts` - Add /analytics/revenue route
- `backend/src/types/database.ts` - Type definitions (already exists)
- `backend/prisma/schema.prisma` - Invoice model (reference only)

## Dependencies
- Story 13.0 must be complete (seed data required for testing)
- Existing AnalyticsService must be functional
- Admin auth middleware must be working

## Estimated Effort
**Story Points**: 8
**Time Estimate**: 6-8 hours

## Definition of Done
- [ ] All tasks completed and checked off
- [ ] All acceptance criteria verified
- [ ] TypeScript compilation passes (no errors)
- [ ] API endpoint returns correct data for all 4 views
- [ ] Revenue calculations validated against manual spreadsheet (±€1 tolerance)
- [ ] Admin auth works (403 for non-admin)
- [ ] Response times < 500ms (tested with 1000+ invoices)
- [ ] Empty database handled gracefully (returns zeros)
- [ ] Edge cases handled (VOID, NULL paidAt, missing Organization)
- [ ] Date range validation works (max 1 year)
- [ ] Code follows existing patterns (matches other analytics methods)
- [ ] Ready for Story 13.2 frontend integration
