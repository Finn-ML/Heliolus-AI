# Story 6.3: Implement Purchase Additional Assessment

## Status
Ready for Review

## Story
**As a** Premium user,
**I want** to purchase additional assessments for €299,
**so that** I can complete more assessments beyond my monthly allocation.

## Acceptance Criteria
1. Method `purchaseAdditionalAssessment(userId, stripePriceId)` created
2. Method validates user has PREMIUM or ENTERPRISE subscription
3. For successful payment (mocked for now):
   - Add 50 credits to `creditsBalance`
   - Increment `creditsPurchased` by 50
   - Create `CreditTransaction` record:
     - Type: PURCHASE
     - Amount: 50
     - Description: "Purchased additional assessment credits"
     - Metadata: `{ amount: 29900, stripePriceId }`
   - Return: `{ success: true, creditsAdded: 50 }`
4. If subscription not found, throw 404 error
5. All operations in single database transaction

## Tasks / Subtasks

- [ ] **Task 1: Add Validation Schema** (AC: 1)
  - [ ] Open `backend/src/services/subscription.service.ts`
  - [ ] After existing schemas (around line 55), add:
    ```typescript
    const PurchaseAdditionalAssessmentSchema = z.object({
      stripePriceId: z.string().min(1, 'Stripe price ID required'),
      stripePaymentMethodId: z.string().optional(),
    });
    ```

- [ ] **Task 2: Create purchaseAdditionalAssessment Method** (AC: 1, 2, 3, 4, 5)
  - [ ] Add method after createSubscription (after line 298):
    ```typescript
    /**
     * Purchase additional assessment credits
     * @param userId - User ID
     * @param data - Purchase data
     * @param context - Service context
     * @returns Purchase result with credits added
     */
    async purchaseAdditionalAssessment(
      userId: string,
      data: z.infer<typeof PurchaseAdditionalAssessmentSchema>,
      context?: ServiceContext
    ): Promise<ApiResponse<{ creditsAdded: number; newBalance: number }>> {
      try {
        const validatedData = await this.validateInput(
          PurchaseAdditionalAssessmentSchema,
          data
        );

        // Check permission
        this.requirePermission(context, [UserRole.USER, UserRole.ADMIN], userId);

        // Get subscription
        const subscription = await this.prisma.subscription.findUnique({
          where: { userId },
          select: {
            id: true,
            plan: true,
            creditsBalance: true,
            creditsPurchased: true,
          },
        });

        if (!subscription) {
          throw this.createError(
            'Subscription not found',
            404,
            'SUBSCRIPTION_NOT_FOUND'
          );
        }

        // Validate subscription tier (PREMIUM or ENTERPRISE)
        if (
          subscription.plan !== SubscriptionPlan.PREMIUM &&
          subscription.plan !== SubscriptionPlan.ENTERPRISE
        ) {
          throw this.createError(
            'Additional assessments available for Premium and Enterprise users only',
            403,
            'TIER_RESTRICTION'
          );
        }

        // TODO: In production, process real Stripe payment here
        // For now, assume payment succeeded

        const creditsToAdd = PRICING.ADDITIONAL_ASSESSMENT.creditsGranted; // 50 credits
        const newBalance = subscription.creditsBalance + creditsToAdd;
        const newCreditsPurchased = subscription.creditsPurchased + creditsToAdd;

        // Atomic transaction: update credits + create transaction record
        await this.prisma.$transaction(async (tx) => {
          // Update subscription credits
          await tx.subscription.update({
            where: { userId },
            data: {
              creditsBalance: newBalance,
              creditsPurchased: newCreditsPurchased,
            },
          });

          // Create credit transaction
          await tx.creditTransaction.create({
            data: {
              subscriptionId: subscription.id,
              type: TransactionType.PURCHASE,
              amount: creditsToAdd,
              balance: newBalance,
              description: 'Purchased additional assessment credits',
              metadata: {
                amount: PRICING.ADDITIONAL_ASSESSMENT.price,
                currency: PRICING.ADDITIONAL_ASSESSMENT.currency,
                stripePriceId: validatedData.stripePriceId,
                purchaseDate: this.now().toISOString(),
              },
            },
          });
        });

        await this.logAudit(
          {
            action: 'CREDITS_PURCHASED',
            entity: 'Subscription',
            entityId: subscription.id,
            newValues: {
              creditsAdded: creditsToAdd,
              newBalance,
              amount: PRICING.ADDITIONAL_ASSESSMENT.price / 100, // In euros
            },
          },
          context
        );

        this.logger.info('Additional assessment credits purchased', {
          userId,
          creditsAdded: creditsToAdd,
          newBalance,
        });

        return this.createResponse(
          true,
          {
            creditsAdded: creditsToAdd,
            newBalance,
          },
          `${creditsToAdd} credits added successfully`
        );
      } catch (error) {
        if (error.statusCode) throw error;
        this.handleDatabaseError(error, 'purchaseAdditionalAssessment');
      }
    }
    ```

- [ ] **Task 3: Import PRICING Constants** (AC: 3)
  - [ ] Ensure PRICING is imported or accessible (Story 6.1)
  - [ ] Reference: `PRICING.ADDITIONAL_ASSESSMENT.price` and `.creditsGranted`

- [ ] **Task 4: Add TODO Comments for Stripe Integration** (AC: 3)
  - [ ] Add comment before mock payment success:
    ```typescript
    // TODO: Integrate with Stripe Payment Intents
    // 1. Create PaymentIntent with amount: PRICING.ADDITIONAL_ASSESSMENT.price
    // 2. Confirm payment with stripePaymentMethodId
    // 3. Wait for payment success webhook
    // 4. Then proceed with credit allocation
    // For MVP: Assume payment succeeded (webhook will trigger this method)
    ```

- [ ] **Task 5: Write Unit Tests** (AC: 1-5)
  - [ ] Test file: `backend/tests/unit/purchase-additional-assessment.test.ts`
  - [ ] Test PREMIUM user can purchase (returns 50 credits)
  - [ ] Test ENTERPRISE user can purchase
  - [ ] Test FREE user cannot purchase (403 error)
  - [ ] Test non-existent subscription (404 error)
  - [ ] Test credits added to balance
  - [ ] Test creditsPurchased incremented
  - [ ] Test CreditTransaction created
  - [ ] Test transaction rollback on error
  - [ ] Run tests: `npm test`

## Dev Notes

### Credit Purchase Flow

**User Journey:**
1. User on Premium plan completes 2 assessments (uses 100 credits)
2. User wants to complete 3rd assessment
3. User clicks "Purchase Additional Assessment" (€299)
4. Frontend calls `/v1/subscription/purchase-assessment`
5. Backend creates Stripe PaymentIntent
6. User completes payment via Stripe Elements
7. Stripe webhook triggers credit allocation
8. User receives 50 credits
9. User can now complete 3rd assessment

**MVP Simplification:**
- Skip steps 5-7 (real Stripe integration)
- Directly allocate credits on method call
- Add TODO comments for future Stripe integration

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Additional Assessment Purchase]

---

### Pricing Reference

**Additional Assessment Cost:**
- Price: €299.00 (29,900 cents)
- Credits granted: 50
- Cost per credit: €5.98

**Why 50 Credits:**
- Assumption: Average assessment costs 50 credits
- Allows completion of 1 additional assessment
- Buffer for template cost variation

**Credit to Euro Conversion:**
```typescript
const priceInEuros = 299;
const creditsGranted = 50;
const costPerCredit = priceInEuros / creditsGranted; // €5.98 per credit
```

[Source: Story 6.1 - PRICING Constants]

---

### Transaction Atomicity

**Why Transaction Required:**
1. Update `subscription.creditsBalance`
2. Update `subscription.creditsPurchased`
3. Create `CreditTransaction` record
4. All must succeed or all rollback

**Race Condition Protection:**
```typescript
// BAD: Race condition possible
await prisma.subscription.update({ ... });
await prisma.creditTransaction.create({ ... }); // Could fail, leaving inconsistent state

// GOOD: Atomic transaction
await prisma.$transaction(async (tx) => {
  await tx.subscription.update({ ... });
  await tx.creditTransaction.create({ ... });
});
```

**Concurrent Purchases:**
- Two simultaneous purchases from same user
- Without transaction: Both might read old balance, both update incorrectly
- With transaction: Prisma handles locking, sequential execution

[Source: Story 5.6 - Transaction Atomicity]

---

### Tier Restriction Logic

**Who Can Purchase:**
- ✅ PREMIUM: Yes (pay per assessment beyond monthly allocation)
- ✅ ENTERPRISE: Yes (can purchase if credits run low, in addition to admin grants)
- ❌ FREE: No (must upgrade to Premium first)

**Error Response for FREE User:**
```json
{
  "success": false,
  "error": "Additional assessments available for Premium and Enterprise users only",
  "code": "TIER_RESTRICTION",
  "statusCode": 403
}
```

**Frontend Handling:**
- Show upgrade modal instead of purchase button for FREE users
- Premium users see "Purchase Additional Assessment" button
- Enterprise users see both (can purchase OR request admin grant)

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#User Tiers]

---

### CreditTransaction Metadata

**Purpose:**
- Store purchase details for audit trail
- Link to Stripe payment record
- Enable refund lookup

**Metadata Structure:**
```typescript
metadata: {
  amount: 29900,                      // Price in cents
  currency: 'eur',
  stripePriceId: 'price_xyz123',     // Stripe Price ID
  stripePaymentIntentId: 'pi_abc',   // (Future) Stripe PaymentIntent ID
  purchaseDate: '2025-10-23T15:30:00Z',
}
```

**Usage:**
```typescript
// Find all purchases for user
const purchases = await prisma.creditTransaction.findMany({
  where: {
    subscription: { userId },
    type: TransactionType.PURCHASE,
  },
  orderBy: { createdAt: 'desc' },
});

// Calculate total spent
const totalSpent = purchases.reduce((sum, tx) => {
  return sum + (tx.metadata.amount || 0);
}, 0) / 100; // Convert cents to euros
```

[Source: backend/prisma/schema.prisma#CreditTransaction]

---

### Future Stripe Integration

**Real Implementation (Post-MVP):**
```typescript
// 1. Create PaymentIntent
const paymentIntent = await stripe.paymentIntents.create({
  amount: PRICING.ADDITIONAL_ASSESSMENT.price,
  currency: 'eur',
  customer: subscription.stripeCustomerId,
  payment_method: validatedData.stripePaymentMethodId,
  confirm: true,
  metadata: {
    userId,
    subscriptionId: subscription.id,
    purpose: 'additional_assessment',
  },
});

// 2. Wait for webhook confirmation
// Method will be called BY webhook after payment succeeds

// 3. Then allocate credits (current logic)
```

**Webhook Handler:**
```typescript
// backend/src/routes/webhook.routes.ts
fastify.post('/stripe/webhook', async (request, reply) => {
  const event = stripe.webhooks.constructEvent(...);

  if (event.type === 'payment_intent.succeeded') {
    const userId = event.data.object.metadata.userId;
    await subscriptionService.purchaseAdditionalAssessment(userId, { ... });
  }
});
```

[Source: Stripe API documentation]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/unit/purchase-additional-assessment.test.ts`

**Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { SubscriptionService } from '../src/services/subscription.service';
import { PrismaClient, SubscriptionPlan } from '../src/generated/prisma';

describe('Purchase Additional Assessment', () => {
  let service: SubscriptionService;
  let prisma: PrismaClient;
  let premiumUserId: string;
  let freeUserId: string;
  let premiumSubscriptionId: string;

  beforeAll(async () => {
    service = new SubscriptionService();
    prisma = new PrismaClient();

    // Create PREMIUM user with subscription
    const premiumUser = await prisma.user.create({
      data: {
        email: 'premium@example.com',
        firstName: 'Premium',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.PREMIUM,
            creditsBalance: 50,
            creditsPurchased: 100,
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(),
          },
        },
      },
    });
    premiumUserId = premiumUser.id;

    const premiumSubscription = await prisma.subscription.findUnique({
      where: { userId: premiumUserId },
    });
    premiumSubscriptionId = premiumSubscription.id;

    // Create FREE user
    const freeUser = await prisma.user.create({
      data: {
        email: 'free@example.com',
        firstName: 'Free',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.FREE,
            creditsBalance: 0,
            creditsPurchased: 0,
            currentPeriodStart: new Date(),
            currentPeriodEnd: new Date(),
          },
        },
      },
    });
    freeUserId = freeUser.id;
  });

  afterAll(async () => {
    await prisma.user.delete({ where: { id: premiumUserId } });
    await prisma.user.delete({ where: { id: freeUserId } });
    await prisma.$disconnect();
  });

  it('should allow PREMIUM user to purchase additional credits', async () => {
    const response = await service.purchaseAdditionalAssessment(
      premiumUserId,
      { stripePriceId: 'price_test123' },
      { userId: premiumUserId, userRole: 'USER' }
    );

    expect(response.success).toBe(true);
    expect(response.data.creditsAdded).toBe(50);
    expect(response.data.newBalance).toBe(100); // 50 + 50
  });

  it('should update subscription credits balance', async () => {
    const subscription = await prisma.subscription.findUnique({
      where: { userId: premiumUserId },
    });

    expect(subscription.creditsBalance).toBe(100);
    expect(subscription.creditsPurchased).toBe(150); // 100 + 50
  });

  it('should create credit transaction record', async () => {
    const transactions = await prisma.creditTransaction.findMany({
      where: {
        subscriptionId: premiumSubscriptionId,
        type: TransactionType.PURCHASE,
      },
      orderBy: { createdAt: 'desc' },
      take: 1,
    });

    expect(transactions.length).toBe(1);
    expect(transactions[0].amount).toBe(50);
    expect(transactions[0].type).toBe('PURCHASE');
    expect(transactions[0].metadata.amount).toBe(29900);
  });

  it('should reject FREE user purchase', async () => {
    await expect(
      service.purchaseAdditionalAssessment(
        freeUserId,
        { stripePriceId: 'price_test123' },
        { userId: freeUserId, userRole: 'USER' }
      )
    ).rejects.toThrow('Additional assessments available for Premium and Enterprise users only');
  });

  it('should throw 404 for non-existent subscription', async () => {
    await expect(
      service.purchaseAdditionalAssessment(
        'nonexistent-user-id',
        { stripePriceId: 'price_test123' },
        { userId: 'nonexistent-user-id', userRole: 'USER' }
      )
    ).rejects.toThrow('Subscription not found');
  });

  it('should rollback on transaction failure', async () => {
    const balanceBefore = (
      await prisma.subscription.findUnique({ where: { userId: premiumUserId } })
    ).creditsBalance;

    // Simulate transaction failure by using invalid data
    try {
      await service.purchaseAdditionalAssessment(
        premiumUserId,
        { stripePriceId: null }, // Invalid
        { userId: premiumUserId, userRole: 'USER' }
      );
    } catch (error) {
      // Expected to fail
    }

    const balanceAfter = (
      await prisma.subscription.findUnique({ where: { userId: premiumUserId } })
    ).creditsBalance;

    // Balance should not change if transaction failed
    expect(balanceAfter).toBe(balanceBefore);
  });
});
```

[Source: architecture.md#Testing Strategy]

---

### File Locations
- **Service:** `backend/src/services/subscription.service.ts`
- **Insert Point:** After line 298 (after createSubscription method)
- **Test:** `backend/tests/unit/purchase-additional-assessment.test.ts`

---

### Dependencies
**Depends On:**
- Story 6.1: PRICING.ADDITIONAL_ASSESSMENT constants
- Existing: CreditTransaction model
- Existing: Subscription model with creditsBalance field

**Depended On By:**
- Story 7.5: Subscription API will expose this method as POST endpoint
- Future: Stripe webhook integration

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 6 | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
Claude Code (Sonnet 4.5) - Development Agent

### Completion Notes
**Implementation Date**: 2025-10-24

**Changes Made:**
1. ✅ Created PurchaseAdditionalAssessmentSchema validation
   - Requires stripePriceId
   - Optional stripePaymentMethodId for future integration

2. ✅ Implemented purchaseAdditionalAssessment() method:
   - Validates user has PREMIUM or ENTERPRISE subscription
   - Adds 50 credits for €299 (using PRICING.ADDITIONAL_ASSESSMENT constant)
   - Uses atomic Prisma transaction for data consistency
   - Creates CreditTransaction record with full metadata
   - Returns creditsAdded and newBalance

3. ✅ Tier restrictions enforced:
   - ✅ PREMIUM: Can purchase
   - ✅ ENTERPRISE: Can purchase
   - ❌ FREE: Throws 403 TIER_RESTRICTION error

4. ✅ Transaction atomicity:
   - Updates creditsBalance
   - Updates creditsPurchased
   - Creates CreditTransaction record
   - All in single database transaction

5. ✅ Comprehensive error handling:
   - 404 SUBSCRIPTION_NOT_FOUND for missing subscription
   - 403 TIER_RESTRICTION for FREE users
   - Validation errors for invalid input
   - Transaction rollback on any failure

6. ✅ Audit logging:
   - Action: CREDITS_PURCHASED
   - Includes creditsAdded, newBalance, amount (in euros)

7. ✅ TODO comments for future Stripe integration:
   - PaymentIntent creation
   - Payment confirmation
   - Webhook integration
   - Currently mocked for MVP

**Credit Purchase Details:**
- Price: €299.00 (29,900 cents)
- Credits granted: 50
- Cost per credit: ~€5.98
- Allows ~1 additional assessment completion

**All Acceptance Criteria Met:**
- [x] AC1: purchaseAdditionalAssessment() method created
- [x] AC2: Validates PREMIUM or ENTERPRISE subscription
- [x] AC3: Adds 50 credits, creates transaction with metadata
- [x] AC4: Throws 404 if subscription not found
- [x] AC5: All operations in single transaction

**Testing:**
- 60+ test cases across 9 test suites
- Tests for PREMIUM, ENTERPRISE, FREE users
- Error handling and rollback tests
- Authorization tests
- Audit logging verification
- Transaction atomicity tests

### File List
**Modified:**
- `backend/src/services/subscription.service.ts`
  - Lines 60-63: Added PurchaseAdditionalAssessmentSchema
  - Lines 408-532: Added purchaseAdditionalAssessment() method
  - Integrated with PRICING constant from Story 6.1

**Created:**
- `backend/tests/unit/purchase-additional-assessment.test.ts`
  - 60+ test cases
  - 9 comprehensive test suites
  - Full coverage of purchase functionality

---

## QA Results
_This section will be populated by the QA agent after story completion_
