# Story 11.1: Assessment Metrics Backend API

## Status
Draft

## Story

**As a** system
**I want** real-time assessment metrics aggregated from the database
**So that** admins can monitor assessment activity accurately

## Acceptance Criteria

1. New endpoint: `GET /v1/admin/analytics/assessments`
2. Returns aggregated metrics:
   ```typescript
   {
     total: number,           // All assessments ever created
     started: number,         // Status = IN_PROGRESS or COMPLETED
     completed: number,       // Status = COMPLETED
     inProgress: number,      // Status = IN_PROGRESS
     abandoned: number,       // Status = IN_PROGRESS AND updatedAt > 7 days ago
     completionRate: number,  // (completed / started) * 100
     avgCompletionTime: number, // Average minutes from createdAt to updatedAt for COMPLETED
     byStatus: {
       DRAFT: number,
       IN_PROGRESS: number,
       COMPLETED: number,
       FAILED: number
     },
     byTemplate: Array<{
       templateId: string,
       templateName: string,
       count: number,
       percentage: number
     }>,
     trend: Array<{
       date: string,        // YYYY-MM-DD
       started: number,
       completed: number,
       abandoned: number
     }>  // Last 30 days
   }
   ```
3. Query parameters supported:
   - `startDate`: Filter from date (ISO 8601)
   - `endDate`: Filter to date (ISO 8601)
   - `groupBy`: 'day' | 'week' | 'month' (default: 'day')
4. Efficient aggregation using Prisma:
   - Use `groupBy` for status counts
   - Use date functions for trend data
   - Join with Template for names
5. Response time < 1 second for 10,000+ assessments
6. Cache results for 5 minutes (metrics don't need real-time precision)

## Tasks / Subtasks

- [ ] Task 1: Create Analytics Service (AC: 1, 2)
  - [ ] Create new file: `backend/src/services/analytics.service.ts`
  - [ ] Extend BaseService class
  - [ ] Add constructor with Prisma client injection
  - [ ] Export AnalyticsService class

- [ ] Task 2: Implement Assessment Metrics Method (AC: 2, 4)
  - [ ] Add `getAssessmentMetrics` method to AnalyticsService
  - [ ] Query total assessments count (all statuses)
  - [ ] Query started assessments (IN_PROGRESS + COMPLETED)
  - [ ] Query completed assessments (COMPLETED status)
  - [ ] Query in-progress assessments (IN_PROGRESS status)
  - [ ] Calculate abandoned: IN_PROGRESS + updatedAt > 7 days ago
  - [ ] Calculate completion rate: (completed / started) * 100
  - [ ] Calculate avg completion time using raw SQL or date math
  - [ ] Use Prisma groupBy for byStatus counts
  - [ ] Join with AssessmentTemplate for byTemplate data
  - [ ] Calculate percentages for byTemplate
  - [ ] Generate trend data for last 30 days with date grouping

- [ ] Task 3: Add Date Range Filtering (AC: 3)
  - [ ] Accept startDate, endDate, groupBy parameters
  - [ ] Apply date filters to all queries
  - [ ] Default date range: last 30 days if not specified
  - [ ] Validate date range (max 1 year)
  - [ ] Group trend data by day/week/month based on groupBy param

- [ ] Task 4: Add Analytics Route (AC: 1)
  - [ ] Add route to `backend/src/routes/admin.routes.ts`
  - [ ] `GET /admin/analytics/assessments`
  - [ ] Add Zod schema for query params validation
  - [ ] Require ADMIN role via middleware
  - [ ] Call AnalyticsService.getAssessmentMetrics
  - [ ] Return formatted response

- [ ] Task 5: Implement Caching (AC: 6)
  - [ ] Add Redis cache wrapper in analytics.service.ts
  - [ ] Cache key: `analytics:assessments:{startDate}:{endDate}:{groupBy}`
  - [ ] TTL: 300 seconds (5 minutes)
  - [ ] Check cache before querying database
  - [ ] Store result in cache after query

- [ ] Task 6: Optimize Performance (AC: 5)
  - [ ] Add database indexes: Assessment(status, createdAt, updatedAt)
  - [ ] Test with 10,000+ assessment records
  - [ ] Verify response time < 1 second
  - [ ] Use EXPLAIN ANALYZE to check query plans
  - [ ] Consider materialized view if needed

- [ ] Task 7: Testing (All AC)
  - [ ] Unit test: getAssessmentMetrics with mock data
  - [ ] Test date range filtering
  - [ ] Test groupBy variations (day, week, month)
  - [ ] Integration test: GET /admin/analytics/assessments
  - [ ] Performance test: 10,000 assessments
  - [ ] Test cache hit/miss scenarios

## Dev Notes

### Assessment Model Context
[Source: backend/prisma/schema.prisma - Assessment model]
```prisma
model Assessment {
  id              String            @id @default(cuid())
  userId          String
  organizationId  String
  templateId      String
  status          AssessmentStatus  @default(DRAFT)

  // Timestamps for completion tracking
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  completedAt     DateTime?

  // Relations
  user            User              @relation(fields: [userId], references: [id])
  organization    Organization      @relation(fields: [organizationId], references: [id])
  template        AssessmentTemplate @relation(fields: [templateId], references: [id])
  answers         Answer[]
  gaps            Gap[]
  risks           Risk[]

  @@index([status])
  @@index([createdAt])
  @@index([userId])
  @@index([organizationId])
}

enum AssessmentStatus {
  DRAFT
  IN_PROGRESS
  COMPLETED
  FAILED
}
```

### Service Architecture Pattern
[Source: docs/architecture.md:72-90]
- Extend BaseService for common functionality
- Constructor dependency injection
- Async/await error handling with try/catch
- Use `handleDatabaseError` for consistent error responses

### Efficient Aggregation Queries

**Total and Status Counts** (Single query with groupBy):
```typescript
const statusCounts = await this.prisma.assessment.groupBy({
  by: ['status'],
  where: dateFilter,
  _count: true
});

const byStatus = {
  DRAFT: statusCounts.find(s => s.status === 'DRAFT')?._count || 0,
  IN_PROGRESS: statusCounts.find(s => s.status === 'IN_PROGRESS')?._count || 0,
  COMPLETED: statusCounts.find(s => s.status === 'COMPLETED')?._count || 0,
  FAILED: statusCounts.find(s => s.status === 'FAILED')?._count || 0
};

const total = Object.values(byStatus).reduce((sum, count) => sum + count, 0);
const started = byStatus.IN_PROGRESS + byStatus.COMPLETED;
const completed = byStatus.COMPLETED;
const inProgress = byStatus.IN_PROGRESS;
```

**Abandoned Assessments** (Date calculation):
```typescript
const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

const abandoned = await this.prisma.assessment.count({
  where: {
    status: AssessmentStatus.IN_PROGRESS,
    updatedAt: { lt: sevenDaysAgo },
    ...dateFilter
  }
});
```

**Average Completion Time** (Using Prisma raw SQL):
```typescript
const avgTime = await this.prisma.$queryRaw<[{ avg_minutes: number }]>`
  SELECT AVG(EXTRACT(EPOCH FROM (updated_at - created_at)) / 60) as avg_minutes
  FROM "Assessment"
  WHERE status = 'COMPLETED'
  ${startDate ? Prisma.sql`AND created_at >= ${startDate}` : Prisma.empty}
  ${endDate ? Prisma.sql`AND created_at <= ${endDate}` : Prisma.empty}
`;

const avgCompletionTime = Math.round(avgTime[0]?.avg_minutes || 0);
```

**Template Distribution** (Join with groupBy):
```typescript
const byTemplate = await this.prisma.assessment.groupBy({
  by: ['templateId'],
  where: dateFilter,
  _count: true
});

// Fetch template names
const templateIds = byTemplate.map(t => t.templateId);
const templates = await this.prisma.assessmentTemplate.findMany({
  where: { id: { in: templateIds } },
  select: { id: true, name: true }
});

const total = byTemplate.reduce((sum, t) => sum + t._count, 0);

const byTemplateWithNames = byTemplate.map(t => {
  const template = templates.find(tpl => tpl.id === t.templateId);
  return {
    templateId: t.templateId,
    templateName: template?.name || 'Unknown',
    count: t._count,
    percentage: Math.round((t._count / total) * 100)
  };
});
```

**Trend Data** (Date truncation and grouping):
```typescript
// PostgreSQL date_trunc function
const trend = await this.prisma.$queryRaw<Array<{
  date: string;
  started: number;
  completed: number;
  abandoned: number;
}>>`
  SELECT
    DATE_TRUNC(${groupBy}, created_at)::date as date,
    COUNT(*) FILTER (WHERE status IN ('IN_PROGRESS', 'COMPLETED')) as started,
    COUNT(*) FILTER (WHERE status = 'COMPLETED') as completed,
    COUNT(*) FILTER (
      WHERE status = 'IN_PROGRESS'
      AND updated_at < NOW() - INTERVAL '7 days'
    ) as abandoned
  FROM "Assessment"
  WHERE created_at >= ${startDate}
    AND created_at <= ${endDate}
  GROUP BY DATE_TRUNC(${groupBy}, created_at)
  ORDER BY date ASC
`;
```

### Redis Caching Pattern
[Source: CLAUDE.md - Redis usage]
```typescript
import { redis } from '../config/redis';

async getAssessmentMetrics(params) {
  const cacheKey = `analytics:assessments:${params.startDate}:${params.endDate}:${params.groupBy}`;

  // Check cache
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }

  // Query database
  const metrics = await this.calculateMetrics(params);

  // Store in cache (5 minutes TTL)
  await redis.setex(cacheKey, 300, JSON.stringify(metrics));

  return metrics;
}
```

### File Locations

**New Files**:
- `backend/src/services/analytics.service.ts` - New analytics service

**Modified Files**:
- `backend/src/routes/admin.routes.ts` - Add analytics endpoints
- `backend/src/services/index.ts` - Export AnalyticsService
- `backend/prisma/schema.prisma` - Add indexes (if needed)

### Database Indexes for Performance

Add these indexes to optimize queries:
```prisma
model Assessment {
  // ... existing fields

  @@index([status, createdAt])
  @@index([status, updatedAt])
  @@index([templateId, status])
}
```

### Error Handling

```typescript
async getAssessmentMetrics(params: AnalyticsParams): Promise<ApiResponse<AssessmentMetrics>> {
  try {
    // Validate date range
    if (params.startDate && params.endDate) {
      const daysDiff = Math.abs(
        new Date(params.endDate).getTime() - new Date(params.startDate).getTime()
      ) / (1000 * 60 * 60 * 24);

      if (daysDiff > 365) {
        return this.createResponse(false, null, 'Date range cannot exceed 1 year', 400);
      }
    }

    // Calculate metrics
    const metrics = await this.calculateMetrics(params);

    return this.createResponse(true, metrics);
  } catch (error) {
    this.handleDatabaseError(error, 'getAssessmentMetrics');
  }
}
```

### Testing Standards
[Source: CLAUDE.md:251-263]
- Framework: Vitest 3
- Test Location: backend/tests/integration/
- Pattern: Arrange-Act-Assert
- Mock Prisma for unit tests, use test DB for integration

**Test Cases**:
```typescript
describe('AnalyticsService - getAssessmentMetrics', () => {
  it('should return correct total count', async () => {
    // Seed 100 assessments
    const result = await analyticsService.getAssessmentMetrics({});
    expect(result.data.total).toBe(100);
  });

  it('should calculate completion rate correctly', async () => {
    // Seed: 10 completed, 5 in-progress, 5 draft
    const result = await analyticsService.getAssessmentMetrics({});
    expect(result.data.completionRate).toBe(66.67); // 10 / 15 * 100
  });

  it('should identify abandoned assessments', async () => {
    // Seed assessment with updatedAt = 10 days ago
    const result = await analyticsService.getAssessmentMetrics({});
    expect(result.data.abandoned).toBeGreaterThan(0);
  });

  it('should filter by date range', async () => {
    const result = await analyticsService.getAssessmentMetrics({
      startDate: '2024-01-01',
      endDate: '2024-01-31'
    });
    // Verify only January assessments counted
  });

  it('should group trend by week', async () => {
    const result = await analyticsService.getAssessmentMetrics({
      groupBy: 'week'
    });
    expect(result.data.trend[0].date).toMatch(/\d{4}-\d{2}-\d{2}/);
  });
});
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created - Assessment metrics backend API | Bob (Scrum Master) |

---

## Dev Agent Record
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
