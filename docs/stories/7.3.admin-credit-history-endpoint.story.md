# Story 7.3: Create Admin Credit History Endpoint

## Status
Draft

## Story
**As a** system administrator,
**I want** to view credit transaction history for users,
**so that** I can audit Enterprise credit allocations.

## Acceptance Criteria
1. New endpoint: `GET /v1/admin/users/:userId/credits`
2. Route protected by: `[authMiddleware, rbacMiddleware(['ADMIN'])]`
3. Request schema validation:
   ```typescript
   params: z.object({ userId: z.string() })
   ```
4. Endpoint calls: `adminCreditService.getUserCreditHistory(userId)`
5. Success response (200):
   ```json
   {
     "success": true,
     "data": [
       {
         "id": "...",
         "type": "ADMIN_GRANT",
         "amount": 50,
         "balance": 150,
         "description": "Monthly allocation",
         "createdAt": "2025-10-23T...",
         "metadata": { ... }
       }
     ]
   }
   ```
6. Transactions sorted by `createdAt` descending (most recent first)
7. Error responses:
   - 403 if non-admin
   - 404 if user not found

## Tasks / Subtasks

- [ ] **Task 1: Define Request/Response Schemas** (AC: 3, 5, 6)
  - [ ] Add Zod schema for params:
    ```typescript
    const GetCreditHistoryParamsSchema = z.object({
      userId: z.string().cuid('Invalid user ID format'),
    });
    ```
  - [ ] Add Fastify response schema:
    ```typescript
    const GetCreditHistoryResponseSchema = {
      200: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          data: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                id: { type: 'string' },
                subscriptionId: { type: 'string' },
                type: { type: 'string' },
                amount: { type: 'number' },
                balance: { type: 'number' },
                description: { type: 'string' },
                metadata: { type: 'object' },
                assessmentId: { type: 'string', nullable: true },
                createdAt: { type: 'string' },
              },
            },
          },
        },
      },
      403: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          message: { type: 'string' },
          code: { type: 'string' },
        },
      },
      404: {
        type: 'object',
        properties: {
          success: { type: 'boolean' },
          message: { type: 'string' },
          code: { type: 'string' },
        },
      },
    };
    ```

- [ ] **Task 2: Create GET /admin/users/:userId/credits Endpoint** (AC: 1, 2, 4, 5)
  - [ ] Open `backend/src/routes/admin.routes.ts`
  - [ ] Add endpoint definition:
    ```typescript
    server.get('/users/:userId/credits', {
      schema: {
        description: 'Get credit transaction history for user (admin only)',
        tags: ['Admin'],
        params: GetCreditHistoryParamsSchema,
        response: GetCreditHistoryResponseSchema,
      },
      preHandler: requireRole(UserRole.ADMIN),
    }, asyncHandler(async (request, reply) => {
      // Implementation in next task
    }));
    ```
  - [ ] Note: authenticationMiddleware already applied via addHook

- [ ] **Task 3: Implement Endpoint Handler Logic** (AC: 4, 5, 6)
  - [ ] Parse validated request:
    ```typescript
    const { userId } = request.params as z.infer<typeof GetCreditHistoryParamsSchema>;
    ```
  - [ ] Call AdminCreditService:
    ```typescript
    const adminCreditService = new AdminCreditService();
    const transactions = await adminCreditService.getUserCreditHistory(userId);
    ```
  - [ ] Return success response (service already sorts by createdAt DESC):
    ```typescript
    reply.status(200).send({
      success: true,
      data: transactions,
    });
    ```

- [ ] **Task 4: Add Error Handling** (AC: 7)
  - [ ] Wrap handler in try-catch:
    ```typescript
    try {
      const transactions = await adminCreditService.getUserCreditHistory(userId);
      reply.status(200).send({ success: true, data: transactions });
    } catch (error: any) {
      request.log.error({ error, userId }, 'Failed to get credit history');

      if (error.code === 'SUBSCRIPTION_NOT_FOUND') {
        return reply.status(404).send({
          success: false,
          message: error.message || 'User subscription not found',
          code: 'SUBSCRIPTION_NOT_FOUND',
        });
      }

      // Let error middleware handle others
      throw error;
    }
    ```
  - [ ] Note: requireRole middleware already handles 403 for non-admins

- [ ] **Task 5: Add JSDoc Documentation** (AC: 1, 4)
  - [ ] Add comment above endpoint:
    ```typescript
    /**
     * Get Credit Transaction History (Admin Only)
     *
     * GET /v1/admin/users/:userId/credits
     *
     * Retrieves all credit transactions for a user in reverse chronological order.
     * Used for auditing Enterprise credit allocations, purchases, and usage.
     *
     * @requires ADMIN role
     * @param userId - User ID (path parameter)
     * @returns Array of CreditTransaction records, newest first
     *
     * @see Story 5.5 - AdminCreditService.getUserCreditHistory()
     * @see Story 7.2 - Grant credits endpoint (creates records shown here)
     */
    ```

- [ ] **Task 6: Write Integration Test** (AC: 1-7)
  - [ ] Create test file: `backend/tests/integration/admin-credit-history-endpoint.test.ts`
  - [ ] Test successful retrieval (200) with multiple transactions
  - [ ] Test transactions sorted by createdAt descending
  - [ ] Test includes all transaction types (ADMIN_GRANT, ASSESSMENT, etc.)
  - [ ] Test non-admin gets 403 Forbidden
  - [ ] Test nonexistent user gets 404 Not Found
  - [ ] Test empty history returns empty array (not error)
  - [ ] Run tests: `npm test`

- [ ] **Task 7: Update OpenAPI/Swagger Documentation** (AC: 1)
  - [ ] Verify Swagger UI includes new endpoint at `/documentation`
  - [ ] Verify "Admin" tag grouping with other admin endpoints
  - [ ] Verify example response shows transaction array

## Dev Notes

### Endpoint Purpose
This endpoint allows administrators to:
- Audit all credit transactions for a user
- Verify ADMIN_GRANT operations were executed correctly
- Track credit usage history (ASSESSMENT debits)
- Review subscription purchases and refunds
- Generate billing reports and reconciliation

Returns all transaction types: ADMIN_GRANT, SUBSCRIPTION, PURCHASE, ASSESSMENT, REFUND

[Source: docs/prd/epic-7-api-endpoints.md#Story 3.3]

---

### AdminCreditService Integration

**Service Method (from Story 5.5):**
```typescript
async getUserCreditHistory(userId: string): Promise<CreditTransaction[]>
```

**What Service Does:**
1. Queries subscription by userId (throws 404 if not found)
2. Queries all CreditTransaction records for subscriptionId
3. Orders by createdAt DESC (most recent first)
4. Returns transaction array

**Important:** Service returns transactions for ALL types, not just ADMIN_GRANT:
- SUBSCRIPTION: Monthly/annual subscription credit allocation
- PURCHASE: Additional assessment purchases
- ASSESSMENT: Credits deducted for assessment completion
- ADMIN_GRANT: Manual admin credit grants
- REFUND: Credit refunds/corrections

[Source: docs/stories/5.5.admin-credit-service.story.md#getUserCreditHistory]

---

### Response Structure

**Successful Response (200):**
```json
{
  "success": true,
  "data": [
    {
      "id": "ctx_cm123abc",
      "subscriptionId": "sub_cm456def",
      "type": "ADMIN_GRANT",
      "amount": 100,
      "balance": 250,
      "description": "Q1 2025 Enterprise allocation",
      "metadata": {
        "grantedBy": "admin_cm789ghi",
        "grantReason": "Q1 2025 Enterprise allocation",
        "grantedAt": "2025-10-23T10:30:00.000Z"
      },
      "assessmentId": null,
      "createdAt": "2025-10-23T10:30:00.000Z"
    },
    {
      "id": "ctx_cm124bcd",
      "subscriptionId": "sub_cm456def",
      "type": "ASSESSMENT",
      "amount": -50,
      "balance": 150,
      "description": "Financial Crime Compliance assessment",
      "metadata": {
        "assessmentId": "asmt_cm890jkl",
        "templateName": "Financial Crime Compliance"
      },
      "assessmentId": "asmt_cm890jkl",
      "createdAt": "2025-10-22T15:20:00.000Z"
    },
    {
      "id": "ctx_cm125cde",
      "subscriptionId": "sub_cm456def",
      "type": "SUBSCRIPTION",
      "amount": 200,
      "balance": 200,
      "description": "October 2025 monthly credit allocation",
      "metadata": {
        "billingCycle": "MONTHLY",
        "periodStart": "2025-10-01",
        "periodEnd": "2025-11-01"
      },
      "assessmentId": null,
      "createdAt": "2025-10-01T00:00:00.000Z"
    }
  ]
}
```

**Transaction Order:** Newest first (createdAt DESC)

**Empty History (200):**
```json
{
  "success": true,
  "data": []
}
```

[Source: docs/prd/epic-7-api-endpoints.md#Story 3.3]

---

### CreditTransaction Model

**Location:** `backend/prisma/schema.prisma`

**Model Definition:**
```prisma
model CreditTransaction {
  id             String @id @default(cuid())
  subscriptionId String

  type    TransactionType  // ADMIN_GRANT, SUBSCRIPTION, PURCHASE, ASSESSMENT, REFUND
  amount  Int             // Positive = credit, Negative = debit
  balance Int             // Balance after this transaction

  description  String
  metadata     Json?       // Transaction-specific details
  assessmentId String?     // For ASSESSMENT transactions

  createdAt DateTime @default(now())

  subscription Subscription @relation(...)
  assessment   Assessment?  @relation(...)
}

enum TransactionType {
  SUBSCRIPTION  // Monthly/annual credit allocation
  PURCHASE      // Additional assessment purchase
  ASSESSMENT    // Credit deduction for assessment
  ADMIN_GRANT   // Manual admin grant
  REFUND        // Refund/correction
}
```

**Metadata Examples by Type:**

**ADMIN_GRANT:**
```json
{
  "grantedBy": "admin-user-id",
  "grantReason": "Reason text",
  "grantedAt": "ISO-8601"
}
```

**SUBSCRIPTION:**
```json
{
  "billingCycle": "MONTHLY",
  "periodStart": "2025-10-01",
  "periodEnd": "2025-11-01"
}
```

**ASSESSMENT:**
```json
{
  "assessmentId": "asmt_...",
  "templateName": "Template name"
}
```

**PURCHASE:**
```json
{
  "stripePriceId": "price_...",
  "creditsAdded": 50
}
```

[Source: backend/prisma/schema.prisma, docs/stories/5.5.admin-credit-service.story.md#CreditTransaction Model]

---

### RBAC Middleware Pattern

**Usage:**
```typescript
server.get('/users/:userId/credits', {
  schema: { ... },
  preHandler: requireRole(UserRole.ADMIN),  // RBAC check
}, asyncHandler(async (request, reply) => {
  // Handler logic
}));
```

**Execution Flow:**
1. authenticationMiddleware (addHook) - validates JWT
2. requireRole(UserRole.ADMIN) (preHandler) - checks role
3. Handler executes only if user is authenticated AND admin

**403 Response (Non-Admin):**
```json
{
  "success": false,
  "message": "Insufficient permissions",
  "code": "FORBIDDEN",
  "requiredRoles": ["ADMIN"],
  "userRole": "USER"
}
```

[Source: backend/src/middleware/rbac.middleware.ts:21-54]

---

### Error Handling

**Error Types:**

| Error Code | HTTP Status | Cause | Thrown By |
|------------|-------------|-------|-----------|
| FORBIDDEN | 403 | Non-admin attempts access | requireRole middleware |
| SUBSCRIPTION_NOT_FOUND | 404 | User subscription doesn't exist | AdminCreditService.getUserCreditHistory() |
| AUTH_REQUIRED | 401 | Missing/invalid JWT | authenticationMiddleware |

**Route Error Handler:**
```typescript
try {
  const transactions = await adminCreditService.getUserCreditHistory(userId);
  reply.status(200).send({ success: true, data: transactions });
} catch (error: any) {
  request.log.error({ error, userId }, 'Failed to get credit history');

  if (error.code === 'SUBSCRIPTION_NOT_FOUND') {
    return reply.status(404).send({
      success: false,
      message: error.message || 'User subscription not found',
      code: 'SUBSCRIPTION_NOT_FOUND',
    });
  }

  throw error;  // Let error middleware handle others
}
```

[Source: backend/src/services/base.service.ts#createError, docs/stories/5.5.admin-credit-service.story.md]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/integration/admin-credit-history-endpoint.test.ts`

**Test Structure:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { FastifyInstance } from 'fastify';
import { PrismaClient, SubscriptionPlan, UserRole, TransactionType } from '../src/generated/prisma';
import { buildServer } from '../src/server';

describe('Admin Credit History Endpoint', () => {
  let server: FastifyInstance;
  let prisma: PrismaClient;
  let adminToken: string;
  let regularUserToken: string;
  let targetUserId: string;

  beforeAll(async () => {
    server = await buildServer();
    prisma = new PrismaClient();

    // Create admin user
    const admin = await prisma.user.create({
      data: {
        email: 'admin@example.com',
        firstName: 'Admin',
        lastName: 'User',
        password: 'hashed',
        role: UserRole.ADMIN,
      },
    });

    const adminAuthResponse = await server.inject({
      method: 'POST',
      url: '/v1/auth/login',
      payload: { email: 'admin@example.com', password: 'hashed' },
    });
    adminToken = adminAuthResponse.json().token;

    // Create regular user
    const regularUser = await prisma.user.create({
      data: {
        email: 'user@example.com',
        firstName: 'Regular',
        lastName: 'User',
        password: 'hashed',
        role: UserRole.USER,
      },
    });

    const userAuthResponse = await server.inject({
      method: 'POST',
      url: '/v1/auth/login',
      payload: { email: 'user@example.com', password: 'hashed' },
    });
    regularUserToken = userAuthResponse.json().token;

    // Create target user with subscription and transaction history
    const targetUser = await prisma.user.create({
      data: {
        email: 'target@example.com',
        firstName: 'Target',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.ENTERPRISE,
            creditsBalance: 250,
            currentPeriodStart: new Date('2025-10-01'),
            currentPeriodEnd: new Date('2025-11-01'),
          },
        },
      },
      include: { subscription: true },
    });
    targetUserId = targetUser.id;

    // Create transaction history
    const subscription = targetUser.subscription!;

    // Transaction 1 (oldest): Monthly allocation
    await prisma.creditTransaction.create({
      data: {
        subscriptionId: subscription.id,
        type: TransactionType.SUBSCRIPTION,
        amount: 200,
        balance: 200,
        description: 'October 2025 monthly credit allocation',
        metadata: {
          billingCycle: 'MONTHLY',
          periodStart: '2025-10-01',
          periodEnd: '2025-11-01',
        },
        createdAt: new Date('2025-10-01T00:00:00.000Z'),
      },
    });

    // Transaction 2 (middle): Assessment deduction
    await prisma.creditTransaction.create({
      data: {
        subscriptionId: subscription.id,
        type: TransactionType.ASSESSMENT,
        amount: -50,
        balance: 150,
        description: 'Financial Crime Compliance assessment',
        metadata: {
          assessmentId: 'asmt_test123',
          templateName: 'Financial Crime Compliance',
        },
        createdAt: new Date('2025-10-15T10:30:00.000Z'),
      },
    });

    // Transaction 3 (newest): Admin grant
    await prisma.creditTransaction.create({
      data: {
        subscriptionId: subscription.id,
        type: TransactionType.ADMIN_GRANT,
        amount: 100,
        balance: 250,
        description: 'Q1 2025 Enterprise allocation',
        metadata: {
          grantedBy: admin.id,
          grantReason: 'Q1 2025 Enterprise allocation',
          grantedAt: new Date('2025-10-23T10:30:00.000Z').toISOString(),
        },
        createdAt: new Date('2025-10-23T10:30:00.000Z'),
      },
    });
  });

  afterAll(async () => {
    // Cleanup
    await prisma.user.deleteMany({
      where: {
        email: { in: ['admin@example.com', 'user@example.com', 'target@example.com'] },
      },
    });
    await prisma.$disconnect();
    await server.close();
  });

  describe('GET /v1/admin/users/:userId/credits', () => {
    it('should return transaction history when admin', async () => {
      const response = await server.inject({
        method: 'GET',
        url: `/v1/admin/users/${targetUserId}/credits`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      const body = response.json();
      expect(body.success).toBe(true);
      expect(body.data).toBeInstanceOf(Array);
      expect(body.data.length).toBe(3);
    });

    it('should return transactions in descending order (newest first)', async () => {
      const response = await server.inject({
        method: 'GET',
        url: `/v1/admin/users/${targetUserId}/credits`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      const body = response.json();
      const transactions = body.data;

      // First transaction should be newest (ADMIN_GRANT)
      expect(transactions[0].type).toBe('ADMIN_GRANT');
      expect(transactions[0].amount).toBe(100);

      // Second transaction should be middle (ASSESSMENT)
      expect(transactions[1].type).toBe('ASSESSMENT');
      expect(transactions[1].amount).toBe(-50);

      // Third transaction should be oldest (SUBSCRIPTION)
      expect(transactions[2].type).toBe('SUBSCRIPTION');
      expect(transactions[2].amount).toBe(200);

      // Verify timestamps are in descending order
      expect(new Date(transactions[0].createdAt).getTime())
        .toBeGreaterThan(new Date(transactions[1].createdAt).getTime());
      expect(new Date(transactions[1].createdAt).getTime())
        .toBeGreaterThan(new Date(transactions[2].createdAt).getTime());
    });

    it('should include metadata for each transaction', async () => {
      const response = await server.inject({
        method: 'GET',
        url: `/v1/admin/users/${targetUserId}/credits`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      const body = response.json();
      const adminGrant = body.data.find((tx: any) => tx.type === 'ADMIN_GRANT');

      expect(adminGrant.metadata).toBeDefined();
      expect(adminGrant.metadata.grantedBy).toBeDefined();
      expect(adminGrant.metadata.grantReason).toBe('Q1 2025 Enterprise allocation');
    });

    it('should return 403 when non-admin attempts access', async () => {
      const response = await server.inject({
        method: 'GET',
        url: `/v1/admin/users/${targetUserId}/credits`,
        headers: {
          authorization: `Bearer ${regularUserToken}`,
        },
      });

      expect(response.statusCode).toBe(403);
      expect(response.json().code).toBe('FORBIDDEN');
    });

    it('should return 404 when user not found', async () => {
      const response = await server.inject({
        method: 'GET',
        url: '/v1/admin/users/nonexistent-user/credits',
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(404);
      expect(response.json().code).toBe('SUBSCRIPTION_NOT_FOUND');
    });

    it('should return empty array when no transactions exist', async () => {
      // Create user with no transactions
      const emptyUser = await prisma.user.create({
        data: {
          email: 'empty@example.com',
          firstName: 'Empty',
          lastName: 'User',
          password: 'hashed',
          subscription: {
            create: {
              plan: SubscriptionPlan.FREE,
              creditsBalance: 0,
              currentPeriodStart: new Date(),
              currentPeriodEnd: new Date(),
            },
          },
        },
      });

      const response = await server.inject({
        method: 'GET',
        url: `/v1/admin/users/${emptyUser.id}/credits`,
        headers: {
          authorization: `Bearer ${adminToken}`,
        },
      });

      expect(response.statusCode).toBe(200);
      expect(response.json().data).toEqual([]);

      // Cleanup
      await prisma.user.delete({ where: { id: emptyUser.id } });
    });
  });
});
```

[Source: CLAUDE.md#Testing Infrastructure, docs/stories/5.5.admin-credit-service.story.md]

---

### File Locations
- **Route File:** `backend/src/routes/admin.routes.ts`
- **Service:** `backend/src/services/admin-credit.service.ts` (from Story 5.5)
- **Test:** `backend/tests/integration/admin-credit-history-endpoint.test.ts`

---

### Dependencies
**Depends On:**
- Story 5.5: AdminCreditService.getUserCreditHistory() must be implemented
- Existing: authenticationMiddleware, requireRole middleware

**Depended On By:**
- Story 8.x: Frontend admin UI will display credit history using this endpoint

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 7 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
_TBD_

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
