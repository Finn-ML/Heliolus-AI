# Story 12.3: Frontend Template Management Integration

## Status
Draft

## Story

**As a** platform administrator,
**I want** the template management UI connected to real backend APIs with proper loading states, error handling, and optimistic updates,
**so that** I can create, edit, and delete templates through the admin panel with a responsive user experience.

## Acceptance Criteria

1. **API Client Methods** - Add to `frontend/src/lib/api.ts`
   - `adminTemplateApi.createTemplate(data)` - POST /admin/templates
   - `adminTemplateApi.updateTemplate(id, data)` - PUT /admin/templates/:id
   - `adminTemplateApi.deleteTemplate(id)` - DELETE /admin/templates/:id
   - `adminTemplateApi.getTemplateStats()` - GET /admin/templates/stats
   - `adminTemplateApi.createSection(templateId, data)` - POST /admin/templates/:templateId/sections
   - `adminTemplateApi.updateSection(id, data)` - PUT /admin/sections/:id
   - `adminTemplateApi.deleteSection(id)` - DELETE /admin/sections/:id
   - `adminTemplateApi.createQuestion(sectionId, data)` - POST /admin/sections/:sectionId/questions
   - `adminTemplateApi.updateQuestion(id, data)` - PUT /admin/questions/:id
   - `adminTemplateApi.deleteQuestion(id)` - DELETE /admin/questions/:id
   - `adminTemplateApi.bulkCreateQuestions(sectionId, questions)` - POST /admin/sections/:sectionId/questions/bulk
   - All methods use `/v1/admin` prefix (authenticated routes)

2. **TanStack Query Hooks** - Create `frontend/src/hooks/useAdminTemplates.ts`
   - `useTemplates()` - Fetch templates list with caching
   - `useTemplate(id)` - Fetch single template with sections/questions
   - `useTemplateStats()` - Fetch template statistics
   - `useCreateTemplate()` - Mutation for template creation with optimistic update
   - `useUpdateTemplate()` - Mutation for template updates with optimistic update
   - `useDeleteTemplate()` - Mutation for template deletion with optimistic update
   - `useCreateSection()` - Mutation for section creation
   - `useUpdateSection()` - Mutation for section updates
   - `useDeleteSection()` - Mutation for section deletion
   - `useCreateQuestion()` - Mutation for question creation
   - `useUpdateQuestion()` - Mutation for question updates
   - `useDeleteQuestion()` - Mutation for question deletion
   - `useBulkCreateQuestions()` - Mutation for bulk question creation
   - All mutations invalidate relevant queries on success

3. **Replace Mock Data** - Update `frontend/src/pages/admin/TemplateManagement.tsx`
   - Remove `mockTemplates` state and data
   - Replace with `useTemplates()` hook for data fetching
   - Connect template creation dialog to `useCreateTemplate()` mutation
   - Connect template edit dialog to `useUpdateTemplate()` mutation
   - Connect delete actions to `useDeleteTemplate()` mutation
   - Connect section/question CRUD operations to respective mutations
   - Remove local state management (sections, questions) in favor of server state

4. **Loading States**
   - Show skeleton loaders while templates are fetching
   - Disable form submit buttons during mutations
   - Show loading spinner on dialog submit buttons
   - Display "Saving..." text during mutations
   - Prevent dialog close during pending mutations

5. **Error Handling**
   - Display toast notifications for mutation errors
   - Show specific error messages (e.g., "Template slug already exists")
   - Handle 403 Forbidden errors (non-admin users)
   - Handle 400 validation errors with field-specific messages
   - Handle network errors with retry option
   - Show error state in template list if fetch fails

6. **Optimistic Updates**
   - Template creation: Immediately add to list with "saving" indicator
   - Template update: Immediately update in list before server confirmation
   - Template delete: Immediately remove from list, rollback if error
   - Section/question mutations: Update template detail view optimistically
   - All optimistic updates rollback on error

7. **Status Toggle** - Connect template status (draft/active/archived)
   - Add status dropdown to template edit dialog
   - Update template.isActive field via `updateTemplate` mutation
   - Display status badge with correct styling (active=green, draft=yellow, archived=gray)
   - Disable status change to "active" if template has no sections/questions

8. **Credit Cost Configuration** - Connect credit cost input
   - Add credit cost number input to template create/edit dialog
   - Validate credit cost >= 0
   - Update template.creditCost field via mutations
   - Display credit cost in template list card

## Tasks / Subtasks

- [ ] Task 1: Create Admin Template API Client (AC: 1)
  - [ ] Add `adminTemplateApi` object to `frontend/src/lib/api.ts`
  - [ ] Implement all 11 API methods using `apiRequest` helper
  - [ ] Use `/v1/admin` prefix for all endpoints (authenticated routes)
  - [ ] Add TypeScript interfaces for request/response types
  - [ ] Handle FormData for file uploads (if needed for future stories)
  - [ ] Add proper error types matching backend error codes

- [ ] Task 2: Create TanStack Query Hooks File (AC: 2)
  - [ ] Create new file: `frontend/src/hooks/useAdminTemplates.ts`
  - [ ] Import adminTemplateApi and TanStack Query utilities
  - [ ] Define query keys constant: `adminTemplateKeys`
  - [ ] Implement 3 query hooks (useTemplates, useTemplate, useTemplateStats)
  - [ ] Implement 10 mutation hooks with optimistic updates
  - [ ] Configure cache invalidation on mutation success
  - [ ] Add TypeScript types for all hook return values

- [ ] Task 3: Implement Query Hooks (AC: 2, 4, 5)
  - [ ] `useTemplates()` - query key: ['adminTemplates'], stale time: 5 min
  - [ ] `useTemplate(id)` - query key: ['adminTemplate', id], enabled when id provided
  - [ ] `useTemplateStats()` - query key: ['adminTemplateStats'], stale time: 5 min
  - [ ] Add loading states: isLoading, isError, error properties
  - [ ] Add retry logic: retry 3 times on failure
  - [ ] Add refetch on window focus: enabled

- [ ] Task 4: Implement Mutation Hooks with Optimistic Updates (AC: 2, 6)
  - [ ] `useCreateTemplate()` - invalidates ['adminTemplates'] on success
  - [ ] `useUpdateTemplate()` - optimistic update to query cache, rollback on error
  - [ ] `useDeleteTemplate()` - optimistic removal, rollback on error
  - [ ] `useCreateSection()` - optimistic add to template sections array
  - [ ] `useUpdateSection()` - optimistic update in template cache
  - [ ] `useDeleteSection()` - optimistic removal from template cache
  - [ ] `useCreateQuestion()` - optimistic add to section questions array
  - [ ] `useUpdateQuestion()` - optimistic update in section cache
  - [ ] `useDeleteQuestion()` - optimistic removal from section cache
  - [ ] `useBulkCreateQuestions()` - optimistic add multiple questions
  - [ ] All mutations expose: mutate, mutateAsync, isPending, isError, error

- [ ] Task 5: Replace Mock Data in TemplateManagement.tsx (AC: 3, 7, 8)
  - [ ] Remove `mockTemplates` array and `useState` for templates
  - [ ] Import and use `useTemplates()` hook
  - [ ] Import and use all mutation hooks
  - [ ] Replace `handleAddTemplate` with `createTemplate.mutate()`
  - [ ] Replace `handleDeleteTemplate` with `deleteTemplate.mutate()`
  - [ ] Connect template edit dialog to `updateTemplate.mutate()`
  - [ ] Connect status dropdown to update template.isActive
  - [ ] Connect credit cost input to update template.creditCost
  - [ ] Remove local state for editingTemplate, use query data instead

- [ ] Task 6: Add Loading States (AC: 4)
  - [ ] Show `Skeleton` components while `useTemplates().isLoading`
  - [ ] Disable submit buttons when `mutation.isPending`
  - [ ] Add loading spinner to dialog submit buttons
  - [ ] Change button text to "Saving..." during mutations
  - [ ] Prevent dialog close when mutation is pending
  - [ ] Show global loading bar (optional) for page-level operations

- [ ] Task 7: Implement Error Handling (AC: 5)
  - [ ] Install `sonner` toast library (if not already installed)
  - [ ] Add toast notifications for mutation success/error
  - [ ] Map backend error codes to user-friendly messages
  - [ ] Handle 409 SLUG_EXISTS with specific message: "Template slug already exists"
  - [ ] Handle 400 TEMPLATE_IN_USE with message including assessment count
  - [ ] Handle 403 FORBIDDEN with redirect to login or access denied page
  - [ ] Show error alert in template list if `useTemplates().isError`
  - [ ] Add retry button for failed fetches

- [ ] Task 8: Connect Section/Question Mutations (AC: 3, 6)
  - [ ] Replace `handleAddSection` with `createSection.mutate()`
  - [ ] Replace `handleDeleteSection` with `deleteSection.mutate()`
  - [ ] Replace `handleAddQuestion` with `createQuestion.mutate()`
  - [ ] Replace `handleDeleteQuestion` with `deleteQuestion.mutate()`
  - [ ] Implement optimistic updates for section/question operations
  - [ ] Show pending states in section/question list items

- [ ] Task 9: Integration Testing (All AC)
  - [ ] Test template creation with valid data (creates on server, appears in list)
  - [ ] Test template creation with duplicate slug (shows error toast)
  - [ ] Test template update (optimistic update, syncs with server)
  - [ ] Test template delete (optimistic removal, syncs with server)
  - [ ] Test template delete with assessments (shows error with count)
  - [ ] Test section creation (appears in template immediately)
  - [ ] Test question creation (appears in section immediately)
  - [ ] Test status toggle (updates server, shows correct badge)
  - [ ] Test credit cost update (saves to server, displays correctly)
  - [ ] Test loading states (skeleton → data transition)
  - [ ] Test error states (network failure, shows error message + retry)
  - [ ] Test cache invalidation (create template → list refreshes)
  - [ ] Test concurrent mutations (queue properly, don't conflict)

## Dev Notes

### Existing System Context

**Frontend API Client Pattern (frontend/src/lib/api.ts:57-149):**
```typescript
// API request helper with auth
async function apiRequest<T>(endpoint: string, options: RequestInit = {}, forceAnonymous = false): Promise<T> {
  const token = localStorage.getItem('token');
  const headers: Record<string, string> = {};

  if (token && !forceAnonymous) {
    headers.Authorization = `Bearer ${token}`;
  }

  // Add Content-Type for JSON bodies
  if (options.body && !(options.body instanceof FormData)) {
    headers['Content-Type'] = 'application/json';
  }

  const config: RequestInit = {
    ...options,
    headers,
    credentials: 'include',
  };

  const prefix = getApiPrefix(forceAnonymous); // Returns '/v1' for authenticated
  const url = `${API_BASE_URL}${prefix}${endpoint}`;

  const response = await fetch(url, config);

  // Handle 401: Clear token and reload
  if (response.status === 401) {
    localStorage.removeItem('token');
    window.location.reload();
    return;
  }

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ message: 'Request failed' }));
    const error: any = new Error(errorData.message || `HTTP ${response.status}`);
    error.statusCode = response.status;
    error.code = errorData.code;
    throw error;
  }

  return response.json();
}

// Example API object
export const assessmentApi = {
  createAssessment: async (data: CreateAssessmentRequest): Promise<Assessment> => {
    return await apiRequest<Assessment>('/assessments', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },
  // ... more methods
};
```

**TanStack Query Pattern (Existing hooks in frontend/src/hooks/):**
```typescript
// Query hook example
export function useTemplates() {
  return useQuery({
    queryKey: ['templates'],
    queryFn: async () => {
      const response = await apiRequest<ApiResponse<AssessmentTemplate[]>>('/templates');
      return response.data || response; // Handle both wrapped and unwrapped responses
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 3,
  });
}

// Mutation hook example with optimistic update
export function useUpdateTemplate() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: Partial<Template> }) => {
      return await adminTemplateApi.updateTemplate(id, data);
    },
    onMutate: async ({ id, data }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['adminTemplates'] });

      // Snapshot previous value
      const previousTemplates = queryClient.getQueryData(['adminTemplates']);

      // Optimistically update
      queryClient.setQueryData(['adminTemplates'], (old: Template[]) =>
        old.map((t) => (t.id === id ? { ...t, ...data } : t))
      );

      // Return context for rollback
      return { previousTemplates };
    },
    onError: (err, variables, context) => {
      // Rollback on error
      if (context?.previousTemplates) {
        queryClient.setQueryData(['adminTemplates'], context.previousTemplates);
      }
      toast.error(`Failed to update template: ${err.message}`);
    },
    onSuccess: () => {
      // Invalidate to refetch from server
      queryClient.invalidateQueries({ queryKey: ['adminTemplates'] });
      toast.success('Template updated successfully');
    },
  });
}
```

**Toast Notifications:**
The project uses `sonner` toast library (check package.json). Import:
```typescript
import { toast } from 'sonner';

toast.success('Template created successfully');
toast.error('Failed to create template');
toast.loading('Creating template...', { id: 'template-create' });
toast.success('Template created', { id: 'template-create' }); // Replaces loading toast
```

**Loading States (Radix UI Skeleton):**
```typescript
import { Skeleton } from '@/components/ui/skeleton';

{isLoading && (
  <div className="space-y-4">
    <Skeleton className="h-12 w-full" />
    <Skeleton className="h-12 w-full" />
  </div>
)}
```

**Existing TemplateManagement.tsx Structure (frontend/src/pages/admin/TemplateManagement.tsx:191-310):**
```typescript
const TemplateManagement = () => {
  const [templates, setTemplates] = useState<Template[]>(mockTemplates); // REPLACE with useTemplates()
  const [selectedTemplate, setSelectedTemplate] = useState<Template | null>(null);
  const [editingTemplate, setEditingTemplate] = useState<Template | null>(null);
  const [isTemplateDialogOpen, setIsTemplateDialogOpen] = useState(false);

  const handleAddTemplate = () => {
    // REPLACE with createTemplate.mutate()
    setEditingTemplate({
      id: Date.now().toString(),
      name: '',
      description: '',
      framework: '',
      status: 'draft',
      sections: [],
      aiEnabled: false,
      creditCost: 50,
      createdDate: new Date().toISOString(),
      lastModified: new Date().toISOString(),
      usageCount: 0,
    });
    setIsTemplateDialogOpen(true);
  };

  const handleDeleteTemplate = (templateId: string) => {
    // REPLACE with deleteTemplate.mutate(templateId)
    setTemplates(templates.filter(t => t.id !== templateId));
  };

  // ... more handlers
};
```

### API Client Implementation

**Add to frontend/src/lib/api.ts:**
```typescript
// Admin Template API (requires ADMIN role)
export const adminTemplateApi = {
  // Templates
  createTemplate: async (data: CreateTemplateData): Promise<ApiResponse<Template>> => {
    return await apiRequest<ApiResponse<Template>>('/admin/templates', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  updateTemplate: async (id: string, data: Partial<Template>): Promise<ApiResponse<Template>> => {
    return await apiRequest<ApiResponse<Template>>(`/admin/templates/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },

  deleteTemplate: async (id: string): Promise<ApiResponse<void>> => {
    return await apiRequest<ApiResponse<void>>(`/admin/templates/${id}`, {
      method: 'DELETE',
    });
  },

  getTemplateStats: async (): Promise<ApiResponse<TemplateStats>> => {
    return await apiRequest<ApiResponse<TemplateStats>>('/admin/templates/stats');
  },

  // Sections
  createSection: async (templateId: string, data: CreateSectionData): Promise<ApiResponse<Section>> => {
    return await apiRequest<ApiResponse<Section>>(`/admin/templates/${templateId}/sections`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  updateSection: async (id: string, data: Partial<Section>): Promise<ApiResponse<Section>> => {
    return await apiRequest<ApiResponse<Section>>(`/admin/sections/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },

  deleteSection: async (id: string): Promise<ApiResponse<void>> => {
    return await apiRequest<ApiResponse<void>>(`/admin/sections/${id}`, {
      method: 'DELETE',
    });
  },

  // Questions
  createQuestion: async (sectionId: string, data: CreateQuestionData): Promise<ApiResponse<Question>> => {
    return await apiRequest<ApiResponse<Question>>(`/admin/sections/${sectionId}/questions`, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  },

  updateQuestion: async (id: string, data: Partial<Question>): Promise<ApiResponse<Question>> => {
    return await apiRequest<ApiResponse<Question>>(`/admin/questions/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },

  deleteQuestion: async (id: string): Promise<ApiResponse<void>> => {
    return await apiRequest<ApiResponse<void>>(`/admin/questions/${id}`, {
      method: 'DELETE',
    });
  },

  bulkCreateQuestions: async (sectionId: string, questions: CreateQuestionData[]): Promise<ApiResponse<Question[]>> => {
    return await apiRequest<ApiResponse<Question[]>>(`/admin/sections/${sectionId}/questions/bulk`, {
      method: 'POST',
      body: JSON.stringify({ questions }),
    });
  },
};

// TypeScript interfaces
interface CreateTemplateData {
  name: string;
  slug: string;
  category: 'FINANCIAL_CRIME' | 'TRADE_COMPLIANCE' | 'DATA_PRIVACY' | 'CYBERSECURITY' | 'ESG';
  description: string;
  version?: string;
  isActive?: boolean;
  creditCost?: number;
}

interface CreateSectionData {
  title: string;
  description?: string;
  order: number;
  weight?: number;
}

interface CreateQuestionData {
  text: string;
  type: 'TEXT' | 'NUMBER' | 'BOOLEAN' | 'SELECT' | 'MULTISELECT' | 'FILE' | 'DATE' | 'RATING';
  order: number;
  required?: boolean;
  options?: string[];
  helpText?: string;
  aiPromptHint?: string;
  weight?: number;
}

interface TemplateStats {
  totalTemplates: number;
  activeTemplates: number;
  categoryCounts: Record<string, number>;
  averageQuestions: number;
}
```

### TanStack Query Hooks Implementation

**Create frontend/src/hooks/useAdminTemplates.ts:**
```typescript
import { useQuery, useMutation, useQueryClient, QueryClient } from '@tanstack/react-query';
import { adminTemplateApi } from '@/lib/api';
import { toast } from 'sonner';

// Query keys
export const adminTemplateKeys = {
  all: ['adminTemplates'] as const,
  lists: () => [...adminTemplateKeys.all, 'list'] as const,
  list: (filters: string) => [...adminTemplateKeys.lists(), { filters }] as const,
  details: () => [...adminTemplateKeys.all, 'detail'] as const,
  detail: (id: string) => [...adminTemplateKeys.details(), id] as const,
  stats: () => [...adminTemplateKeys.all, 'stats'] as const,
};

// Query hooks
export function useTemplates() {
  return useQuery({
    queryKey: adminTemplateKeys.lists(),
    queryFn: async () => {
      const response = await adminTemplateApi.getTemplates(); // Use existing public endpoint
      return response.data || response;
    },
    staleTime: 5 * 60 * 1000,
    retry: 3,
  });
}

export function useTemplate(id: string) {
  return useQuery({
    queryKey: adminTemplateKeys.detail(id),
    queryFn: async () => {
      const response = await adminTemplateApi.getTemplate(id); // Use existing public endpoint
      return response.data || response;
    },
    enabled: !!id,
    staleTime: 5 * 60 * 1000,
  });
}

export function useTemplateStats() {
  return useQuery({
    queryKey: adminTemplateKeys.stats(),
    queryFn: async () => {
      const response = await adminTemplateApi.getTemplateStats();
      return response.data;
    },
    staleTime: 5 * 60 * 1000,
  });
}

// Mutation hooks with optimistic updates
export function useCreateTemplate() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: adminTemplateApi.createTemplate,
    onSuccess: (response) => {
      queryClient.invalidateQueries({ queryKey: adminTemplateKeys.lists() });
      toast.success('Template created successfully');
    },
    onError: (error: any) => {
      const message = error.code === 'SLUG_EXISTS'
        ? 'Template slug already exists'
        : `Failed to create template: ${error.message}`;
      toast.error(message);
    },
  });
}

export function useUpdateTemplate() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<Template> }) =>
      adminTemplateApi.updateTemplate(id, data),
    onMutate: async ({ id, data }) => {
      await queryClient.cancelQueries({ queryKey: adminTemplateKeys.lists() });
      const previousTemplates = queryClient.getQueryData(adminTemplateKeys.lists());

      queryClient.setQueryData(adminTemplateKeys.lists(), (old: Template[]) =>
        old.map((t) => (t.id === id ? { ...t, ...data } : t))
      );

      return { previousTemplates };
    },
    onError: (err: any, variables, context) => {
      if (context?.previousTemplates) {
        queryClient.setQueryData(adminTemplateKeys.lists(), context.previousTemplates);
      }
      toast.error(`Failed to update template: ${err.message}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: adminTemplateKeys.lists() });
      toast.success('Template updated successfully');
    },
  });
}

export function useDeleteTemplate() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: adminTemplateApi.deleteTemplate,
    onMutate: async (id) => {
      await queryClient.cancelQueries({ queryKey: adminTemplateKeys.lists() });
      const previousTemplates = queryClient.getQueryData(adminTemplateKeys.lists());

      queryClient.setQueryData(adminTemplateKeys.lists(), (old: Template[]) =>
        old.filter((t) => t.id !== id)
      );

      return { previousTemplates };
    },
    onError: (err: any, variables, context) => {
      if (context?.previousTemplates) {
        queryClient.setQueryData(adminTemplateKeys.lists(), context.previousTemplates);
      }

      const message = err.code === 'TEMPLATE_IN_USE'
        ? `Cannot delete template: ${err.metadata?.assessmentCount || 'some'} assessments are using it`
        : `Failed to delete template: ${err.message}`;
      toast.error(message);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: adminTemplateKeys.lists() });
      toast.success('Template deleted successfully');
    },
  });
}

// Similar patterns for section/question mutations...
```

### File Locations

**Modified Files:**
- `frontend/src/lib/api.ts` - Add adminTemplateApi object with 11 methods
- `frontend/src/pages/admin/TemplateManagement.tsx` - Replace mock data with hooks

**New Files:**
- `frontend/src/hooks/useAdminTemplates.ts` - TanStack Query hooks for template management

### Integration Points

1. **Existing Public Template Routes:**
   - GET /templates (list) - Used by regular users for template selection
   - GET /templates/:id (detail) - Used by assessment creation
   - Admin can reuse these for reading, use /admin routes for mutations

2. **Toast Notifications:**
   - Existing sonner toast system (check if installed in package.json)
   - Consistent success/error messaging across admin panel

3. **RBAC Enforcement:**
   - Backend enforces ADMIN role on all /admin/templates routes
   - Frontend shows 403 error if non-admin tries to access
   - Should redirect to access denied page or hide admin panel link

### Testing Standards

**Test Approach:**
- Manual testing in development (no automated frontend tests yet)
- Test checklist in AC 9

**Testing Checklist:**
```
□ Create template with valid data
□ Create template with duplicate slug (error toast)
□ Update template name (optimistic update)
□ Update template status (active/draft/archived)
□ Update credit cost
□ Delete template (optimistic removal)
□ Delete template with assessments (error message)
□ Create section
□ Create question
□ Bulk create 5 questions
□ Delete section (cascade to questions)
□ Test loading states (skeleton → data)
□ Test error states (network failure)
□ Test cache invalidation
```

### Performance Considerations

- **Optimistic Updates:** Instant UI feedback, rollback on error
- **Query Caching:** 5-minute stale time reduces unnecessary refetches
- **Cache Invalidation:** Smart invalidation (only affected queries)
- **Debouncing:** Not needed (explicit user actions, not search)

### Error Message Mapping

```typescript
const errorMessages: Record<string, string> = {
  SLUG_EXISTS: 'Template slug already exists. Please choose a different slug.',
  TEMPLATE_NOT_FOUND: 'Template not found.',
  TEMPLATE_IN_USE: 'Cannot delete template: assessments are using it.',
  TEMPLATE_INACTIVE: 'Cannot modify inactive template.',
  SECTION_NOT_FOUND: 'Section not found.',
  QUESTION_NOT_FOUND: 'Question not found.',
  FORBIDDEN: 'You do not have permission to perform this action.',
};

function getErrorMessage(error: any): string {
  if (error.code && errorMessages[error.code]) {
    return errorMessages[error.code];
  }
  return error.message || 'An unexpected error occurred.';
}
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created - Frontend template management integration | Bob (Scrum Master) |

---

## Dev Agent Record
_To be populated by dev agent during implementation_

---

## QA Results
_To be populated by QA agent after testing_
