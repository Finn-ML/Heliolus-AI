# Story 6.4: Create BillingService with Renewal Logic

## Status
Draft

## Story
**As a** system,
**I want** automated subscription renewal processing,
**so that** monthly and annual subscriptions are renewed correctly.

## Acceptance Criteria
1. New service `BillingService` created extending `BaseService`
2. Method `processSubscriptionRenewal(subscriptionId)`:
   - Validates subscription exists and has `billingCycle` set
   - Generates invoice record (mocked Stripe ID for now)
   - Updates subscription period:
     - `currentPeriodStart` = now
     - `currentPeriodEnd` = now + billing cycle duration
     - `renewalDate` = new currentPeriodEnd
   - For MONTHLY renewals: Resets `UserAssessmentQuota.assessmentsUsedThisMonth` to 0
   - For ANNUAL renewals: No quota reset needed
   - Returns void on success
3. Method handles subscriptions without `billingCycle` gracefully (FREE tier)
4. All updates in single transaction
5. Error handling for failed renewals (log and notify)

## Tasks / Subtasks

- [ ] **Task 1: Create BillingService File** (AC: 1)
  - [ ] Create file: `backend/src/services/billing.service.ts`
  - [ ] Import BaseService and required types:
    ```typescript
    import { BaseService, ServiceContext } from './base.service';
    import {
      ApiResponse,
      SubscriptionPlan,
      BillingCycle,
      InvoiceStatus,
    } from '../types/database';
    import { PRICING } from './subscription.service';
    ```
  - [ ] Create class extending BaseService:
    ```typescript
    export class BillingService extends BaseService {
      constructor() {
        super();
      }
    }
    ```

- [ ] **Task 2: Implement processSubscriptionRenewal Method** (AC: 2, 3, 4, 5)
  - [ ] Add method:
    ```typescript
    /**
     * Process subscription renewal
     * Updates billing period, resets quotas, and generates invoice
     *
     * @param subscriptionId - Subscription ID to renew
     * @throws Error if subscription not found or has no billing cycle
     */
    async processSubscriptionRenewal(subscriptionId: string): Promise<void> {
      try {
        // Fetch subscription with user relation
        const subscription = await this.prisma.subscription.findUnique({
          where: { id: subscriptionId },
          include: {
            user: {
              select: { id: true, email: true },
            },
          },
        });

        if (!subscription) {
          throw this.createError(
            'Subscription not found',
            404,
            'SUBSCRIPTION_NOT_FOUND'
          );
        }

        // Handle FREE tier gracefully (no billing cycle)
        if (!subscription.billingCycle) {
          this.logger.info('Skipping renewal for FREE tier subscription', {
            subscriptionId,
            userId: subscription.userId,
          });
          return;
        }

        // Calculate new period dates
        const now = this.now();
        const currentPeriodStart = now;
        let currentPeriodEnd: Date;

        if (subscription.billingCycle === BillingCycle.MONTHLY) {
          currentPeriodEnd = new Date(now);
          currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);
        } else if (subscription.billingCycle === BillingCycle.ANNUAL) {
          currentPeriodEnd = new Date(now);
          currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);
        } else {
          throw this.createError(
            `Unknown billing cycle: ${subscription.billingCycle}`,
            400,
            'INVALID_BILLING_CYCLE'
          );
        }

        const renewalDate = currentPeriodEnd;

        // Perform renewal in transaction
        await this.prisma.$transaction(async (tx) => {
          // 1. Update subscription period
          await tx.subscription.update({
            where: { id: subscriptionId },
            data: {
              currentPeriodStart,
              currentPeriodEnd,
              renewalDate,
            },
          });

          // 2. Reset monthly assessment quota for MONTHLY renewals
          if (subscription.billingCycle === BillingCycle.MONTHLY) {
            await tx.userAssessmentQuota.update({
              where: { userId: subscription.userId },
              data: {
                assessmentsUsedThisMonth: 0,
              },
            });
          }

          // 3. Generate invoice
          await this.generateInvoice(tx, subscription);
        });

        await this.logAudit({
          action: 'SUBSCRIPTION_RENEWED',
          entity: 'Subscription',
          entityId: subscriptionId,
          newValues: {
            currentPeriodStart,
            currentPeriodEnd,
            renewalDate,
          },
        });

        this.logger.info('Subscription renewed successfully', {
          subscriptionId,
          userId: subscription.userId,
          billingCycle: subscription.billingCycle,
          newPeriodEnd: currentPeriodEnd,
        });
      } catch (error) {
        this.logger.error('Subscription renewal failed', {
          subscriptionId,
          error: error.message,
        });

        // TODO: Send alert to admin/support team
        // await this.sendRenewalFailureAlert(subscriptionId, error);

        throw error;
      }
    }
    ```

- [ ] **Task 3: Implement generateInvoice Helper Method** (AC: 2)
  - [ ] Add private helper method:
    ```typescript
    /**
     * Generate invoice record for subscription renewal
     * Private helper method for processSubscriptionRenewal
     *
     * @param tx - Prisma transaction client
     * @param subscription - Subscription data
     */
    private async generateInvoice(
      tx: any,
      subscription: any
    ): Promise<void> {
      // Determine invoice amount based on billing cycle
      let amountInCents: number;

      if (subscription.billingCycle === BillingCycle.MONTHLY) {
        amountInCents = PRICING.PREMIUM_MONTHLY.price;
      } else if (subscription.billingCycle === BillingCycle.ANNUAL) {
        amountInCents = PRICING.PREMIUM_ANNUAL.price;
      } else {
        throw this.createError(
          `Cannot generate invoice for billing cycle: ${subscription.billingCycle}`,
          400,
          'INVALID_BILLING_CYCLE'
        );
      }

      // Convert cents to euros for Invoice model
      const amountInEuros = amountInCents / 100;

      // Mock Stripe invoice ID (real implementation would get from Stripe)
      const stripeInvoiceId = `draft-${Date.now()}-${subscription.id}`;

      // Calculate due date (14 days grace period)
      const dueDate = new Date(subscription.currentPeriodEnd);
      dueDate.setDate(dueDate.getDate() + 14);

      await tx.invoice.create({
        data: {
          subscriptionId: subscription.id,
          stripeInvoiceId,
          amount: amountInEuros,
          currency: 'EUR',
          status: InvoiceStatus.DRAFT,
          periodStart: subscription.currentPeriodStart,
          periodEnd: subscription.currentPeriodEnd,
          dueDate,
        },
      });

      this.logger.info('Invoice generated', {
        subscriptionId: subscription.id,
        stripeInvoiceId,
        amount: amountInEuros,
      });
    }
    ```

- [ ] **Task 4: Add Method to Get Upcoming Renewals** (AC: 2)
  - [ ] Add utility method:
    ```typescript
    /**
     * Get subscriptions due for renewal
     * Used by cron job to find subscriptions needing renewal
     *
     * @param daysAhead - Number of days to look ahead (default: 1)
     * @returns List of subscription IDs due for renewal
     */
    async getUpcomingRenewals(daysAhead: number = 1): Promise<string[]> {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() + daysAhead);

      const subscriptions = await this.prisma.subscription.findMany({
        where: {
          renewalDate: {
            lte: cutoffDate,
          },
          billingCycle: {
            not: null,
          },
          status: {
            in: ['ACTIVE', 'TRIALING'],
          },
        },
        select: {
          id: true,
          renewalDate: true,
        },
      });

      return subscriptions.map((sub) => sub.id);
    }
    ```

- [ ] **Task 5: Add Service Export** (AC: 1)
  - [ ] At bottom of file:
    ```typescript
    // Export singleton instance
    export const billingService = new BillingService();
    ```

- [ ] **Task 6: Add Index Export** (AC: 1)
  - [ ] Update `backend/src/services/index.ts`:
    ```typescript
    export { billingService } from './billing.service';
    ```

- [ ] **Task 7: Write Unit Tests** (AC: 2-5)
  - [ ] Test file: `backend/tests/unit/billing-service-renewal.test.ts`
  - [ ] Test MONTHLY renewal updates period correctly
  - [ ] Test ANNUAL renewal updates period correctly
  - [ ] Test MONTHLY renewal resets assessmentsUsedThisMonth
  - [ ] Test ANNUAL renewal does NOT reset assessmentsUsedThisMonth
  - [ ] Test FREE tier renewal skipped gracefully
  - [ ] Test invoice generated with correct amount
  - [ ] Test transaction rollback on error
  - [ ] Test getUpcomingRenewals returns correct subscriptions
  - [ ] Run tests: `npm test`

## Dev Notes

### Service Purpose

**BillingService** handles subscription billing workflows:
1. **Renewal Processing**: Advance subscription periods and reset quotas
2. **Invoice Generation**: Create invoice records for payments
3. **Renewal Discovery**: Find subscriptions due for renewal (cron job support)

**Not Handled Here:**
- Stripe payment processing (handled by webhooks)
- Email notifications (handled by EmailService)
- Failed payment retry logic (future enhancement)

[Source: docs/V4_REVISED_PAY_GATING_PLAN.md#Billing Services]

---

### Renewal Workflow

**Trigger:** Cron job or Stripe webhook

**Steps:**
1. Identify subscriptions with `renewalDate <= today`
2. For each subscription:
   - Update `currentPeriodStart`, `currentPeriodEnd`, `renewalDate`
   - Reset `assessmentsUsedThisMonth` (MONTHLY only)
   - Generate invoice record
3. Log audit event
4. Handle errors (log + alert)

**Example:**
```typescript
// Daily cron job
async function processRenewals() {
  const renewalIds = await billingService.getUpcomingRenewals(1);

  for (const id of renewalIds) {
    try {
      await billingService.processSubscriptionRenewal(id);
    } catch (error) {
      console.error(`Renewal failed for ${id}:`, error);
    }
  }
}
```

[Source: Epic 6 - Billing Services]

---

### Period Date Calculations

**Monthly Renewal:**
```typescript
const currentPeriodStart = new Date('2025-01-15');
const currentPeriodEnd = new Date(currentPeriodStart);
currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);
// Result: 2025-02-15
```

**Annual Renewal:**
```typescript
const currentPeriodStart = new Date('2025-01-15');
const currentPeriodEnd = new Date(currentPeriodStart);
currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);
// Result: 2026-01-15
```

**Edge Cases Handled:**
- End of month: Jan 31 → Feb 28/29
- Leap years: Feb 29, 2024 → Feb 28, 2025
- DST changes: Preserved by JavaScript Date object

[Source: Story 6.2 - Date Arithmetic]

---

### Quota Reset Logic

**MONTHLY Renewal:**
```typescript
// Reset assessmentsUsedThisMonth to 0
await tx.userAssessmentQuota.update({
  where: { userId: subscription.userId },
  data: {
    assessmentsUsedThisMonth: 0,  // Reset
  },
});
// assessmentsThisMonth stays the same (cumulative)
// totalAssessmentsCreated stays the same (lifetime)
```

**Why Reset:**
- Premium users get 2 assessments per billing cycle
- Monthly renewal = new billing cycle
- Reset counter to allow 2 more assessments

**ANNUAL Renewal:**
- No quota reset needed
- Annual users already have unlimited assessments
- Quota tracking is for billing cycle management only

**FREE Tier:**
- No renewal process
- No quota reset
- `totalAssessmentsCreated` never resets (lifetime limit)

[Source: Story 5.2 - UserAssessmentQuota Model]

---

### Invoice Generation

**Invoice Fields:**
```typescript
{
  subscriptionId: 'sub-xyz',
  stripeInvoiceId: 'draft-1729692345-sub-xyz',  // Mock ID
  amount: 599.00,                                // In euros
  currency: 'EUR',
  status: 'DRAFT',                               // Awaiting Stripe confirmation
  periodStart: Date('2025-01-15'),
  periodEnd: Date('2025-02-15'),
  dueDate: Date('2025-03-01'),                   // 14-day grace period
}
```

**Amount Calculation:**
```typescript
const amountInCents = subscription.billingCycle === 'MONTHLY'
  ? PRICING.PREMIUM_MONTHLY.price   // 59900 cents
  : PRICING.PREMIUM_ANNUAL.price;   // 646920 cents

const amountInEuros = amountInCents / 100;  // Convert to euros for Invoice model
```

**Why DRAFT Status:**
- Invoice created but payment not processed yet
- Real Stripe integration would:
  1. Create invoice in Stripe
  2. Charge customer
  3. Webhook updates status to PAID
- For MVP: Assume payment succeeds

[Source: backend/prisma/schema.prisma#Invoice]

---

### Transaction Safety

**Why Transaction:**
1. Update subscription period
2. Reset quota counter
3. Create invoice record
4. All must succeed or all rollback

**Failure Scenarios:**
```typescript
// Scenario 1: Quota update fails
await tx.subscription.update({ ... });  // ✓ Succeeds
await tx.userAssessmentQuota.update({ ... });  // ✗ Fails
// Result: Transaction rolls back, subscription period NOT updated

// Scenario 2: Invoice creation fails
await tx.subscription.update({ ... });  // ✓ Succeeds
await tx.userAssessmentQuota.update({ ... });  // ✓ Succeeds
await tx.invoice.create({ ... });  // ✗ Fails
// Result: Transaction rolls back, everything reverted
```

[Source: Story 5.6 - Transaction Atomicity]

---

### Error Handling

**Types of Errors:**
1. **Not Found**: Subscription doesn't exist → 404
2. **No Billing Cycle**: FREE tier → Skip renewal
3. **Invalid Billing Cycle**: Unknown value → 400
4. **Database Error**: Transaction fails → Rollback + log

**Error Response:**
```typescript
try {
  await billingService.processSubscriptionRenewal(subscriptionId);
} catch (error) {
  if (error.code === 'SUBSCRIPTION_NOT_FOUND') {
    // Handle 404
  } else if (error.code === 'INVALID_BILLING_CYCLE') {
    // Handle bad data
  } else {
    // Unknown error - alert admin
  }
}
```

**TODO: Add Alerting:**
```typescript
// Future enhancement
async sendRenewalFailureAlert(subscriptionId: string, error: Error) {
  await emailService.sendAdminAlert({
    subject: `Subscription Renewal Failed: ${subscriptionId}`,
    body: `Error: ${error.message}`,
    priority: 'HIGH',
  });
}
```

[Source: backend/src/services/base.service.ts#Error Handling]

---

### Future Stripe Integration

**Real Implementation (Post-MVP):**
```typescript
async processSubscriptionRenewal(subscriptionId: string) {
  const subscription = await this.prisma.subscription.findUnique({ ... });

  // 1. Create Stripe invoice
  const stripeInvoice = await stripe.invoices.create({
    customer: subscription.stripeCustomerId,
    subscription: subscription.stripeSubscriptionId,
    auto_advance: true,  // Auto-charge customer
  });

  // 2. Wait for webhook: invoice.paid
  // Webhook will call this method after payment succeeds

  // 3. Then update period (current logic)
  await this.prisma.$transaction(async (tx) => {
    await tx.subscription.update({ ... });
    await this.generateInvoice(tx, subscription, stripeInvoice.id);
  });
}
```

**Webhook Handler:**
```typescript
// backend/src/routes/webhook.routes.ts
if (event.type === 'invoice.paid') {
  const subscriptionId = event.data.object.subscription;
  await billingService.processSubscriptionRenewal(subscriptionId);
}
```

[Source: Stripe API documentation - Subscriptions]

---

### Testing Standards

**Test Framework:** Vitest 3
**Test Location:** `backend/tests/unit/billing-service-renewal.test.ts`

**Test Pattern:**
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { BillingService } from '../src/services/billing.service';
import { PrismaClient, SubscriptionPlan, BillingCycle } from '../src/generated/prisma';

describe('BillingService - Renewal Processing', () => {
  let service: BillingService;
  let prisma: PrismaClient;
  let monthlySubscriptionId: string;
  let annualSubscriptionId: string;
  let freeSubscriptionId: string;
  let monthlyUserId: string;

  beforeAll(async () => {
    service = new BillingService();
    prisma = new PrismaClient();

    // Create MONTHLY subscription
    const monthlyUser = await prisma.user.create({
      data: {
        email: 'monthly@example.com',
        firstName: 'Monthly',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.PREMIUM,
            billingCycle: BillingCycle.MONTHLY,
            currentPeriodStart: new Date('2025-01-15'),
            currentPeriodEnd: new Date('2025-02-15'),
            renewalDate: new Date('2025-02-15'),
            creditsBalance: 100,
          },
        },
        assessmentQuota: {
          create: {
            totalAssessmentsCreated: 5,
            assessmentsUsedThisMonth: 2,  // Should reset to 0
          },
        },
      },
    });
    monthlyUserId = monthlyUser.id;

    const monthlySubscription = await prisma.subscription.findUnique({
      where: { userId: monthlyUserId },
    });
    monthlySubscriptionId = monthlySubscription.id;

    // Create ANNUAL subscription
    const annualUser = await prisma.user.create({
      data: {
        email: 'annual@example.com',
        firstName: 'Annual',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.PREMIUM,
            billingCycle: BillingCycle.ANNUAL,
            currentPeriodStart: new Date('2024-01-15'),
            currentPeriodEnd: new Date('2025-01-15'),
            renewalDate: new Date('2025-01-15'),
            creditsBalance: 100,
          },
        },
      },
    });

    const annualSubscription = await prisma.subscription.findUnique({
      where: { userId: annualUser.id },
    });
    annualSubscriptionId = annualSubscription.id;

    // Create FREE subscription
    const freeUser = await prisma.user.create({
      data: {
        email: 'free@example.com',
        firstName: 'Free',
        lastName: 'User',
        password: 'hashed',
        subscription: {
          create: {
            plan: SubscriptionPlan.FREE,
            billingCycle: null,
            currentPeriodStart: null,
            currentPeriodEnd: null,
            renewalDate: null,
            creditsBalance: 0,
          },
        },
      },
    });

    const freeSubscription = await prisma.subscription.findUnique({
      where: { userId: freeUser.id },
    });
    freeSubscriptionId = freeSubscription.id;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: {
        email: { in: ['monthly@example.com', 'annual@example.com', 'free@example.com'] },
      },
    });
    await prisma.$disconnect();
  });

  describe('MONTHLY renewal', () => {
    it('should update subscription period by 1 month', async () => {
      await service.processSubscriptionRenewal(monthlySubscriptionId);

      const subscription = await prisma.subscription.findUnique({
        where: { id: monthlySubscriptionId },
      });

      const periodStart = new Date(subscription.currentPeriodStart);
      const periodEnd = new Date(subscription.currentPeriodEnd);
      const daysDiff = (periodEnd.getTime() - periodStart.getTime()) / (1000 * 60 * 60 * 24);

      expect(daysDiff).toBeGreaterThan(28);
      expect(daysDiff).toBeLessThan(32);
      expect(subscription.renewalDate).toEqual(subscription.currentPeriodEnd);
    });

    it('should reset assessmentsUsedThisMonth', async () => {
      const quotaBefore = await prisma.userAssessmentQuota.findUnique({
        where: { userId: monthlyUserId },
      });

      expect(quotaBefore.assessmentsUsedThisMonth).toBe(2);

      await service.processSubscriptionRenewal(monthlySubscriptionId);

      const quotaAfter = await prisma.userAssessmentQuota.findUnique({
        where: { userId: monthlyUserId },
      });

      expect(quotaAfter.assessmentsUsedThisMonth).toBe(0);  // Reset
      expect(quotaAfter.totalAssessmentsCreated).toBe(5);   // Unchanged
    });

    it('should generate invoice with monthly amount', async () => {
      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: monthlySubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      expect(invoices.length).toBe(1);
      expect(invoices[0].amount).toBe(599.00);  // PREMIUM_MONTHLY
      expect(invoices[0].currency).toBe('EUR');
      expect(invoices[0].status).toBe('DRAFT');
    });
  });

  describe('ANNUAL renewal', () => {
    it('should update subscription period by 1 year', async () => {
      await service.processSubscriptionRenewal(annualSubscriptionId);

      const subscription = await prisma.subscription.findUnique({
        where: { id: annualSubscriptionId },
      });

      const periodStart = new Date(subscription.currentPeriodStart);
      const periodEnd = new Date(subscription.currentPeriodEnd);
      const daysDiff = (periodEnd.getTime() - periodStart.getTime()) / (1000 * 60 * 60 * 24);

      expect(daysDiff).toBeGreaterThan(364);
      expect(daysDiff).toBeLessThan(367);
    });

    it('should generate invoice with annual amount', async () => {
      const invoices = await prisma.invoice.findMany({
        where: { subscriptionId: annualSubscriptionId },
        orderBy: { createdAt: 'desc' },
        take: 1,
      });

      expect(invoices.length).toBe(1);
      expect(invoices[0].amount).toBe(6469.20);  // PREMIUM_ANNUAL
    });
  });

  describe('FREE tier', () => {
    it('should skip renewal for FREE tier', async () => {
      await service.processSubscriptionRenewal(freeSubscriptionId);

      const subscription = await prisma.subscription.findUnique({
        where: { id: freeSubscriptionId },
      });

      // Period should remain null
      expect(subscription.currentPeriodStart).toBeNull();
      expect(subscription.currentPeriodEnd).toBeNull();
      expect(subscription.renewalDate).toBeNull();
    });
  });

  describe('getUpcomingRenewals', () => {
    it('should return subscriptions due for renewal', async () => {
      const renewalIds = await service.getUpcomingRenewals(30);

      expect(renewalIds).toContain(monthlySubscriptionId);
      expect(renewalIds).not.toContain(freeSubscriptionId);
    });
  });
});
```

[Source: architecture.md#Testing Strategy]

---

### File Locations
- **Service:** `backend/src/services/billing.service.ts` (NEW)
- **Export:** `backend/src/services/index.ts` (UPDATE)
- **Test:** `backend/tests/unit/billing-service-renewal.test.ts`

---

### Dependencies
**Depends On:**
- Story 5.1: BillingCycle enum
- Story 5.2: UserAssessmentQuota model
- Story 6.1: PRICING constants
- Existing: Invoice model, Subscription model

**Depended On By:**
- Future: Cron job to trigger renewals
- Future: Stripe webhook integration

---

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-23 | 1.0 | Initial story creation from Epic 6 | Bob (Scrum Master) |

---

## Dev Agent Record
_This section will be populated by the development agent during implementation_

### Agent Model Used
_TBD_

### Debug Log References
_TBD_

### Completion Notes
_TBD_

### File List
_TBD_

---

## QA Results
_This section will be populated by the QA agent after story completion_
