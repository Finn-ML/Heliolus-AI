# Story 11.3: Vendor Analytics Backend API

## Status
Draft

## Story

**As a** system
**I want** vendor engagement metrics aggregated from interactions
**So that** admins can measure marketplace effectiveness

## Acceptance Criteria

1. New endpoint: `GET /v1/admin/analytics/vendors`
2. Returns vendor engagement metrics:
   ```typescript
   {
     totalVendors: number,
     activeVendors: number,     // Has at least 1 match
     totalClicks: number,       // VendorMatch.viewed = true
     uniqueVisitors: number,    // Distinct users who viewed vendors
     totalContacts: number,     // VendorContact count
     conversionRate: number,    // (contacts / clicks) * 100
     avgMatchScore: number,     // Average VendorMatch.matchScore
     topVendors: Array<{
       vendorId: string,
       companyName: string,
       clicks: number,
       contacts: number,
       conversionRate: number,
       trend: 'up' | 'down' | 'stable'
     }>,  // Top 10 by engagement
     clicksByCategory: Array<{
       category: string,
       clicks: number,
       contacts: number
     }>,
     trend: Array<{
       date: string,
       clicks: number,
       contacts: number,
       uniqueVisitors: number
     }>  // Last 30 days
   }
   ```
3. Query parameters:
   - `startDate`, `endDate`: Date range filters
   - `limit`: Max vendors in topVendors (default: 10)
4. Trend calculation:
   - Compare last 7 days to previous 7 days
   - 'up' if > 10% increase, 'down' if > 10% decrease, else 'stable'
5. Response time < 1 second
6. Cache for 5 minutes

## Tasks / Subtasks

- [ ] Task 1: Add Vendor Analytics Method to Service (AC: 1, 2)
  - [ ] Add `getVendorAnalytics` method to AnalyticsService
  - [ ] Query total vendors count from Vendor table
  - [ ] Query active vendors (vendors with at least 1 VendorMatch)
  - [ ] Query total clicks from VendorMatch where viewed = true
  - [ ] Query unique visitors using distinct userId from VendorMatch
  - [ ] Query total contacts from VendorContact table
  - [ ] Calculate conversion rate: (contacts / clicks) * 100
  - [ ] Calculate average match score from VendorMatch.matchScore

- [ ] Task 2: Implement Top Vendors Ranking (AC: 2, 4)
  - [ ] Calculate engagement score: (clicks × 1) + (contacts × 5)
  - [ ] Query top N vendors by engagement score
  - [ ] For each vendor, get clicks and contacts counts
  - [ ] Calculate per-vendor conversion rate
  - [ ] Calculate trend:
    - Get clicks for last 7 days vs previous 7 days
    - Compare: 'up' if > 10% increase, 'down' if > 10%, else 'stable'
  - [ ] Sort by engagement score descending
  - [ ] Limit to top 10 (or param limit)

- [ ] Task 3: Clicks by Category (AC: 2)
  - [ ] Join VendorMatch with Vendor to get categories
  - [ ] Group by vendor category
  - [ ] Count clicks (viewed = true) per category
  - [ ] Count contacts per category (join with VendorContact)
  - [ ] Return array sorted by clicks descending

- [ ] Task 4: Vendor Engagement Trend (AC: 2)
  - [ ] Query VendorMatch grouped by date (last 30 days)
  - [ ] Count clicks per day (viewed = true)
  - [ ] Query VendorContact grouped by date
  - [ ] Count contacts per day
  - [ ] Count distinct users (unique visitors) per day
  - [ ] Return array of daily metrics

- [ ] Task 5: Add Analytics Route (AC: 1)
  - [ ] Add route to `backend/src/routes/admin.routes.ts`
  - [ ] `GET /admin/analytics/vendors`
  - [ ] Zod schema for query params (startDate, endDate, limit)
  - [ ] Require ADMIN role
  - [ ] Call AnalyticsService.getVendorAnalytics
  - [ ] Return formatted response

- [ ] Task 6: Add Caching (AC: 6)
  - [ ] Cache key: `analytics:vendors:{startDate}:{endDate}:{limit}`
  - [ ] TTL: 300 seconds (5 minutes)
  - [ ] Check cache before database query
  - [ ] Store result in Redis cache

- [ ] Task 7: Optimize Performance (AC: 5)
  - [ ] Add indexes: VendorMatch(viewed, createdAt), VendorContact(createdAt)
  - [ ] Test with 1000+ vendors, 10,000+ matches
  - [ ] Verify response time < 1 second
  - [ ] Use EXPLAIN ANALYZE for query optimization

- [ ] Task 8: Testing (All AC)
  - [ ] Unit test: getVendorAnalytics with mock data
  - [ ] Test top vendors ranking algorithm
  - [ ] Test trend calculation (up/down/stable)
  - [ ] Test clicks by category grouping
  - [ ] Integration test: GET /admin/analytics/vendors
  - [ ] Performance test: Large dataset
  - [ ] Test cache hit/miss

## Dev Notes

### Relevant Models
[Source: backend/prisma/schema.prisma]

**Vendor Model** (lines 607-670):
```prisma
model Vendor {
  id          String            @id @default(cuid())
  companyName String            @unique
  categories  VendorCategory[]
  status      VendorStatus      @default(PENDING)
  createdAt   DateTime          @default(now())

  matches     VendorMatch[]
  contacts    VendorContact[]
  solutions   Solution[]
}
```

**VendorMatch Model** (lines 708-735):
```prisma
model VendorMatch {
  id          String   @id @default(cuid())
  gapId       String
  vendorId    String
  matchScore  Int      // 0-100
  viewed      Boolean  @default(false)
  contacted   Boolean  @default(false)
  dismissed   Boolean  @default(false)
  createdAt   DateTime @default(now())

  vendor      Vendor   @relation(fields: [vendorId], references: [id])

  @@index([vendorId])
  @@index([viewed])
  @@index([contacted])
}
```

**VendorContact Model** (lines 876-907):
```prisma
model VendorContact {
  id          String        @id @default(cuid())
  vendorId    String
  userId      String
  type        ContactType
  status      ContactStatus @default(PENDING)
  createdAt   DateTime      @default(now())

  vendor      Vendor        @relation(fields: [vendorId], references: [id])
  user        User          @relation(fields: [userId], references: [id])

  @@index([vendorId])
  @@index([userId])
  @@index([createdAt])
}
```

### Efficient Query Patterns

**Total and Active Vendors**:
```typescript
const [totalVendors, activeVendors] = await Promise.all([
  this.prisma.vendor.count(),
  this.prisma.vendor.count({
    where: {
      matches: { some: {} }  // Has at least 1 match
    }
  })
]);
```

**Clicks and Unique Visitors**:
```typescript
const [totalClicks, uniqueVisitors] = await Promise.all([
  this.prisma.vendorMatch.count({
    where: { viewed: true, ...dateFilter }
  }),
  this.prisma.vendorMatch.findMany({
    where: { viewed: true, ...dateFilter },
    distinct: ['userId'],
    select: { userId: true }
  }).then(results => results.length)
]);
```

**Top Vendors with Engagement Score**:
```typescript
// Get vendor stats
const vendorStats = await this.prisma.vendorMatch.groupBy({
  by: ['vendorId'],
  where: { viewed: true, ...dateFilter },
  _count: { id: true }
});

const contactStats = await this.prisma.vendorContact.groupBy({
  by: ['vendorId'],
  where: dateFilter,
  _count: { id: true }
});

// Calculate engagement scores
const vendorEngagement = vendorStats.map(v => {
  const clicks = v._count.id;
  const contacts = contactStats.find(c => c.vendorId === v.vendorId)?._count.id || 0;
  const engagementScore = (clicks * 1) + (contacts * 5);
  const conversionRate = clicks > 0 ? (contacts / clicks) * 100 : 0;

  return {
    vendorId: v.vendorId,
    clicks,
    contacts,
    engagementScore,
    conversionRate
  };
});

// Sort and get top N
const topVendorIds = vendorEngagement
  .sort((a, b) => b.engagementScore - a.engagementScore)
  .slice(0, limit)
  .map(v => v.vendorId);

// Fetch vendor details
const vendors = await this.prisma.vendor.findMany({
  where: { id: { in: topVendorIds } },
  select: { id: true, companyName: true }
});

// Merge data
const topVendors = topVendorIds.map(id => {
  const stats = vendorEngagement.find(v => v.vendorId === id)!;
  const vendor = vendors.find(v => v.id === id)!;
  const trend = await this.calculateVendorTrend(id, dateFilter);

  return {
    vendorId: id,
    companyName: vendor.companyName,
    clicks: stats.clicks,
    contacts: stats.contacts,
    conversionRate: Math.round(stats.conversionRate * 10) / 10,
    trend
  };
});
```

**Trend Calculation**:
```typescript
async calculateVendorTrend(vendorId: string, dateFilter: any): Promise<'up' | 'down' | 'stable'> {
  const now = new Date();
  const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const fourteenDaysAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);

  const [recentClicks, previousClicks] = await Promise.all([
    this.prisma.vendorMatch.count({
      where: {
        vendorId,
        viewed: true,
        createdAt: { gte: sevenDaysAgo, lte: now }
      }
    }),
    this.prisma.vendorMatch.count({
      where: {
        vendorId,
        viewed: true,
        createdAt: { gte: fourteenDaysAgo, lt: sevenDaysAgo }
      }
    })
  ]);

  if (previousClicks === 0) return 'stable';

  const change = ((recentClicks - previousClicks) / previousClicks) * 100;

  if (change > 10) return 'up';
  if (change < -10) return 'down';
  return 'stable';
}
```

**Clicks by Category**:
```typescript
const clicksByCategory = await this.prisma.$queryRaw<Array<{
  category: string;
  clicks: number;
  contacts: number;
}>>`
  SELECT
    unnest(v.categories) as category,
    COUNT(DISTINCT vm.id) FILTER (WHERE vm.viewed = true) as clicks,
    COUNT(DISTINCT vc.id) as contacts
  FROM "Vendor" v
  LEFT JOIN "VendorMatch" vm ON v.id = vm."vendorId"
  LEFT JOIN "VendorContact" vc ON v.id = vc."vendorId"
  WHERE vm."createdAt" >= ${startDate}
    AND vm."createdAt" <= ${endDate}
  GROUP BY category
  ORDER BY clicks DESC
`;
```

**Engagement Trend (Last 30 Days)**:
```typescript
const trend = await this.prisma.$queryRaw<Array<{
  date: string;
  clicks: number;
  contacts: number;
  unique_visitors: number;
}>>`
  SELECT
    DATE(vm.created_at) as date,
    COUNT(DISTINCT vm.id) FILTER (WHERE vm.viewed = true) as clicks,
    COUNT(DISTINCT vc.id) as contacts,
    COUNT(DISTINCT vm.user_id) as unique_visitors
  FROM "VendorMatch" vm
  LEFT JOIN "VendorContact" vc ON DATE(vm.created_at) = DATE(vc.created_at)
  WHERE vm.created_at >= ${thirtyDaysAgo}
  GROUP BY DATE(vm.created_at)
  ORDER BY date ASC
`;
```

### Database Indexes

Add these indexes for performance:
```prisma
model VendorMatch {
  // ... existing fields

  @@index([viewed, createdAt])
  @@index([vendorId, viewed])
  @@index([userId, viewed])
}

model VendorContact {
  // ... existing fields

  @@index([vendorId, createdAt])
  @@index([createdAt])
}
```

### File Locations

**Modified Files**:
- `backend/src/services/analytics.service.ts` - Add getVendorAnalytics method
- `backend/src/routes/admin.routes.ts` - Add GET /admin/analytics/vendors route
- `backend/prisma/schema.prisma` - Add indexes if needed

### Testing Standards

**Test Cases**:
```typescript
describe('AnalyticsService - getVendorAnalytics', () => {
  it('should count total and active vendors', async () => {
    // Seed: 10 vendors, 7 with matches
    const result = await analyticsService.getVendorAnalytics({});
    expect(result.data.totalVendors).toBe(10);
    expect(result.data.activeVendors).toBe(7);
  });

  it('should calculate conversion rate', async () => {
    // Seed: 100 clicks, 15 contacts
    const result = await analyticsService.getVendorAnalytics({});
    expect(result.data.conversionRate).toBe(15); // 15/100 * 100
  });

  it('should rank top vendors by engagement', async () => {
    // Seed vendors with varying clicks and contacts
    const result = await analyticsService.getVendorAnalytics({ limit: 5 });
    expect(result.data.topVendors).toHaveLength(5);
    // Verify sorted by engagement score
    const scores = result.data.topVendors.map(v =>
      (v.clicks * 1) + (v.contacts * 5)
    );
    expect(scores).toEqual([...scores].sort((a, b) => b - a));
  });

  it('should calculate vendor trend correctly', async () => {
    // Seed: Vendor A with 20 clicks last week, 10 clicks previous week (100% up)
    const result = await analyticsService.getVendorAnalytics({});
    const vendorA = result.data.topVendors.find(v => v.vendorId === 'vendorA');
    expect(vendorA.trend).toBe('up');
  });

  it('should group clicks by category', async () => {
    const result = await analyticsService.getVendorAnalytics({});
    expect(result.data.clicksByCategory).toBeInstanceOf(Array);
    expect(result.data.clicksByCategory[0]).toHaveProperty('category');
    expect(result.data.clicksByCategory[0]).toHaveProperty('clicks');
  });
});
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | Story created - Vendor analytics backend API | Bob (Scrum Master) |

---

## Dev Agent Record
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
