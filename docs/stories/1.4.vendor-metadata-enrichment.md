# Story 1.4: Enrich Vendor Metadata from Existing Text Fields

**Epic:** 1 - Vendor Matching Score Fixes
**Story:** 1.4
**Status:** Draft

---

## Story

**As a** product manager,
**I want** to extract structured metadata from existing vendor text fields,
**so that** the matching algorithm can properly score vendors on all dimensions without requiring manual data entry

---

## Acceptance Criteria

1. ✅ Script extracts features from `aiCapabilities` and `primaryProduct` fields
2. ✅ Script infers `targetSegments` from `customerSegments` field
3. ✅ Script maps `headquarters` to `geographicCoverage` array
4. ✅ Script generates reasonable `pricingRange` estimates based on vendor tier
5. ✅ Script sets `implementationTimeline` based on vendor maturity/deployment complexity
6. ✅ All 10+ approved vendors have enriched metadata
7. ✅ Match scores improve to 50-85% range for well-matched vendors
8. ✅ Enrichment results are reviewed and validated before database update

---

## Tasks / Subtasks

- [ ] **Task 1: Create Vendor Enrichment Script** (AC: 1, 2, 3, 4, 5)
  - [ ] Create file: `backend/scripts/enrich-vendor-metadata.ts`
  - [ ] Load all approved vendors from database
  - [ ] For each vendor, extract structured data from text fields
  - [ ] Generate enrichment plan (before/after comparison)
  - [ ] Output enrichment results to JSON file for review

- [ ] **Task 2: Implement Feature Extraction Logic** (AC: 1)
  - [ ] Parse `aiCapabilities` field for feature keywords
  - [ ] Parse `primaryProduct` field for capability mentions
  - [ ] Map detected keywords to standard feature names
  - [ ] Example: "API integration" → "API_INTEGRATION", "real-time" → "REAL_TIME_MONITORING"
  - [ ] Return array of feature strings for `vendor.features` field

- [ ] **Task 3: Implement Target Segment Inference** (AC: 2)
  - [ ] Parse `customerSegments` field for company size mentions
  - [ ] Map keywords to CompanySize enum: "SMB" → `SMB`, "enterprise" → `ENTERPRISE`, "startup" → `STARTUP`
  - [ ] Default to `[SMB, MIDMARKET, ENTERPRISE]` if unclear
  - [ ] Return CompanySize[] array for `vendor.targetSegments` field

- [ ] **Task 4: Implement Geographic Coverage Mapping** (AC: 3)
  - [ ] Map `headquarters` location to primary geographic region
  - [ ] Add "Global" if vendor explicitly mentions global operations
  - [ ] Parse `dataCoverage` field for jurisdiction mentions (US, EU, UK, APAC)
  - [ ] Return string[] array for `vendor.geographicCoverage` field
  - [ ] Example: headquarters="London" → ["EU", "UK", "Global"]

- [ ] **Task 5: Implement Pricing Range Estimation** (AC: 4)
  - [ ] Analyze vendor tier indicators (featured, verified, awards)
  - [ ] Infer pricing from company maturity and target segments
  - [ ] Default estimates: Enterprise vendors → "RANGE_100K_250K", SMB-focused → "RANGE_10K_50K"
  - [ ] Return pricingRange string matching CostRange enum format

- [ ] **Task 6: Implement Implementation Timeline Estimation** (AC: 5)
  - [ ] Parse `deploymentOptions` for deployment complexity hints
  - [ ] Simple SaaS/API-only → 30-60 days
  - [ ] Hybrid cloud/on-prem options → 90-120 days
  - [ ] Enterprise deployments → 120-180 days
  - [ ] Return number (days) for `vendor.implementationTimeline` field

- [ ] **Task 7: Generate Enrichment Report** (AC: 6, 8)
  - [ ] Create JSON output: `backend/scripts/vendor-enrichment-results.json`
  - [ ] Include before/after comparison for each vendor
  - [ ] Flag high-confidence vs low-confidence inferences
  - [ ] Generate summary statistics (% fields enriched)
  - [ ] Output to console for review

- [ ] **Task 8: Create Database Update Migration** (AC: 6)
  - [ ] Review enrichment results JSON manually
  - [ ] Validate 5+ vendors spot-checked for accuracy
  - [ ] Create Prisma migration or direct SQL script
  - [ ] Update all vendor records with enriched metadata
  - [ ] Run migration against development database first

- [ ] **Task 9: Validate Score Improvements** (AC: 7)
  - [ ] Run vendor matching before enrichment (baseline scores)
  - [ ] Apply enrichment migration to database
  - [ ] Run vendor matching after enrichment
  - [ ] Compare scores for test assessment `cmgtah4e9003jlvglxp0ra3ri`
  - [ ] Verify scores increase from 40-50 to 70-110 range
  - [ ] Document improvements in completion notes

- [ ] **Task 10: Create Validation Documentation** (AC: 8)
  - [ ] Create file: `docs/vendor-enrichment-validation.md`
  - [ ] Document methodology and assumptions
  - [ ] Include spot-check validation results (5+ vendors)
  - [ ] List any vendors that need manual review
  - [ ] Document acceptance testing results

---

## Dev Notes

### Problem Context

**Root Cause:** Vendors have rich descriptive text fields but empty structured metadata fields. The structured fields drive scoring, but text fields are ignored.

**Current Vendor Data Example (Napier AI):**
```typescript
{
  companyName: "Napier AI",
  headquarters: "Edinburgh, UK",
  primaryProduct: "AI-powered transaction monitoring and AML compliance platform",
  aiCapabilities: "Machine learning for transaction monitoring, behavioral analytics, case management",
  deploymentOptions: "SaaS; API; private cloud",
  customerSegments: "Banks, FIServ, Insurance, Fintechs",

  // ❌ Empty structured fields:
  targetSegments: [],
  features: [],
  geographicCoverage: [],
  pricingRange: null,
  implementationTimeline: null,
}
```

**After Enrichment:**
```typescript
{
  // ... text fields unchanged ...

  // ✅ Populated structured fields:
  targetSegments: ['MIDMARKET', 'ENTERPRISE'],
  features: ['TRANSACTION_MONITORING', 'CASE_MANAGEMENT', 'API_INTEGRATION', 'REAL_TIME_MONITORING'],
  geographicCoverage: ['EU', 'UK', 'GLOBAL'],
  pricingRange: 'RANGE_100K_250K',
  implementationTimeline: 90,
}
```

---

### Technical Context

#### File Structure

1. **Enrichment Script**:
   - File: `backend/scripts/enrich-vendor-metadata.ts`
   - Purpose: Extract structured data from text fields
   - Output: JSON file with enrichment plan
   - Dependencies: Prisma client, OpenAI (optional for AI-assisted extraction)

2. **Migration**:
   - File: `backend/prisma/migrations/YYYYMMDD_enrich_vendor_data.sql`
   - Purpose: Bulk update vendor records
   - Method: Prisma raw SQL or prisma.vendor.update() calls

3. **Validation Report**:
   - File: `docs/vendor-enrichment-validation.md`
   - Purpose: Document enrichment quality and methodology

#### Data Models

**Source:** [Project: backend/prisma/schema.prisma]

```typescript
model Vendor {
  id       String   @id @default(cuid())

  // Rich text fields (source data):
  companyName            String
  headquarters           String?
  primaryProduct         String?
  aiCapabilities         String?
  deploymentOptions      String?
  customerSegments       String?
  benefitsSnapshot       String?
  maturityAssessment     String?

  // Structured fields (target for enrichment):
  targetSegments         CompanySize[]  @default([])  // ❌ 0% populated
  features               String[]       @default([])  // ❌ 0% populated
  geographicCoverage     String[]       @default([])  // ❌ 0% populated
  pricingRange           String?                      // ❌ 0% populated
  implementationTimeline Int?                         // ❌ 0% populated

  // Other fields...
}
```

#### Enrichment Mapping Logic

**Source:** [Analysis: docs/VENDOR_MATCH_SCORE_ANALYSIS.md - Medium-Term Fix #4]

##### 1. Features Extraction

**Source Fields:** `aiCapabilities`, `primaryProduct`, `benefitsSnapshot`

**Keyword Mapping:**
```typescript
const featureKeywords = {
  'REAL_TIME_MONITORING': ['real-time', 'real time', 'continuous monitoring', 'live'],
  'CASE_MANAGEMENT': ['case management', 'case handling', 'investigations', 'workflow'],
  'API_INTEGRATION': ['API', 'integration', 'REST', 'webhook'],
  'TRANSACTION_MONITORING': ['transaction monitoring', 'TM', 'transactions'],
  'SANCTIONS_SCREENING': ['sanctions', 'screening', 'watchlist', 'PEP'],
  'KYC_VERIFICATION': ['KYC', 'identity', 'verification', 'due diligence'],
  'RISK_SCORING': ['risk score', 'risk assessment', 'risk rating'],
  'FRAUD_DETECTION': ['fraud detection', 'fraud prevention', 'anomaly'],
  'COMPLIANCE_REPORTING': ['reporting', 'regulatory reporting', 'SAR', 'CTR'],
  'ALERT_MANAGEMENT': ['alert', 'notification', 'escalation'],
};

function extractFeatures(vendor: Vendor): string[] {
  const textToSearch = [
    vendor.aiCapabilities,
    vendor.primaryProduct,
    vendor.benefitsSnapshot,
  ].join(' ').toLowerCase();

  const features: string[] = [];
  for (const [feature, keywords] of Object.entries(featureKeywords)) {
    if (keywords.some(keyword => textToSearch.includes(keyword.toLowerCase()))) {
      features.push(feature);
    }
  }
  return features;
}
```

##### 2. Target Segments Inference

**Source Field:** `customerSegments`

**Keyword Mapping:**
```typescript
function inferTargetSegments(customerSegments: string | null): CompanySize[] {
  if (!customerSegments) return ['SMB', 'MIDMARKET', 'ENTERPRISE']; // Default: all

  const text = customerSegments.toLowerCase();
  const segments: Set<CompanySize> = new Set();

  if (text.includes('startup') || text.includes('early-stage')) segments.add('STARTUP');
  if (text.includes('smb') || text.includes('small') || text.includes('medium')) segments.add('SMB');
  if (text.includes('midmarket') || text.includes('mid-market') || text.includes('mid-size')) segments.add('MIDMARKET');
  if (text.includes('enterprise') || text.includes('large') || text.includes('global')) segments.add('ENTERPRISE');
  if (text.includes('bank') || text.includes('finserv') || text.includes('insurance')) {
    segments.add('MIDMARKET');
    segments.add('ENTERPRISE');
  }

  return segments.size > 0 ? Array.from(segments) : ['SMB', 'MIDMARKET', 'ENTERPRISE'];
}
```

##### 3. Geographic Coverage Mapping

**Source Fields:** `headquarters`, `dataCoverage`

**Logic:**
```typescript
function mapGeographicCoverage(headquarters: string | null, dataCoverage: string | null): string[] {
  const coverage: Set<string> = new Set();

  // Map headquarters to region
  if (headquarters) {
    const location = headquarters.toLowerCase();
    if (location.includes('us') || location.includes('america') || location.includes('new york') || location.includes('san francisco')) {
      coverage.add('US');
    }
    if (location.includes('uk') || location.includes('london') || location.includes('edinburgh')) {
      coverage.add('UK');
      coverage.add('EU');
    }
    if (location.includes('eu') || location.includes('europe') || location.includes('germany') || location.includes('france')) {
      coverage.add('EU');
    }
    if (location.includes('asia') || location.includes('singapore') || location.includes('hong kong')) {
      coverage.add('APAC');
    }
  }

  // Parse data coverage field
  if (dataCoverage) {
    const text = dataCoverage.toLowerCase();
    if (text.includes('global') || text.includes('worldwide')) coverage.add('GLOBAL');
    if (text.includes('us')) coverage.add('US');
    if (text.includes('eu') || text.includes('europe')) coverage.add('EU');
    if (text.includes('uk')) coverage.add('UK');
    if (text.includes('asia') || text.includes('apac')) coverage.add('APAC');
  }

  // Default to global if nothing detected
  if (coverage.size === 0) coverage.add('GLOBAL');

  return Array.from(coverage);
}
```

##### 4. Pricing Range Estimation

**Logic:**
```typescript
function estimatePricingRange(vendor: Vendor): string | null {
  // Enterprise-focused vendors typically expensive
  if (vendor.customerSegments?.toLowerCase().includes('enterprise')) {
    return 'RANGE_100K_250K';
  }

  // Featured/verified vendors likely mid-tier
  if (vendor.featured || vendor.verified) {
    return 'RANGE_50K_100K';
  }

  // SMB-focused vendors likely cheaper
  if (vendor.customerSegments?.toLowerCase().includes('smb') || vendor.customerSegments?.toLowerCase().includes('startup')) {
    return 'RANGE_10K_50K';
  }

  // Default mid-range
  return 'RANGE_50K_100K';
}
```

##### 5. Implementation Timeline Estimation

**Source Field:** `deploymentOptions`

**Logic:**
```typescript
function estimateImplementationTimeline(deploymentOptions: string | null): number {
  if (!deploymentOptions) return 90; // Default 3 months

  const text = deploymentOptions.toLowerCase();

  // Simple SaaS/API deployments are fast
  if ((text.includes('saas') || text.includes('api')) && !text.includes('on-prem') && !text.includes('private')) {
    return 45; // 1.5 months
  }

  // Hybrid or private cloud deployments moderate
  if (text.includes('private') || text.includes('hybrid')) {
    return 90; // 3 months
  }

  // On-premise or enterprise deployments slow
  if (text.includes('on-prem') || text.includes('enterprise')) {
    return 150; // 5 months
  }

  return 90; // Default 3 months
}
```

---

### Testing

#### Test Strategy

1. **Unit Tests** (optional - script is run-once utility):
   - Test feature extraction with sample vendor text
   - Test target segment inference logic
   - Test geographic coverage mapping

2. **Integration Testing**:
   - Run enrichment script on development database
   - Review generated JSON output
   - Spot-check 5-10 vendors manually for accuracy

3. **Validation Testing**:
   - Run vendor matching before enrichment → capture baseline scores
   - Apply enrichment
   - Run vendor matching after enrichment → compare scores
   - Expected: 200-400% score increase

#### Spot-Check Validation

**Vendors to manually validate:**
1. Napier AI (known categories, comprehensive text)
2. Silent Eight (sanctions screening specialist)
3. Kount/Equifax (fraud detection)
4. DISCAI (transaction monitoring)
5. Neterium (API-first vendor)

**Validation Checklist per Vendor:**
- [ ] Features extracted match known capabilities
- [ ] Target segments align with stated customer base
- [ ] Geographic coverage matches headquarters + operations
- [ ] Pricing range reasonable for vendor tier
- [ ] Implementation timeline realistic for deployment model

---

### Implementation Guidance

#### Script Execution Flow

1. **Initialize Prisma Client**:
   ```typescript
   const prisma = new PrismaClient();
   const vendors = await prisma.vendor.findMany({
     where: { status: 'APPROVED' }
   });
   ```

2. **Enrich Each Vendor**:
   ```typescript
   const enrichmentPlan = vendors.map(vendor => ({
     id: vendor.id,
     companyName: vendor.companyName,
     before: {
       targetSegments: vendor.targetSegments,
       features: vendor.features,
       // ...
     },
     after: {
       targetSegments: inferTargetSegments(vendor.customerSegments),
       features: extractFeatures(vendor),
       geographicCoverage: mapGeographicCoverage(vendor.headquarters, vendor.dataCoverage),
       pricingRange: estimatePricingRange(vendor),
       implementationTimeline: estimateImplementationTimeline(vendor.deploymentOptions),
     },
     confidence: 'HIGH' | 'MEDIUM' | 'LOW',
   }));
   ```

3. **Output for Review**:
   ```typescript
   fs.writeFileSync(
     'vendor-enrichment-results.json',
     JSON.stringify(enrichmentPlan, null, 2)
   );
   console.log('Enrichment plan generated. Review before applying.');
   ```

4. **Apply Updates** (after manual review):
   ```typescript
   for (const plan of enrichmentPlan) {
     await prisma.vendor.update({
       where: { id: plan.id },
       data: plan.after,
     });
   }
   ```

#### Alternative: AI-Assisted Enrichment

For higher accuracy, use GPT-4 to analyze vendor text:

```typescript
async function enrichVendorWithAI(vendor: Vendor): Promise<EnrichedData> {
  const prompt = `
    Analyze this vendor profile and extract structured metadata:

    Company: ${vendor.companyName}
    Primary Product: ${vendor.primaryProduct}
    AI Capabilities: ${vendor.aiCapabilities}
    Customer Segments: ${vendor.customerSegments}
    Deployment: ${vendor.deploymentOptions}

    Extract:
    1. Features (from capabilities/product): array of feature names
    2. Target Segments (from customer segments): array of [STARTUP, SMB, MIDMARKET, ENTERPRISE]
    3. Geographic Coverage: array of [US, EU, UK, APAC, GLOBAL]
    4. Pricing Range estimate: [UNDER_10K, RANGE_10K_50K, RANGE_50K_100K, RANGE_100K_250K, OVER_250K]
    5. Implementation Timeline estimate: number of days (30-180)

    Return as JSON.
  `;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [{ role: 'user', content: prompt }],
    response_format: { type: 'json_object' },
  });

  return JSON.parse(response.choices[0].message.content);
}
```

---

### Expected Impact

**Before Enrichment (After Stories 1.1 + 1.2 + 1.3):**
- Average Score: 45-60 points (32-43%)
- All vendors have partial credit on missing fields

**After Enrichment (All 4 Stories Complete):**
- Average Score: 70-110 points (50-79%)
- Well-matched vendors score 80-120 points (57-86%)
- Poor-fit vendors score 40-60 points (29-43%)
- Clear differentiation based on actual compatibility

**Example: Napier AI (Perfect Match Scenario):**
| Component | Before | After | Change |
|-----------|--------|-------|--------|
| Risk Coverage (Story 1.1) | 15 | 25 | +10 |
| Size Fit (Story 1.3 → 1.4) | 10 | 20 | +10 |
| Geo Coverage (Story 1.3 → 1.4) | 10 | 20 | +10 |
| Price (Story 1.4) | 10 | 20 | +10 |
| Priority Boost (Story 1.2) | 20 | 20 | 0 |
| Features (Story 1.3 → 1.4) | 5 | 10 | +5 |
| Deployment | 5 | 5 | 0 |
| Speed (Story 1.4) | 0 | 5 | +5 |
| **TOTAL** | **75** | **125** | **+50** |

**Success Metrics:**
- 100% of approved vendors have enriched metadata
- Match scores reflect actual vendor-assessment fit
- Top-matched vendors score 90-125 points
- User feedback: "Vendor recommendations make sense"

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | Initial story creation from Epic 1 | Bob (Scrum Master) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by development agent_

### Debug Log References
_To be filled by development agent_

### Completion Notes List
_To be filled by development agent_

### File List
_To be filled by development agent_

---

## QA Results
_To be filled by QA agent after implementation review_
