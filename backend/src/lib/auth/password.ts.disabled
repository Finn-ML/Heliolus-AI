/**
 * Password hashing and validation utilities
 */

import bcrypt from 'bcryptjs';
import { z } from 'zod';
import { PasswordRequirements, WeakPasswordError, ValidationError } from './types.js';
import { AUTH_CONFIG } from './index.js';

// Validation schemas
const PasswordSchema = z.string()
  .min(AUTH_CONFIG.password.minLength, `Password must be at least ${AUTH_CONFIG.password.minLength} characters`)
  .max(128, 'Password must not exceed 128 characters');

/**
 * Hash password using bcrypt
 */
export async function hashPassword(password: string): Promise<string> {
  try {
    validatePasswordFormat(password);
    return await bcrypt.hash(password, AUTH_CONFIG.password.saltRounds);
  } catch (error) {
    if (error instanceof ValidationError) {
      throw error;
    }
    throw new Error('Failed to hash password');
  }
}

/**
 * Verify password against hash
 */
export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  try {
    if (!password || !hash) {
      return false;
    }
    return await bcrypt.compare(password, hash);
  } catch (error) {
    // Log error but don't expose details
    console.error('Password verification error:', error);
    return false;
  }
}

/**
 * Validate password format and strength
 */
export function validatePasswordFormat(password: string): void {
  // Basic format validation
  const result = PasswordSchema.safeParse(password);
  if (!result.success) {
    throw new ValidationError(result.error.errors[0].message, 'password');
  }

  // Strength validation
  const requirements = validatePasswordStrength(password);
  if (requirements.length > 0) {
    throw new WeakPasswordError(requirements);
  }
}

/**
 * Check password strength requirements
 */
export function validatePasswordStrength(password: string): string[] {
  const requirements: string[] = [];
  const config = AUTH_CONFIG.password;

  if (config.requireUppercase && !/[A-Z]/.test(password)) {
    requirements.push('at least one uppercase letter');
  }

  if (config.requireLowercase && !/[a-z]/.test(password)) {
    requirements.push('at least one lowercase letter');
  }

  if (config.requireNumbers && !/\d/.test(password)) {
    requirements.push('at least one number');
  }

  if (config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    requirements.push('at least one special character');
  }

  return requirements;
}

/**
 * Get password strength score (0-100)
 */
export function getPasswordStrength(password: string): {
  score: number;
  feedback: string[];
  isStrong: boolean;
} {
  const feedback: string[] = [];
  let score = 0;

  // Length scoring
  if (password.length >= 8) score += 20;
  if (password.length >= 12) score += 10;
  if (password.length >= 16) score += 10;

  // Character variety scoring
  if (/[a-z]/.test(password)) score += 10;
  if (/[A-Z]/.test(password)) score += 10;
  if (/\d/.test(password)) score += 10;
  if (/[!@#$%^&*(),.?":{}|<>]/.test(password)) score += 15;

  // Pattern checks
  if (!/(.)\1{2,}/.test(password)) {
    score += 5; // No repeated characters
  } else {
    feedback.push('Avoid repeating characters');
  }

  if (!/^(012|123|234|345|456|567|678|789|890|abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|mno|nop|opq|pqr|qrs|rst|stu|tuv|uvw|vwx|wxy|xyz)/i.test(password)) {
    score += 5; // No sequential characters
  } else {
    feedback.push('Avoid sequential characters');
  }

  // Common password checks (basic)
  const commonPasswords = ['password', '123456', 'qwerty', 'admin', 'login'];
  if (!commonPasswords.some(common => password.toLowerCase().includes(common))) {
    score += 5;
  } else {
    feedback.push('Avoid common passwords');
  }

  // Dictionary word check (simplified)
  if (password.length > 6 && !/^[a-zA-Z]+$/.test(password)) {
    score += 5;
  } else if (/^[a-zA-Z]+$/.test(password)) {
    feedback.push('Consider mixing letters with numbers and symbols');
  }

  // Feedback based on score
  if (score < 30) {
    feedback.unshift('Very weak password');
  } else if (score < 50) {
    feedback.unshift('Weak password');
  } else if (score < 70) {
    feedback.unshift('Fair password');
  } else if (score < 90) {
    feedback.unshift('Good password');
  } else {
    feedback.unshift('Strong password');
  }

  return {
    score: Math.min(score, 100),
    feedback,
    isStrong: score >= 70
  };
}

/**
 * Generate a secure random password
 */
export function generateSecurePassword(length: number = 16): string {
  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const lowercase = 'abcdefghijklmnopqrstuvwxyz';
  const numbers = '0123456789';
  const symbols = '!@#$%^&*(),.?":{}|<>';
  
  const allChars = uppercase + lowercase + numbers + symbols;
  
  let password = '';
  
  // Ensure at least one character from each required category
  if (AUTH_CONFIG.password.requireUppercase) {
    password += uppercase.charAt(Math.floor(Math.random() * uppercase.length));
  }
  if (AUTH_CONFIG.password.requireLowercase) {
    password += lowercase.charAt(Math.floor(Math.random() * lowercase.length));
  }
  if (AUTH_CONFIG.password.requireNumbers) {
    password += numbers.charAt(Math.floor(Math.random() * numbers.length));
  }
  if (AUTH_CONFIG.password.requireSpecialChars) {
    password += symbols.charAt(Math.floor(Math.random() * symbols.length));
  }
  
  // Fill remaining length with random characters
  for (let i = password.length; i < length; i++) {
    password += allChars.charAt(Math.floor(Math.random() * allChars.length));
  }
  
  // Shuffle the password to avoid predictable patterns
  return password.split('').sort(() => Math.random() - 0.5).join('');
}

/**
 * Check if password needs rehashing (e.g., salt rounds changed)
 */
export function needsRehashing(hash: string): boolean {
  try {
    // Extract salt rounds from hash
    const rounds = parseInt(hash.split('$')[2], 10);
    return rounds < AUTH_CONFIG.password.saltRounds;
  } catch {
    return true; // Invalid hash format, needs rehashing
  }
}

/**
 * Validate password change request
 */
export async function validatePasswordChange(
  currentPassword: string,
  newPassword: string,
  currentHash: string
): Promise<void> {
  // Verify current password
  const isCurrentValid = await verifyPassword(currentPassword, currentHash);
  if (!isCurrentValid) {
    throw new ValidationError('Current password is incorrect', 'currentPassword');
  }

  // Validate new password
  validatePasswordFormat(newPassword);

  // Ensure new password is different
  if (currentPassword === newPassword) {
    throw new ValidationError('New password must be different from current password', 'newPassword');
  }
}

/**
 * Generate password reset token (simple random string, not JWT)
 */
export function generatePasswordResetCode(length: number = 32): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  
  return result;
}

/**
 * Hash sensitive data (for tokens, codes, etc.)
 */
export async function hashSensitiveData(data: string): Promise<string> {
  return await bcrypt.hash(data, 10); // Lower rounds for non-password data
}

/**
 * Verify sensitive data against hash
 */
export async function verifySensitiveData(data: string, hash: string): Promise<boolean> {
  try {
    return await bcrypt.compare(data, hash);
  } catch {
    return false;
  }
}