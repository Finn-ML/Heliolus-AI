/**
 * User authentication and management utilities
 */

import { PrismaClient } from '../../generated/prisma/index.js';
import { z } from 'zod';
import {
  AuthUser,
  LoginCredentials,
  RegisterData,
  EmailVerificationData,
  PasswordResetData,
  AuthResult,
  UserNotFoundError,
  InvalidCredentialsError,
  EmailNotVerifiedError,
  AccountSuspendedError,
  DuplicateEmailError,
  ValidationError,
  TokenExpiredError,
  InvalidTokenError
} from './types.js';
import { hashPassword, verifyPassword, validatePasswordFormat } from './password.js';
import { 
  generateTokenPair, 
  generateEmailVerificationToken, 
  generatePasswordResetToken,
  verifyEmailVerificationToken,
  verifyPasswordResetToken
} from './jwt.js';
import { UserRole, UserStatus, CompanySize } from '../../types/database.js';

const prisma = new PrismaClient();

// Validation schemas
const LoginCredentialsSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(1, 'Password is required'),
  rememberMe: z.boolean().optional()
});

const RegisterDataSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  firstName: z.string().min(1, 'First name is required').max(50, 'First name too long'),
  lastName: z.string().min(1, 'Last name is required').max(50, 'Last name too long'),
  organizationName: z.string().min(1).max(100).optional(),
  website: z.string().url().optional(),
  industry: z.string().max(100).optional(),
  country: z.string().min(2, 'Country is required').max(100),
  isVendor: z.boolean().optional()
});

/**
 * Authenticate user with email and password
 */
export async function login(credentials: LoginCredentials): Promise<AuthResult> {
  try {
    // Validate input
    const validCredentials = LoginCredentialsSchema.parse(credentials);

    // Find user by email
    const user = await prisma.user.findUnique({
      where: { email: validCredentials.email.toLowerCase() },
      include: {
        organization: true,
        vendorProfile: true
      }
    });

    if (!user) {
      throw new InvalidCredentialsError();
    }

    // Verify password
    const isPasswordValid = await verifyPassword(validCredentials.password, user.password);
    if (!isPasswordValid) {
      throw new InvalidCredentialsError();
    }

    // Check account status
    if (user.status === UserStatus.SUSPENDED) {
      throw new AccountSuspendedError();
    }

    if (user.status === UserStatus.DELETED) {
      throw new UserNotFoundError();
    }

    // Check email verification for non-admin users
    if (!user.emailVerified && user.role !== UserRole.ADMIN) {
      throw new EmailNotVerifiedError();
    }

    // Update last login
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLogin: new Date() }
    });

    // Generate tokens
    const authUser: AuthUser = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      status: user.status,
      emailVerified: user.emailVerified,
      organizationId: user.organization?.id,
      vendorId: user.vendorProfile?.id,
      lastLogin: new Date(),
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };

    const tokens = generateTokenPair(authUser);

    return {
      success: true,
      data: authUser,
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      message: 'Login successful'
    };

  } catch (error) {
    console.error('Login error:', error);
    
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: error.errors[0].message
      };
    }

    if (error instanceof InvalidCredentialsError || 
        error instanceof EmailNotVerifiedError || 
        error instanceof AccountSuspendedError ||
        error instanceof UserNotFoundError) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: false,
      error: 'Authentication failed'
    };
  }
}

/**
 * Register new user
 */
export async function register(data: RegisterData): Promise<AuthResult> {
  try {
    // Validate input
    const validData = RegisterDataSchema.parse(data);
    
    // Validate password strength
    validatePasswordFormat(validData.password);

    // Check if email already exists
    const existingUser = await prisma.user.findUnique({
      where: { email: validData.email.toLowerCase() }
    });

    if (existingUser) {
      throw new DuplicateEmailError();
    }

    // Hash password
    const hashedPassword = await hashPassword(validData.password);

    // Generate email verification token
    const verificationToken = generateEmailVerificationToken(validData.email.toLowerCase());

    // Determine user role
    const role = validData.isVendor ? UserRole.VENDOR : UserRole.USER;

    // Create user in transaction
    const result = await prisma.$transaction(async (tx) => {
      // Create user
      const user = await tx.user.create({
        data: {
          email: validData.email.toLowerCase(),
          password: hashedPassword,
          firstName: validData.firstName,
          lastName: validData.lastName,
          role,
          emailVerificationToken: verificationToken,
          emailVerified: false
        }
      });

      // Create organization if provided
      if (validData.organizationName && !validData.isVendor) {
        await tx.organization.create({
          data: {
            userId: user.id,
            name: validData.organizationName,
            website: validData.website,
            industry: validData.industry,
            country: validData.country
          }
        });
      }

      // Create vendor profile if vendor
      if (validData.isVendor && validData.organizationName) {
        await tx.vendor.create({
          data: {
            userId: user.id,
            companyName: validData.organizationName,
            website: validData.website || '',
            description: '',
            shortDescription: '',
            contactEmail: user.email,
            categories: []
          }
        });
      }

      return user;
    });

    // TODO: Send verification email
    console.log(`Verification token for ${result.email}: ${verificationToken}`);

    return {
      success: true,
      message: 'Registration successful. Please check your email to verify your account.',
      data: {
        id: result.id,
        email: result.email,
        firstName: result.firstName,
        lastName: result.lastName,
        role: result.role,
        status: result.status,
        emailVerified: result.emailVerified,
        createdAt: result.createdAt,
        updatedAt: result.updatedAt
      }
    };

  } catch (error) {
    console.error('Registration error:', error);
    
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: error.errors[0].message
      };
    }

    if (error instanceof DuplicateEmailError || error instanceof ValidationError) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: false,
      error: 'Registration failed'
    };
  }
}

/**
 * Verify email address
 */
export async function verifyEmail(data: EmailVerificationData): Promise<AuthResult> {
  try {
    // Verify token
    const { email } = verifyEmailVerificationToken(data.token);

    // Find user
    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() }
    });

    if (!user) {
      throw new UserNotFoundError();
    }

    if (user.emailVerified) {
      return {
        success: true,
        message: 'Email already verified'
      };
    }

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id: user.id },
      data: {
        emailVerified: true,
        emailVerificationToken: null
      },
      include: {
        organization: true,
        vendorProfile: true
      }
    });

    const authUser: AuthUser = {
      id: updatedUser.id,
      email: updatedUser.email,
      firstName: updatedUser.firstName,
      lastName: updatedUser.lastName,
      role: updatedUser.role,
      status: updatedUser.status,
      emailVerified: updatedUser.emailVerified,
      organizationId: updatedUser.organization?.id,
      vendorId: updatedUser.vendorProfile?.id,
      lastLogin: updatedUser.lastLogin,
      createdAt: updatedUser.createdAt,
      updatedAt: updatedUser.updatedAt
    };

    const tokens = generateTokenPair(authUser);

    return {
      success: true,
      message: 'Email verified successfully',
      data: authUser,
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken
    };

  } catch (error) {
    console.error('Email verification error:', error);
    
    if (error instanceof TokenExpiredError || error instanceof InvalidTokenError) {
      return {
        success: false,
        error: error.message
      };
    }

    if (error instanceof UserNotFoundError) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: false,
      error: 'Email verification failed'
    };
  }
}

/**
 * Request password reset
 */
export async function requestPasswordReset(email: string): Promise<AuthResult> {
  try {
    // Find user
    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() }
    });

    if (!user) {
      // Don't reveal if email exists
      return {
        success: true,
        message: 'If the email exists, a password reset link has been sent'
      };
    }

    // Generate reset token
    const resetToken = generatePasswordResetToken(user.id, user.email);

    // Save token to database
    await prisma.user.update({
      where: { id: user.id },
      data: {
        passwordResetToken: resetToken,
        passwordResetExpires: new Date(Date.now() + 2 * 60 * 60 * 1000) // 2 hours
      }
    });

    // TODO: Send password reset email
    console.log(`Password reset token for ${user.email}: ${resetToken}`);

    return {
      success: true,
      message: 'If the email exists, a password reset link has been sent'
    };

  } catch (error) {
    console.error('Password reset request error:', error);
    
    return {
      success: false,
      error: 'Password reset request failed'
    };
  }
}

/**
 * Reset password with token
 */
export async function resetPassword(data: PasswordResetData): Promise<AuthResult> {
  try {
    // Verify token
    const { id, email } = verifyPasswordResetToken(data.token);

    // Validate new password
    validatePasswordFormat(data.newPassword);

    // Find user and check token validity
    const user = await prisma.user.findUnique({
      where: { id }
    });

    if (!user || user.email !== email) {
      throw new InvalidTokenError();
    }

    if (!user.passwordResetExpires || user.passwordResetExpires < new Date()) {
      throw new TokenExpiredError();
    }

    // Hash new password
    const hashedPassword = await hashPassword(data.newPassword);

    // Update password and clear reset token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        passwordResetToken: null,
        passwordResetExpires: null
      }
    });

    return {
      success: true,
      message: 'Password reset successful'
    };

  } catch (error) {
    console.error('Password reset error:', error);
    
    if (error instanceof TokenExpiredError || 
        error instanceof InvalidTokenError || 
        error instanceof ValidationError) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: false,
      error: 'Password reset failed'
    };
  }
}

/**
 * Get user profile by ID
 */
export async function getUserProfile(userId: string): Promise<AuthUser | null> {
  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        organization: true,
        vendorProfile: true
      }
    });

    if (!user) {
      return null;
    }

    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      status: user.status,
      emailVerified: user.emailVerified,
      organizationId: user.organization?.id,
      vendorId: user.vendorProfile?.id,
      lastLogin: user.lastLogin,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };

  } catch (error) {
    console.error('Get user profile error:', error);
    return null;
  }
}

/**
 * Update user profile
 */
export async function updateUserProfile(
  userId: string, 
  updates: Partial<Pick<AuthUser, 'firstName' | 'lastName' | 'email'>>
): Promise<AuthResult> {
  try {
    // Validate email if provided
    if (updates.email) {
      z.string().email().parse(updates.email);
      
      // Check if email is already taken
      const existingUser = await prisma.user.findFirst({
        where: {
          email: updates.email.toLowerCase(),
          id: { not: userId }
        }
      });

      if (existingUser) {
        throw new DuplicateEmailError();
      }
    }

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        ...(updates.firstName && { firstName: updates.firstName }),
        ...(updates.lastName && { lastName: updates.lastName }),
        ...(updates.email && { 
          email: updates.email.toLowerCase(),
          emailVerified: false // Reset verification if email changed
        })
      },
      include: {
        organization: true,
        vendorProfile: true
      }
    });

    const authUser: AuthUser = {
      id: updatedUser.id,
      email: updatedUser.email,
      firstName: updatedUser.firstName,
      lastName: updatedUser.lastName,
      role: updatedUser.role,
      status: updatedUser.status,
      emailVerified: updatedUser.emailVerified,
      organizationId: updatedUser.organization?.id,
      vendorId: updatedUser.vendorProfile?.id,
      lastLogin: updatedUser.lastLogin,
      createdAt: updatedUser.createdAt,
      updatedAt: updatedUser.updatedAt
    };

    return {
      success: true,
      data: authUser,
      message: 'Profile updated successfully'
    };

  } catch (error) {
    console.error('Update user profile error:', error);
    
    if (error instanceof z.ZodError) {
      return {
        success: false,
        error: 'Invalid email format'
      };
    }

    if (error instanceof DuplicateEmailError) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: false,
      error: 'Profile update failed'
    };
  }
}

/**
 * Change user password
 */
export async function changePassword(
  userId: string,
  currentPassword: string,
  newPassword: string
): Promise<AuthResult> {
  try {
    // Get current user
    const user = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      throw new UserNotFoundError();
    }

    // Verify current password
    const isCurrentValid = await verifyPassword(currentPassword, user.password);
    if (!isCurrentValid) {
      throw new ValidationError('Current password is incorrect', 'currentPassword');
    }

    // Validate new password
    validatePasswordFormat(newPassword);

    // Ensure new password is different
    if (currentPassword === newPassword) {
      throw new ValidationError('New password must be different from current password', 'newPassword');
    }

    // Hash new password
    const hashedPassword = await hashPassword(newPassword);

    // Update password
    await prisma.user.update({
      where: { id: userId },
      data: { password: hashedPassword }
    });

    return {
      success: true,
      message: 'Password changed successfully'
    };

  } catch (error) {
    console.error('Change password error:', error);
    
    if (error instanceof ValidationError || error instanceof UserNotFoundError) {
      return {
        success: false,
        error: error.message
      };
    }

    return {
      success: false,
      error: 'Password change failed'
    };
  }
}

/**
 * Deactivate user account
 */
export async function deactivateAccount(userId: string): Promise<AuthResult> {
  try {
    await prisma.user.update({
      where: { id: userId },
      data: { status: UserStatus.SUSPENDED }
    });

    return {
      success: true,
      message: 'Account deactivated successfully'
    };

  } catch (error) {
    console.error('Deactivate account error:', error);
    
    return {
      success: false,
      error: 'Account deactivation failed'
    };
  }
}